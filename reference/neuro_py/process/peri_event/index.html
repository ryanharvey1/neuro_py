<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=../intervals/ rel=prev><link href=../precession_utils/ rel=next><link rel=icon href=../../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.7.2"><title>neuro_py.process.peri_event - neuro_py</title><link rel=stylesheet href=../../../../assets/stylesheets/main.484c7ddc.min.css><link rel=stylesheet href=../../../../assets/stylesheets/palette.ab4e12ef.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../../assets/_mkdocstrings.css><link rel=stylesheet href=../../../../stylesheets/extra.css><script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#neuro_py.process.peri_event class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../../.. title=neuro_py class="md-header__button md-logo" aria-label=neuro_py data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> neuro_py </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> neuro_py.process.peri_event </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=light data-md-color-primary=custom data-md-color-accent=custom aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=indigo data-md-color-accent=blue aria-label="Switch to system preference" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to system preference" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/ryanharvey1/neuro_py title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> ryanharvey1/neuro_py </div> </a> </div> </nav> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../.. class=md-tabs__link> Home </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../../ class=md-tabs__link> API Reference </a> </li> <li class=md-tabs__item> <a href=../../../../tutorials/attractor_landscape/ class=md-tabs__link> Tutorials </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../../.. title=neuro_py class="md-nav__button md-logo" aria-label=neuro_py data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> neuro_py </label> <div class=md-nav__source> <a href=https://github.com/ryanharvey1/neuro_py title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> ryanharvey1/neuro_py </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2 checked> <div class="md-nav__link md-nav__container"> <a href=../../ class="md-nav__link "> <span class=md-ellipsis> API Reference </span> </a> <label class="md-nav__link " for=__nav_2 id=__nav_2_label tabindex> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=true> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> API Reference </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_2> <label class=md-nav__link for=__nav_2_2 id=__nav_2_2_label tabindex> <span class=md-ellipsis> behavior </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2_2> <span class="md-nav__icon md-icon"></span> behavior </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../behavior/cheeseboard/ class=md-nav__link> <span class=md-ellipsis> cheeseboard </span> </a> </li> <li class=md-nav__item> <a href=../../behavior/circle_maze/ class=md-nav__link> <span class=md-ellipsis> circle_maze </span> </a> </li> <li class=md-nav__item> <a href=../../behavior/get_trials/ class=md-nav__link> <span class=md-ellipsis> get_trials </span> </a> </li> <li class=md-nav__item> <a href=../../behavior/kinematics/ class=md-nav__link> <span class=md-ellipsis> kinematics </span> </a> </li> <li class=md-nav__item> <a href=../../behavior/linear_positions/ class=md-nav__link> <span class=md-ellipsis> linear_positions </span> </a> </li> <li class=md-nav__item> <a href=../../behavior/linearization/ class=md-nav__link> <span class=md-ellipsis> linearization </span> </a> </li> <li class=md-nav__item> <a href=../../behavior/linearization_pipeline/ class=md-nav__link> <span class=md-ellipsis> linearization_pipeline </span> </a> </li> <li class=md-nav__item> <a href=../../behavior/preprocessing/ class=md-nav__link> <span class=md-ellipsis> preprocessing </span> </a> </li> <li class=md-nav__item> <a href=../../behavior/well_traversal_classification/ class=md-nav__link> <span class=md-ellipsis> well_traversal_classification </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_3> <label class=md-nav__link for=__nav_2_3 id=__nav_2_3_label tabindex> <span class=md-ellipsis> detectors </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_3_label aria-expanded=false> <label class=md-nav__title for=__nav_2_3> <span class="md-nav__icon md-icon"></span> detectors </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../detectors/dentate_spike/ class=md-nav__link> <span class=md-ellipsis> dentate_spike </span> </a> </li> <li class=md-nav__item> <a href=../../detectors/up_down_state/ class=md-nav__link> <span class=md-ellipsis> up_down_state </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_4> <div class="md-nav__link md-nav__container"> <a href=../../ensemble/decoding/ class="md-nav__link "> <span class=md-ellipsis> ensemble </span> </a> <label class="md-nav__link " for=__nav_2_4 id=__nav_2_4_label tabindex> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_4_label aria-expanded=false> <label class=md-nav__title for=__nav_2_4> <span class="md-nav__icon md-icon"></span> ensemble </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../ensemble/assembly/ class=md-nav__link> <span class=md-ellipsis> assembly </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/assembly_reactivation/ class=md-nav__link> <span class=md-ellipsis> assembly_reactivation </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/dynamics/ class=md-nav__link> <span class=md-ellipsis> dynamics </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/explained_variance/ class=md-nav__link> <span class=md-ellipsis> explained_variance </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/geometry/ class=md-nav__link> <span class=md-ellipsis> geometry </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/pairwise_bias_correlation/ class=md-nav__link> <span class=md-ellipsis> pairwise_bias_correlation </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/replay/ class=md-nav__link> <span class=md-ellipsis> replay </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/similarity_index/ class=md-nav__link> <span class=md-ellipsis> similarity_index </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/similaritymat/ class=md-nav__link> <span class=md-ellipsis> similaritymat </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_5> <label class=md-nav__link for=__nav_2_5 id=__nav_2_5_label tabindex> <span class=md-ellipsis> decoding </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_5_label aria-expanded=false> <label class=md-nav__title for=__nav_2_5> <span class="md-nav__icon md-icon"></span> decoding </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../ensemble/decoding/bayesian/ class=md-nav__link> <span class=md-ellipsis> bayesian </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/decoding/lstm/ class=md-nav__link> <span class=md-ellipsis> lstm </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/decoding/m2mlstm/ class=md-nav__link> <span class=md-ellipsis> m2mlstm </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/decoding/mlp/ class=md-nav__link> <span class=md-ellipsis> mlp </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/decoding/pipeline/ class=md-nav__link> <span class=md-ellipsis> pipeline </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/decoding/preprocess/ class=md-nav__link> <span class=md-ellipsis> preprocess </span> </a> </li> <li class=md-nav__item> <a href=../../ensemble/decoding/transformer/ class=md-nav__link> <span class=md-ellipsis> transformer </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_6> <label class=md-nav__link for=__nav_2_6 id=__nav_2_6_label tabindex> <span class=md-ellipsis> io </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_6_label aria-expanded=false> <label class=md-nav__title for=__nav_2_6> <span class="md-nav__icon md-icon"></span> io </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../io/loading/ class=md-nav__link> <span class=md-ellipsis> loading </span> </a> </li> <li class=md-nav__item> <a href=../../io/saving/ class=md-nav__link> <span class=md-ellipsis> saving </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_7> <label class=md-nav__link for=__nav_2_7 id=__nav_2_7_label tabindex> <span class=md-ellipsis> lfp </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_7_label aria-expanded=false> <label class=md-nav__title for=__nav_2_7> <span class="md-nav__icon md-icon"></span> lfp </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../lfp/CSD/ class=md-nav__link> <span class=md-ellipsis> CSD </span> </a> </li> <li class=md-nav__item> <a href=../../lfp/preprocessing/ class=md-nav__link> <span class=md-ellipsis> preprocessing </span> </a> </li> <li class=md-nav__item> <a href=../../lfp/spectral/ class=md-nav__link> <span class=md-ellipsis> spectral </span> </a> </li> <li class=md-nav__item> <a href=../../lfp/theta_cycles/ class=md-nav__link> <span class=md-ellipsis> theta_cycles </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_8> <label class=md-nav__link for=__nav_2_8 id=__nav_2_8_label tabindex> <span class=md-ellipsis> plotting </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_8_label aria-expanded=false> <label class=md-nav__title for=__nav_2_8> <span class="md-nav__icon md-icon"></span> plotting </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../plotting/decorators/ class=md-nav__link> <span class=md-ellipsis> decorators </span> </a> </li> <li class=md-nav__item> <a href=../../plotting/events/ class=md-nav__link> <span class=md-ellipsis> events </span> </a> </li> <li class=md-nav__item> <a href=../../plotting/figure_helpers/ class=md-nav__link> <span class=md-ellipsis> figure_helpers </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_9 checked> <label class=md-nav__link for=__nav_2_9 id=__nav_2_9_label tabindex> <span class=md-ellipsis> process </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_9_label aria-expanded=true> <label class=md-nav__title for=__nav_2_9> <span class="md-nav__icon md-icon"></span> process </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../batch_analysis/ class=md-nav__link> <span class=md-ellipsis> batch_analysis </span> </a> </li> <li class=md-nav__item> <a href=../correlations/ class=md-nav__link> <span class=md-ellipsis> correlations </span> </a> </li> <li class=md-nav__item> <a href=../intervals/ class=md-nav__link> <span class=md-ellipsis> intervals </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> peri_event </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> peri_event </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#neuro_py.process.peri_event class=md-nav__link> <span class=md-ellipsis> peri_event </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event._sync_fill_indices class=md-nav__link> <span class=md-ellipsis> _sync_fill_indices </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event._sync_find_windows class=md-nav__link> <span class=md-ellipsis> _sync_find_windows </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.compute_psth class=md-nav__link> <span class=md-ellipsis> compute_psth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.count_events class=md-nav__link> <span class=md-ellipsis> count_events </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.count_in_interval class=md-nav__link> <span class=md-ellipsis> count_in_interval </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.crossCorr class=md-nav__link> <span class=md-ellipsis> crossCorr </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.deconvolve_peth class=md-nav__link> <span class=md-ellipsis> deconvolve_peth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.event_spiking_threshold class=md-nav__link> <span class=md-ellipsis> event_spiking_threshold </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.event_triggered_average class=md-nav__link> <span class=md-ellipsis> event_triggered_average </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.event_triggered_average_fast class=md-nav__link> <span class=md-ellipsis> event_triggered_average_fast </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.event_triggered_average_irregular_sample class=md-nav__link> <span class=md-ellipsis> event_triggered_average_irregular_sample </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.get_rank_order class=md-nav__link> <span class=md-ellipsis> get_rank_order </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.get_raster_points class=md-nav__link> <span class=md-ellipsis> get_raster_points </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.joint_peth class=md-nav__link> <span class=md-ellipsis> joint_peth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.nearest_event_delay class=md-nav__link> <span class=md-ellipsis> nearest_event_delay </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.peth class=md-nav__link> <span class=md-ellipsis> peth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.peth_matrix class=md-nav__link> <span class=md-ellipsis> peth_matrix </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.relative_times class=md-nav__link> <span class=md-ellipsis> relative_times </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.sync class=md-nav__link> <span class=md-ellipsis> sync </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../precession_utils/ class=md-nav__link> <span class=md-ellipsis> precession_utils </span> </a> </li> <li class=md-nav__item> <a href=../pychronux/ class=md-nav__link> <span class=md-ellipsis> pychronux </span> </a> </li> <li class=md-nav__item> <a href=../utils/ class=md-nav__link> <span class=md-ellipsis> utils </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_10> <label class=md-nav__link for=__nav_2_10 id=__nav_2_10_label tabindex> <span class=md-ellipsis> raw </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_10_label aria-expanded=false> <label class=md-nav__title for=__nav_2_10> <span class="md-nav__icon md-icon"></span> raw </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../raw/preprocessing/ class=md-nav__link> <span class=md-ellipsis> preprocessing </span> </a> </li> <li class=md-nav__item> <a href=../../raw/spike_sorting/ class=md-nav__link> <span class=md-ellipsis> spike_sorting </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_11> <label class=md-nav__link for=__nav_2_11 id=__nav_2_11_label tabindex> <span class=md-ellipsis> session </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_11_label aria-expanded=false> <label class=md-nav__title for=__nav_2_11> <span class="md-nav__icon md-icon"></span> session </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../session/locate_epochs/ class=md-nav__link> <span class=md-ellipsis> locate_epochs </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_12> <label class=md-nav__link for=__nav_2_12 id=__nav_2_12_label tabindex> <span class=md-ellipsis> spikes </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_12_label aria-expanded=false> <label class=md-nav__title for=__nav_2_12> <span class="md-nav__icon md-icon"></span> spikes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../spikes/spike_tools/ class=md-nav__link> <span class=md-ellipsis> spike_tools </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_13> <label class=md-nav__link for=__nav_2_13 id=__nav_2_13_label tabindex> <span class=md-ellipsis> stats </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_13_label aria-expanded=false> <label class=md-nav__title for=__nav_2_13> <span class="md-nav__icon md-icon"></span> stats </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../stats/circ_stats/ class=md-nav__link> <span class=md-ellipsis> circ_stats </span> </a> </li> <li class=md-nav__item> <a href=../../stats/regression/ class=md-nav__link> <span class=md-ellipsis> regression </span> </a> </li> <li class=md-nav__item> <a href=../../stats/stats/ class=md-nav__link> <span class=md-ellipsis> stats </span> </a> </li> <li class=md-nav__item> <a href=../../stats/system_identifier/ class=md-nav__link> <span class=md-ellipsis> system_identifier </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_14> <label class=md-nav__link for=__nav_2_14 id=__nav_2_14_label tabindex> <span class=md-ellipsis> tuning </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_14_label aria-expanded=false> <label class=md-nav__title for=__nav_2_14> <span class="md-nav__icon md-icon"></span> tuning </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../tuning/fields/ class=md-nav__link> <span class=md-ellipsis> fields </span> </a> </li> <li class=md-nav__item> <a href=../../tuning/maps/ class=md-nav__link> <span class=md-ellipsis> maps </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_15> <label class=md-nav__link for=__nav_2_15 id=__nav_2_15_label tabindex> <span class=md-ellipsis> util </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_15_label aria-expanded=false> <label class=md-nav__title for=__nav_2_15> <span class="md-nav__icon md-icon"></span> util </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../util/array/ class=md-nav__link> <span class=md-ellipsis> array </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Tutorials </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Tutorials </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../../tutorials/attractor_landscape/ class=md-nav__link> <span class=md-ellipsis> Attractor Estimation </span> </a> </li> <li class=md-nav__item> <a href=../../../../tutorials/batch_analysis/ class=md-nav__link> <span class=md-ellipsis> Batch Analysis </span> </a> </li> <li class=md-nav__item> <a href=../../../../tutorials/bias_correlation/ class=md-nav__link> <span class=md-ellipsis> Bias Correlation </span> </a> </li> <li class=md-nav__item> <a href=../../../../tutorials/explained_variance/ class=md-nav__link> <span class=md-ellipsis> Explained Variance </span> </a> </li> <li class=md-nav__item> <a href=../../../../tutorials/decoding/ class=md-nav__link> <span class=md-ellipsis> Neural Decoding </span> </a> </li> <li class=md-nav__item> <a href=../../../../tutorials/neural_geodynamics/ class=md-nav__link> <span class=md-ellipsis> Neural Geodynamics </span> </a> </li> <li class=md-nav__item> <a href=../../../../tutorials/peth_tutorial/ class=md-nav__link> <span class=md-ellipsis> PETH </span> </a> </li> <li class=md-nav__item> <a href=../../../../tutorials/reactivation/ class=md-nav__link> <span class=md-ellipsis> Reactivation </span> </a> </li> <li class=md-nav__item> <a href=../../../../tutorials/spatial_map/ class=md-nav__link> <span class=md-ellipsis> Spatial Map </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#neuro_py.process.peri_event class=md-nav__link> <span class=md-ellipsis> peri_event </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event._sync_fill_indices class=md-nav__link> <span class=md-ellipsis> _sync_fill_indices </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event._sync_find_windows class=md-nav__link> <span class=md-ellipsis> _sync_find_windows </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.compute_psth class=md-nav__link> <span class=md-ellipsis> compute_psth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.count_events class=md-nav__link> <span class=md-ellipsis> count_events </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.count_in_interval class=md-nav__link> <span class=md-ellipsis> count_in_interval </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.crossCorr class=md-nav__link> <span class=md-ellipsis> crossCorr </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.deconvolve_peth class=md-nav__link> <span class=md-ellipsis> deconvolve_peth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.event_spiking_threshold class=md-nav__link> <span class=md-ellipsis> event_spiking_threshold </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.event_triggered_average class=md-nav__link> <span class=md-ellipsis> event_triggered_average </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.event_triggered_average_fast class=md-nav__link> <span class=md-ellipsis> event_triggered_average_fast </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.event_triggered_average_irregular_sample class=md-nav__link> <span class=md-ellipsis> event_triggered_average_irregular_sample </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.get_rank_order class=md-nav__link> <span class=md-ellipsis> get_rank_order </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.get_raster_points class=md-nav__link> <span class=md-ellipsis> get_raster_points </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.joint_peth class=md-nav__link> <span class=md-ellipsis> joint_peth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.nearest_event_delay class=md-nav__link> <span class=md-ellipsis> nearest_event_delay </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.peth class=md-nav__link> <span class=md-ellipsis> peth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.peth_matrix class=md-nav__link> <span class=md-ellipsis> peth_matrix </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.relative_times class=md-nav__link> <span class=md-ellipsis> relative_times </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peri_event.sync class=md-nav__link> <span class=md-ellipsis> sync </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <nav class=md-path aria-label=Navigation> <ol class=md-path__list> <li class=md-path__item> <a href=../../../.. class=md-path__link> <span class=md-ellipsis> Home </span> </a> </li> <li class=md-path__item> <a href=../../behavior/ class=md-path__link> <span class=md-ellipsis> API Reference </span> </a> </li> <li class=md-path__item> <a href=../batch_analysis/ class=md-path__link> <span class=md-ellipsis> process </span> </a> </li> </ol> </nav> <article class="md-content__inner md-typeset"> <a href=https://github.com/ryanharvey1/neuro_py/edit/main/docs/neuro_py/process/peri_event.py title="Edit this page" class="md-content__button md-icon" rel=edit> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg> </a> <a href=https://github.com/ryanharvey1/neuro_py/raw/main/docs/neuro_py/process/peri_event.py title="View source of this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"/></svg> </a> <h1> peri_event</h1> <div class="doc doc-object doc-module"> <a id=neuro_py.process.peri_event></a> <div class="doc doc-contents first"> <div class="doc doc-children"> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event._sync_fill_indices class="doc doc-heading"> <code class="highlight language-python"><span class=n>_sync_fill_indices</span><span class=p>(</span><span class=n>starts</span><span class=p>,</span> <span class=n>stops</span><span class=p>,</span> <span class=n>events_with_hits</span><span class=p>,</span> <span class=n>total_hits</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Numba-compiled function to fill Is and Ie index arrays.</p> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>526</span>
<span class=normal>527</span>
<span class=normal>528</span>
<span class=normal>529</span>
<span class=normal>530</span>
<span class=normal>531</span>
<span class=normal>532</span>
<span class=normal>533</span>
<span class=normal>534</span>
<span class=normal>535</span>
<span class=normal>536</span>
<span class=normal>537</span>
<span class=normal>538</span>
<span class=normal>539</span>
<span class=normal>540</span>
<span class=normal>541</span>
<span class=normal>542</span>
<span class=normal>543</span>
<span class=normal>544</span>
<span class=normal>545</span>
<span class=normal>546</span>
<span class=normal>547</span>
<span class=normal>548</span>
<span class=normal>549</span>
<span class=normal>550</span>
<span class=normal>551</span>
<span class=normal>552</span>
<span class=normal>553</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>_sync_fill_indices</span><span class=p>(</span>
    <span class=n>starts</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>stops</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>events_with_hits</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>total_hits</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Numba-compiled function to fill Is and Ie index arrays.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>Is</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=n>total_hits</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>int64</span><span class=p>)</span>
    <span class=n>Ie</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=n>total_hits</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>int64</span><span class=p>)</span>

    <span class=n>write_pos</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>starts</span><span class=p>)):</span>
        <span class=n>start_idx</span> <span class=o>=</span> <span class=n>starts</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
        <span class=n>stop_idx</span> <span class=o>=</span> <span class=n>stops</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
        <span class=n>event_i</span> <span class=o>=</span> <span class=n>events_with_hits</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
        <span class=n>run_len</span> <span class=o>=</span> <span class=n>stop_idx</span> <span class=o>-</span> <span class=n>start_idx</span>

        <span class=c1># Fill this segment</span>
        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>run_len</span><span class=p>):</span>
            <span class=n>Is</span><span class=p>[</span><span class=n>write_pos</span> <span class=o>+</span> <span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>start_idx</span> <span class=o>+</span> <span class=n>j</span>
            <span class=n>Ie</span><span class=p>[</span><span class=n>write_pos</span> <span class=o>+</span> <span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>event_i</span>

        <span class=n>write_pos</span> <span class=o>+=</span> <span class=n>run_len</span>

    <span class=k>return</span> <span class=n>Is</span><span class=p>,</span> <span class=n>Ie</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event._sync_find_windows class="doc doc-heading"> <code class="highlight language-python"><span class=n>_sync_find_windows</span><span class=p>(</span><span class=n>sample_times</span><span class=p>,</span> <span class=n>event_times</span><span class=p>,</span> <span class=n>start_offset</span><span class=p>,</span> <span class=n>stop_offset</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Numba-compiled function to find time windows for each event.</p> <p>Returns arrays of starts, stops, events_with_hits, and total_hits count.</p> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>468</span>
<span class=normal>469</span>
<span class=normal>470</span>
<span class=normal>471</span>
<span class=normal>472</span>
<span class=normal>473</span>
<span class=normal>474</span>
<span class=normal>475</span>
<span class=normal>476</span>
<span class=normal>477</span>
<span class=normal>478</span>
<span class=normal>479</span>
<span class=normal>480</span>
<span class=normal>481</span>
<span class=normal>482</span>
<span class=normal>483</span>
<span class=normal>484</span>
<span class=normal>485</span>
<span class=normal>486</span>
<span class=normal>487</span>
<span class=normal>488</span>
<span class=normal>489</span>
<span class=normal>490</span>
<span class=normal>491</span>
<span class=normal>492</span>
<span class=normal>493</span>
<span class=normal>494</span>
<span class=normal>495</span>
<span class=normal>496</span>
<span class=normal>497</span>
<span class=normal>498</span>
<span class=normal>499</span>
<span class=normal>500</span>
<span class=normal>501</span>
<span class=normal>502</span>
<span class=normal>503</span>
<span class=normal>504</span>
<span class=normal>505</span>
<span class=normal>506</span>
<span class=normal>507</span>
<span class=normal>508</span>
<span class=normal>509</span>
<span class=normal>510</span>
<span class=normal>511</span>
<span class=normal>512</span>
<span class=normal>513</span>
<span class=normal>514</span>
<span class=normal>515</span>
<span class=normal>516</span>
<span class=normal>517</span>
<span class=normal>518</span>
<span class=normal>519</span>
<span class=normal>520</span>
<span class=normal>521</span>
<span class=normal>522</span>
<span class=normal>523</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>_sync_find_windows</span><span class=p>(</span>
    <span class=n>sample_times</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>event_times</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>start_offset</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
    <span class=n>stop_offset</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=nb>int</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Numba-compiled function to find time windows for each event.</span>

<span class=sd>    Returns arrays of starts, stops, events_with_hits, and total_hits count.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>n_samples</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>sample_times</span><span class=p>)</span>
    <span class=n>n_events</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>event_times</span><span class=p>)</span>

    <span class=c1># Pre-allocate maximum possible size</span>
    <span class=n>starts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=n>n_events</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>int64</span><span class=p>)</span>
    <span class=n>stops</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=n>n_events</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>int64</span><span class=p>)</span>
    <span class=n>events_with_hits</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=n>n_events</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>int64</span><span class=p>)</span>

    <span class=n>n_hits</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>total_hits</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>left_idx</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>right_idx</span> <span class=o>=</span> <span class=mi>0</span>

    <span class=k>for</span> <span class=n>event_i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n_events</span><span class=p>):</span>
        <span class=n>event_t</span> <span class=o>=</span> <span class=n>event_times</span><span class=p>[</span><span class=n>event_i</span><span class=p>]</span>
        <span class=n>start_t</span> <span class=o>=</span> <span class=n>event_t</span> <span class=o>+</span> <span class=n>start_offset</span>
        <span class=n>stop_t</span> <span class=o>=</span> <span class=n>event_t</span> <span class=o>+</span> <span class=n>stop_offset</span>

        <span class=c1># Advance left pointer</span>
        <span class=k>while</span> <span class=n>left_idx</span> <span class=o>&lt;</span> <span class=n>n_samples</span> <span class=ow>and</span> <span class=n>sample_times</span><span class=p>[</span><span class=n>left_idx</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>start_t</span><span class=p>:</span>
            <span class=n>left_idx</span> <span class=o>+=</span> <span class=mi>1</span>

        <span class=c1># Ensure right_idx is at least left_idx</span>
        <span class=k>if</span> <span class=n>right_idx</span> <span class=o>&lt;</span> <span class=n>left_idx</span><span class=p>:</span>
            <span class=n>right_idx</span> <span class=o>=</span> <span class=n>left_idx</span>

        <span class=c1># Advance right pointer</span>
        <span class=k>while</span> <span class=n>right_idx</span> <span class=o>&lt;</span> <span class=n>n_samples</span> <span class=ow>and</span> <span class=n>sample_times</span><span class=p>[</span><span class=n>right_idx</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>stop_t</span><span class=p>:</span>
            <span class=n>right_idx</span> <span class=o>+=</span> <span class=mi>1</span>

        <span class=c1># Record if we found any samples in this window</span>
        <span class=k>if</span> <span class=n>right_idx</span> <span class=o>&gt;</span> <span class=n>left_idx</span><span class=p>:</span>
            <span class=n>starts</span><span class=p>[</span><span class=n>n_hits</span><span class=p>]</span> <span class=o>=</span> <span class=n>left_idx</span>
            <span class=n>stops</span><span class=p>[</span><span class=n>n_hits</span><span class=p>]</span> <span class=o>=</span> <span class=n>right_idx</span>
            <span class=n>events_with_hits</span><span class=p>[</span><span class=n>n_hits</span><span class=p>]</span> <span class=o>=</span> <span class=n>event_i</span>
            <span class=n>total_hits</span> <span class=o>+=</span> <span class=n>right_idx</span> <span class=o>-</span> <span class=n>left_idx</span>
            <span class=n>n_hits</span> <span class=o>+=</span> <span class=mi>1</span>

    <span class=c1># Trim arrays to actual size</span>
    <span class=n>starts</span> <span class=o>=</span> <span class=n>starts</span><span class=p>[:</span><span class=n>n_hits</span><span class=p>]</span>
    <span class=n>stops</span> <span class=o>=</span> <span class=n>stops</span><span class=p>[:</span><span class=n>n_hits</span><span class=p>]</span>
    <span class=n>events_with_hits</span> <span class=o>=</span> <span class=n>events_with_hits</span><span class=p>[:</span><span class=n>n_hits</span><span class=p>]</span>

    <span class=k>return</span> <span class=n>starts</span><span class=p>,</span> <span class=n>stops</span><span class=p>,</span> <span class=n>events_with_hits</span><span class=p>,</span> <span class=n>total_hits</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.compute_psth class="doc doc-heading"> <code class="highlight language-python"><span class=n>compute_psth</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>event</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the Peri-Stimulus Time Histogram (PSTH) for discrete-time events.</p> <p>This function calculates the PSTH for a given set of discrete-time events (e.g. spike times) aligned to specific reference events. The PSTH provides time-resolved <strong>rates (Hz)</strong> in response to the events over a defined time window.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of discrete-time events (e.g. spike times) for multiple trials, with each trial in a separate row.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>event</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of reference event times to which the data are aligned.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Width of each time bin in seconds (default is 0.002 seconds).</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of bins to create for the histogram (default is 100).</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>Time window around each event to consider for the PSTH. If None, a symmetric window is created based on <code>n_bins</code> and <code>bin_width</code>.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>A DataFrame containing the PSTH, indexed by time bins and columns representing each trial's PSTH.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>If the specified window is not symmetric around 0, it is adjusted to be symmetric. Each trial's times must be sorted in ascending order. This function relies on <code>crossCorr</code>, which uses binary search and assumes sorted input.</p> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>spikes</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.15</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>],</span> <span class=p>[</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.12</span><span class=p>,</span> <span class=mf>0.13</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>event</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>psth</span> <span class=o>=</span> <span class=n>compute_psth</span><span class=p>(</span><span class=n>spikes</span><span class=p>,</span> <span class=n>event</span><span class=p>)</span>
</code></pre></div> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>112</span>
<span class=normal>113</span>
<span class=normal>114</span>
<span class=normal>115</span>
<span class=normal>116</span>
<span class=normal>117</span>
<span class=normal>118</span>
<span class=normal>119</span>
<span class=normal>120</span>
<span class=normal>121</span>
<span class=normal>122</span>
<span class=normal>123</span>
<span class=normal>124</span>
<span class=normal>125</span>
<span class=normal>126</span>
<span class=normal>127</span>
<span class=normal>128</span>
<span class=normal>129</span>
<span class=normal>130</span>
<span class=normal>131</span>
<span class=normal>132</span>
<span class=normal>133</span>
<span class=normal>134</span>
<span class=normal>135</span>
<span class=normal>136</span>
<span class=normal>137</span>
<span class=normal>138</span>
<span class=normal>139</span>
<span class=normal>140</span>
<span class=normal>141</span>
<span class=normal>142</span>
<span class=normal>143</span>
<span class=normal>144</span>
<span class=normal>145</span>
<span class=normal>146</span>
<span class=normal>147</span>
<span class=normal>148</span>
<span class=normal>149</span>
<span class=normal>150</span>
<span class=normal>151</span>
<span class=normal>152</span>
<span class=normal>153</span>
<span class=normal>154</span>
<span class=normal>155</span>
<span class=normal>156</span>
<span class=normal>157</span>
<span class=normal>158</span>
<span class=normal>159</span>
<span class=normal>160</span>
<span class=normal>161</span>
<span class=normal>162</span>
<span class=normal>163</span>
<span class=normal>164</span>
<span class=normal>165</span>
<span class=normal>166</span>
<span class=normal>167</span>
<span class=normal>168</span>
<span class=normal>169</span>
<span class=normal>170</span>
<span class=normal>171</span>
<span class=normal>172</span>
<span class=normal>173</span>
<span class=normal>174</span>
<span class=normal>175</span>
<span class=normal>176</span>
<span class=normal>177</span>
<span class=normal>178</span>
<span class=normal>179</span>
<span class=normal>180</span>
<span class=normal>181</span>
<span class=normal>182</span>
<span class=normal>183</span>
<span class=normal>184</span>
<span class=normal>185</span>
<span class=normal>186</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>compute_psth</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>event</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=nb>list</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the Peri-Stimulus Time Histogram (PSTH) for discrete-time events.</span>

<span class=sd>    This function calculates the PSTH for a given set of discrete-time events</span>
<span class=sd>    (e.g. spike times) aligned to specific reference events. The PSTH provides</span>
<span class=sd>    time-resolved **rates (Hz)** in response to the events over a defined time window.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray</span>
<span class=sd>        An array of discrete-time events (e.g. spike times) for multiple trials,</span>
<span class=sd>        with each trial in a separate row.</span>
<span class=sd>    event : np.ndarray</span>
<span class=sd>        An array of reference event times to which the data are aligned.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        Width of each time bin in seconds (default is 0.002 seconds).</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        Number of bins to create for the histogram (default is 100).</span>
<span class=sd>    window : list, optional</span>
<span class=sd>        Time window around each event to consider for the PSTH. If None, a</span>
<span class=sd>        symmetric window is created based on `n_bins` and `bin_width`.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame</span>
<span class=sd>        A DataFrame containing the PSTH, indexed by time bins and columns</span>
<span class=sd>        representing each trial&#39;s PSTH.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    If the specified window is not symmetric around 0, it is adjusted to be symmetric.</span>
<span class=sd>    Each trial&#39;s times must be sorted in ascending order. This function</span>
<span class=sd>    relies on `crossCorr`, which uses binary search and assumes sorted input.</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; spikes = np.array([[0.1, 0.15, 0.2], [0.1, 0.12, 0.13]])</span>
<span class=sd>    &gt;&gt;&gt; event = np.array([0.1, 0.3])</span>
<span class=sd>    &gt;&gt;&gt; psth = compute_psth(spikes, event)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>window_original</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=c1># check if window is symmetric around 0, if not make it so</span>
        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>/</span> <span class=mf>2.0</span>
        <span class=n>is_symmetric</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>isclose</span><span class=p>(</span><span class=n>mid</span><span class=p>,</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=ow>and</span> <span class=n>np</span><span class=o>.</span><span class=n>isclose</span><span class=p>(</span><span class=o>-</span><span class=n>mid</span><span class=p>,</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=n>is_symmetric</span><span class=p>:</span>
            <span class=n>window_original</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>window</span><span class=p>)</span>
            <span class=n>window</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>window</span><span class=p>)),</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>window</span><span class=p>))]</span>

        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
        <span class=n>n_bins</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=p>)</span>

    <span class=n>ccg</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)))</span>
    <span class=c1># Now we can iterate over trials</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
        <span class=c1># Ensure spike times are float64 for numba compatibility</span>
        <span class=n>s</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>
        <span class=n>ccg</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>event</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span><span class=p>)</span>

    <span class=c1># if window was not symmetric, remove the extra bins</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>window_original</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>ccg</span> <span class=o>=</span> <span class=n>ccg</span><span class=o>.</span><span class=n>loc</span><span class=p>[</span><span class=n>window_original</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>:</span> <span class=n>window_original</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=p>:]</span>
    <span class=k>return</span> <span class=n>ccg</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.count_events class="doc doc-heading"> <code class="highlight language-python"><span class=n>count_events</span><span class=p>(</span><span class=n>events</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>,</span> <span class=n>time_range</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Count the number of events that occur within a given time range after each reference event.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of event times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_ref</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of reference times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_range</code> </td> <td> <code>tuple of (float, float)</code> </td> <td> <div class=doc-md-description> <p>A tuple containing the start and end times of the time range.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>counts</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of event counts, one for each reference time (same length as time_ref).</p> </div> </td> </tr> </tbody> </table> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1599</span>
<span class=normal>1600</span>
<span class=normal>1601</span>
<span class=normal>1602</span>
<span class=normal>1603</span>
<span class=normal>1604</span>
<span class=normal>1605</span>
<span class=normal>1606</span>
<span class=normal>1607</span>
<span class=normal>1608</span>
<span class=normal>1609</span>
<span class=normal>1610</span>
<span class=normal>1611</span>
<span class=normal>1612</span>
<span class=normal>1613</span>
<span class=normal>1614</span>
<span class=normal>1615</span>
<span class=normal>1616</span>
<span class=normal>1617</span>
<span class=normal>1618</span>
<span class=normal>1619</span>
<span class=normal>1620</span>
<span class=normal>1621</span>
<span class=normal>1622</span>
<span class=normal>1623</span>
<span class=normal>1624</span>
<span class=normal>1625</span>
<span class=normal>1626</span>
<span class=normal>1627</span>
<span class=normal>1628</span>
<span class=normal>1629</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>count_events</span><span class=p>(</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>time_range</span><span class=p>:</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Count the number of events that occur within a given time range after each reference event.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    events : np.ndarray</span>
<span class=sd>        A 1D array of event times.</span>
<span class=sd>    time_ref : np.ndarray</span>
<span class=sd>        A 1D array of reference times.</span>
<span class=sd>    time_range : tuple of (float, float)</span>
<span class=sd>        A tuple containing the start and end times of the time range.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    counts : np.ndarray</span>
<span class=sd>        A 1D array of event counts, one for each reference time (same length as time_ref).</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Initialize an array to store the event counts</span>
    <span class=n>counts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros_like</span><span class=p>(</span><span class=n>time_ref</span><span class=p>)</span>

    <span class=c1># Iterate over the reference times</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>time_ref</span><span class=p>):</span>
        <span class=c1># Check if any events occur within the time range</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=p>(</span><span class=n>events</span> <span class=o>&gt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>time_range</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>events</span> <span class=o>&lt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>time_range</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
        <span class=c1># Increment the event count if any events are found</span>
        <span class=n>counts</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span>

    <span class=k>return</span> <span class=n>counts</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.count_in_interval class="doc doc-heading"> <code class="highlight language-python"><span class=n>count_in_interval</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>event_starts</span><span class=p>,</span> <span class=n>event_stops</span><span class=p>,</span> <span class=n>par_type</span><span class=o>=</span><span class=s1>&#39;counts&#39;</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Count discrete-time events in specified intervals and return a matrix where each column represents counts for each discrete-time event series over given epochs.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A jagged array where each element contains discrete-time events times for a series (e.g. spike times for a neuron). (n series x variable length event times).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>event_starts</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array containing the start times of events.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>event_stops</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array containing the stop times of events.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>par_type</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>The type of count calculation to perform: - 'counts': returns raw counts of spikes in the intervals. - 'binary': returns a binary matrix indicating presence (1) or absence (0) of spikes. - 'rate': returns the firing rate calculated as counts divided by the interval duration. Defaults to 'binary'.</p> </div> </td> <td> <code>&#39;counts&#39;</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array (n series x n epochs) where each column shows the counts (or binary values or rates) per series for each epoch.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span><span class=w> </span><span class=nn>numpy</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>np</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># Create spike trains for 3 units with different spike times</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>unit_1_spikes</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>1.2</span><span class=p>,</span> <span class=mf>1.8</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>unit_2_spikes</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>,</span> <span class=mf>1.5</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>unit_3_spikes</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.05</span><span class=p>,</span> <span class=mf>0.4</span><span class=p>,</span> <span class=mf>0.9</span><span class=p>,</span> <span class=mf>1.1</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>unit_1_spikes</span><span class=p>,</span> <span class=n>unit_2_spikes</span><span class=p>,</span> <span class=n>unit_3_spikes</span><span class=p>],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>object</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># Define two events with their start and stop times</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>event_starts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>event_stops</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.7</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># Count spikes in each interval</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>counts</span> <span class=o>=</span> <span class=n>count_in_interval</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>event_starts</span><span class=p>,</span> <span class=n>event_stops</span><span class=p>,</span> <span class=n>par_type</span><span class=o>=</span><span class=s1>&#39;counts&#39;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>counts</span><span class=p>)</span>
<span class=go>[[3. 2.]</span>
<span class=go> [1. 1.]</span>
<span class=go> [2. 1.]]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># Get binary presence/absence</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>binary</span> <span class=o>=</span> <span class=n>count_in_interval</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>event_starts</span><span class=p>,</span> <span class=n>event_stops</span><span class=p>,</span> <span class=n>par_type</span><span class=o>=</span><span class=s1>&#39;binary&#39;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>binary</span><span class=p>)</span>
<span class=go>[[1. 1.]</span>
<span class=go> [1. 1.]</span>
<span class=go> [1. 1.]]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># Calculate firing rates</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>rates</span> <span class=o>=</span> <span class=n>count_in_interval</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>event_starts</span><span class=p>,</span> <span class=n>event_stops</span><span class=p>,</span> <span class=n>par_type</span><span class=o>=</span><span class=s1>&#39;firing_rate&#39;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>rates</span><span class=p>)</span>
<span class=go>[[4.28571429 2.   ]</span>
<span class=go> [1.42857143 1.   ]</span>
<span class=go> [2.85714286 1.   ]]</span>
</code></pre></div> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1316</span>
<span class=normal>1317</span>
<span class=normal>1318</span>
<span class=normal>1319</span>
<span class=normal>1320</span>
<span class=normal>1321</span>
<span class=normal>1322</span>
<span class=normal>1323</span>
<span class=normal>1324</span>
<span class=normal>1325</span>
<span class=normal>1326</span>
<span class=normal>1327</span>
<span class=normal>1328</span>
<span class=normal>1329</span>
<span class=normal>1330</span>
<span class=normal>1331</span>
<span class=normal>1332</span>
<span class=normal>1333</span>
<span class=normal>1334</span>
<span class=normal>1335</span>
<span class=normal>1336</span>
<span class=normal>1337</span>
<span class=normal>1338</span>
<span class=normal>1339</span>
<span class=normal>1340</span>
<span class=normal>1341</span>
<span class=normal>1342</span>
<span class=normal>1343</span>
<span class=normal>1344</span>
<span class=normal>1345</span>
<span class=normal>1346</span>
<span class=normal>1347</span>
<span class=normal>1348</span>
<span class=normal>1349</span>
<span class=normal>1350</span>
<span class=normal>1351</span>
<span class=normal>1352</span>
<span class=normal>1353</span>
<span class=normal>1354</span>
<span class=normal>1355</span>
<span class=normal>1356</span>
<span class=normal>1357</span>
<span class=normal>1358</span>
<span class=normal>1359</span>
<span class=normal>1360</span>
<span class=normal>1361</span>
<span class=normal>1362</span>
<span class=normal>1363</span>
<span class=normal>1364</span>
<span class=normal>1365</span>
<span class=normal>1366</span>
<span class=normal>1367</span>
<span class=normal>1368</span>
<span class=normal>1369</span>
<span class=normal>1370</span>
<span class=normal>1371</span>
<span class=normal>1372</span>
<span class=normal>1373</span>
<span class=normal>1374</span>
<span class=normal>1375</span>
<span class=normal>1376</span>
<span class=normal>1377</span>
<span class=normal>1378</span>
<span class=normal>1379</span>
<span class=normal>1380</span>
<span class=normal>1381</span>
<span class=normal>1382</span>
<span class=normal>1383</span>
<span class=normal>1384</span>
<span class=normal>1385</span>
<span class=normal>1386</span>
<span class=normal>1387</span>
<span class=normal>1388</span>
<span class=normal>1389</span>
<span class=normal>1390</span>
<span class=normal>1391</span>
<span class=normal>1392</span>
<span class=normal>1393</span>
<span class=normal>1394</span>
<span class=normal>1395</span>
<span class=normal>1396</span>
<span class=normal>1397</span>
<span class=normal>1398</span>
<span class=normal>1399</span>
<span class=normal>1400</span>
<span class=normal>1401</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>count_in_interval</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>event_starts</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>event_stops</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>par_type</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&quot;counts&quot;</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Count discrete-time events in specified intervals and return a matrix where each</span>
<span class=sd>    column represents counts for each discrete-time event series over given epochs.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray</span>
<span class=sd>        A jagged array where each element contains discrete-time events times for</span>
<span class=sd>        a series (e.g. spike times for a neuron). (n series x variable length event times).</span>

<span class=sd>    event_starts : np.ndarray</span>
<span class=sd>        A 1D array containing the start times of events.</span>

<span class=sd>    event_stops : np.ndarray</span>
<span class=sd>        A 1D array containing the stop times of events.</span>

<span class=sd>    par_type : str, optional</span>
<span class=sd>        The type of count calculation to perform:</span>
<span class=sd>        - &#39;counts&#39;: returns raw counts of spikes in the intervals.</span>
<span class=sd>        - &#39;binary&#39;: returns a binary matrix indicating presence (1) or absence (0) of spikes.</span>
<span class=sd>        - &#39;rate&#39;: returns the firing rate calculated as counts divided by the interval duration.</span>
<span class=sd>        Defaults to &#39;binary&#39;.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        A 2D array (n series x n epochs) where each column shows the counts</span>
<span class=sd>        (or binary values or rates) per series for each epoch.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; import numpy as np</span>
<span class=sd>    &gt;&gt;&gt; # Create spike trains for 3 units with different spike times</span>
<span class=sd>    &gt;&gt;&gt; unit_1_spikes = np.array([0.1, 0.3, 0.5, 1.2, 1.8])</span>
<span class=sd>    &gt;&gt;&gt; unit_2_spikes = np.array([0.2, 0.8, 1.5])</span>
<span class=sd>    &gt;&gt;&gt; unit_3_spikes = np.array([0.05, 0.4, 0.9, 1.1])</span>
<span class=sd>    &gt;&gt;&gt; st = np.array([unit_1_spikes, unit_2_spikes, unit_3_spikes], dtype=object)</span>
<span class=sd>    &gt;&gt;&gt; # Define two events with their start and stop times</span>
<span class=sd>    &gt;&gt;&gt; event_starts = np.array([0.0, 1.0])</span>
<span class=sd>    &gt;&gt;&gt; event_stops = np.array([0.7, 2.0])</span>
<span class=sd>    &gt;&gt;&gt; # Count spikes in each interval</span>
<span class=sd>    &gt;&gt;&gt; counts = count_in_interval(st, event_starts, event_stops, par_type=&#39;counts&#39;)</span>
<span class=sd>    &gt;&gt;&gt; print(counts)</span>
<span class=sd>    [[3. 2.]</span>
<span class=sd>     [1. 1.]</span>
<span class=sd>     [2. 1.]]</span>
<span class=sd>    &gt;&gt;&gt; # Get binary presence/absence</span>
<span class=sd>    &gt;&gt;&gt; binary = count_in_interval(st, event_starts, event_stops, par_type=&#39;binary&#39;)</span>
<span class=sd>    &gt;&gt;&gt; print(binary)</span>
<span class=sd>    [[1. 1.]</span>
<span class=sd>     [1. 1.]</span>
<span class=sd>     [1. 1.]]</span>
<span class=sd>    &gt;&gt;&gt; # Calculate firing rates</span>
<span class=sd>    &gt;&gt;&gt; rates = count_in_interval(st, event_starts, event_stops, par_type=&#39;firing_rate&#39;)</span>
<span class=sd>    &gt;&gt;&gt; print(rates)</span>
<span class=sd>    [[4.28571429 2.   ]</span>
<span class=sd>     [1.42857143 1.   ]</span>
<span class=sd>     [2.85714286 1.   ]]</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># convert to numpy array</span>
    <span class=n>event_starts</span><span class=p>,</span> <span class=n>event_stops</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>event_starts</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>event_stops</span><span class=p>)</span>

    <span class=c1># initialize matrix</span>
    <span class=n>unit_mat</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>),</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>event_starts</span><span class=p>))))</span>

    <span class=c1># loop over units and bin spikes into epochs</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
        <span class=n>idx1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>event_starts</span><span class=p>,</span> <span class=s2>&quot;right&quot;</span><span class=p>)</span>
        <span class=n>idx2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>event_stops</span><span class=p>,</span> <span class=s2>&quot;left&quot;</span><span class=p>)</span>
        <span class=n>unit_mat</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=p>:]</span> <span class=o>=</span> <span class=n>idx2</span> <span class=o>-</span> <span class=n>idx1</span>

    <span class=n>par_type_funcs</span> <span class=o>=</span> <span class=p>{</span>
        <span class=s2>&quot;counts&quot;</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>,</span>
        <span class=s2>&quot;binary&quot;</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1</span><span class=p>,</span>
        <span class=s2>&quot;firing_rate&quot;</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>event_stops</span> <span class=o>-</span> <span class=n>event_starts</span><span class=p>),</span>
    <span class=p>}</span>
    <span class=n>calc_func</span> <span class=o>=</span> <span class=n>par_type_funcs</span><span class=p>[</span><span class=n>par_type</span><span class=p>]</span>
    <span class=n>unit_mat</span> <span class=o>=</span> <span class=n>calc_func</span><span class=p>(</span><span class=n>unit_mat</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>unit_mat</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.crossCorr class="doc doc-heading"> <code class="highlight language-python"><span class=n>crossCorr</span><span class=p>(</span><span class=n>t1</span><span class=p>,</span> <span class=n>t2</span><span class=p>,</span> <span class=n>binsize</span><span class=p>,</span> <span class=n>nbins</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute a cross-correlogram using independent event-wise histograms.</p> <p>This is the standard definition of a cross-correlogram: each reference event (t1) independently computes a histogram of all target timestamps (t2) relative to it. Each t2 sample can contribute to every t1 event (no "consumption").</p> <p>Efficient O(nt1 * (log(nt2) + nt2)) implementation using binary search for initial positioning, then single-pass binning per event.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>t1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Reference events (can be unsorted, any order).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>t2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Target timestamps (must be sorted in ascending order).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>binsize</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Bin width in seconds.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>nbins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of bins (will be adjusted to be odd).</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Normalized cross-correlogram (rate in Hz). Shape (nbins,) where nbins is adjusted to be odd.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>True cross-correlogram: each t2 sample contributes to every t1 event. Order of t1 does not affect the result. Suitable for spike-to-event analysis (e.g., spikes relative to ripples).</p> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>t1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>t2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>1.1</span><span class=p>,</span> <span class=mf>1.3</span><span class=p>,</span> <span class=mf>2.1</span><span class=p>,</span> <span class=mf>2.3</span><span class=p>]))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>result</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>t1</span><span class=p>,</span> <span class=n>t2</span><span class=p>,</span> <span class=n>binsize</span><span class=o>=</span><span class=mf>0.2</span><span class=p>,</span> <span class=n>nbins</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>result</span><span class=o>.</span><span class=n>shape</span>
<span class=go>(5,)</span>
</code></pre></div> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 23</span>
<span class=normal> 24</span>
<span class=normal> 25</span>
<span class=normal> 26</span>
<span class=normal> 27</span>
<span class=normal> 28</span>
<span class=normal> 29</span>
<span class=normal> 30</span>
<span class=normal> 31</span>
<span class=normal> 32</span>
<span class=normal> 33</span>
<span class=normal> 34</span>
<span class=normal> 35</span>
<span class=normal> 36</span>
<span class=normal> 37</span>
<span class=normal> 38</span>
<span class=normal> 39</span>
<span class=normal> 40</span>
<span class=normal> 41</span>
<span class=normal> 42</span>
<span class=normal> 43</span>
<span class=normal> 44</span>
<span class=normal> 45</span>
<span class=normal> 46</span>
<span class=normal> 47</span>
<span class=normal> 48</span>
<span class=normal> 49</span>
<span class=normal> 50</span>
<span class=normal> 51</span>
<span class=normal> 52</span>
<span class=normal> 53</span>
<span class=normal> 54</span>
<span class=normal> 55</span>
<span class=normal> 56</span>
<span class=normal> 57</span>
<span class=normal> 58</span>
<span class=normal> 59</span>
<span class=normal> 60</span>
<span class=normal> 61</span>
<span class=normal> 62</span>
<span class=normal> 63</span>
<span class=normal> 64</span>
<span class=normal> 65</span>
<span class=normal> 66</span>
<span class=normal> 67</span>
<span class=normal> 68</span>
<span class=normal> 69</span>
<span class=normal> 70</span>
<span class=normal> 71</span>
<span class=normal> 72</span>
<span class=normal> 73</span>
<span class=normal> 74</span>
<span class=normal> 75</span>
<span class=normal> 76</span>
<span class=normal> 77</span>
<span class=normal> 78</span>
<span class=normal> 79</span>
<span class=normal> 80</span>
<span class=normal> 81</span>
<span class=normal> 82</span>
<span class=normal> 83</span>
<span class=normal> 84</span>
<span class=normal> 85</span>
<span class=normal> 86</span>
<span class=normal> 87</span>
<span class=normal> 88</span>
<span class=normal> 89</span>
<span class=normal> 90</span>
<span class=normal> 91</span>
<span class=normal> 92</span>
<span class=normal> 93</span>
<span class=normal> 94</span>
<span class=normal> 95</span>
<span class=normal> 96</span>
<span class=normal> 97</span>
<span class=normal> 98</span>
<span class=normal> 99</span>
<span class=normal>100</span>
<span class=normal>101</span>
<span class=normal>102</span>
<span class=normal>103</span>
<span class=normal>104</span>
<span class=normal>105</span>
<span class=normal>106</span>
<span class=normal>107</span>
<span class=normal>108</span>
<span class=normal>109</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>crossCorr</span><span class=p>(</span>
    <span class=n>t1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>t2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>binsize</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
    <span class=n>nbins</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute a cross-correlogram using independent event-wise histograms.</span>

<span class=sd>    This is the standard definition of a cross-correlogram: each reference event (t1)</span>
<span class=sd>    independently computes a histogram of all target timestamps (t2) relative to it.</span>
<span class=sd>    Each t2 sample can contribute to every t1 event (no &quot;consumption&quot;).</span>

<span class=sd>    Efficient O(nt1 * (log(nt2) + nt2)) implementation using binary search for</span>
<span class=sd>    initial positioning, then single-pass binning per event.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    t1 : np.ndarray</span>
<span class=sd>        Reference events (can be unsorted, any order).</span>
<span class=sd>    t2 : np.ndarray</span>
<span class=sd>        Target timestamps (must be sorted in ascending order).</span>
<span class=sd>    binsize : float</span>
<span class=sd>        Bin width in seconds.</span>
<span class=sd>    nbins : int</span>
<span class=sd>        Number of bins (will be adjusted to be odd).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        Normalized cross-correlogram (rate in Hz).</span>
<span class=sd>        Shape (nbins,) where nbins is adjusted to be odd.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    True cross-correlogram: each t2 sample contributes to every t1 event.</span>
<span class=sd>    Order of t1 does not affect the result.</span>
<span class=sd>    Suitable for spike-to-event analysis (e.g., spikes relative to ripples).</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; t1 = np.array([1.0, 2.0])</span>
<span class=sd>    &gt;&gt;&gt; t2 = np.sort(np.array([1.1, 1.3, 2.1, 2.3]))</span>
<span class=sd>    &gt;&gt;&gt; result = crossCorr(t1, t2, binsize=0.2, nbins=4)</span>
<span class=sd>    &gt;&gt;&gt; result.shape</span>
<span class=sd>    (5,)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Ensure nbins is odd</span>
    <span class=n>nbins</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>nbins</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>floor</span><span class=p>(</span><span class=n>nbins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>==</span> <span class=n>nbins</span><span class=p>:</span>
        <span class=n>nbins</span> <span class=o>=</span> <span class=n>nbins</span> <span class=o>+</span> <span class=mi>1</span>

    <span class=n>nt1</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>t1</span><span class=p>)</span>
    <span class=n>nt2</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>t2</span><span class=p>)</span>

    <span class=n>w</span> <span class=o>=</span> <span class=p>(</span><span class=n>nbins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=n>binsize</span>
    <span class=n>C</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=n>nbins</span><span class=p>)</span>

    <span class=c1># For each reference event, independently compute histogram</span>
    <span class=k>for</span> <span class=n>i1</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>nt1</span><span class=p>):</span>
        <span class=n>lbound</span> <span class=o>=</span> <span class=n>t1</span><span class=p>[</span><span class=n>i1</span><span class=p>]</span> <span class=o>-</span> <span class=n>w</span>
        <span class=n>ubound</span> <span class=o>=</span> <span class=n>lbound</span> <span class=o>+</span> <span class=n>nbins</span> <span class=o>*</span> <span class=n>binsize</span>

        <span class=c1># Binary search to find first t2 sample in window</span>
        <span class=n>left</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=n>right</span> <span class=o>=</span> <span class=n>nt2</span>
        <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
            <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
            <span class=k>if</span> <span class=n>t2</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>lbound</span><span class=p>:</span>
                <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span>

        <span class=c1># Single pass through t2 samples in this event&#39;s window</span>
        <span class=c1># Bin each sample directly using its offset from lbound</span>
        <span class=n>k</span> <span class=o>=</span> <span class=n>left</span>
        <span class=k>while</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>nt2</span> <span class=ow>and</span> <span class=n>t2</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>ubound</span><span class=p>:</span>
            <span class=n>bin_j</span> <span class=o>=</span> <span class=nb>int</span><span class=p>((</span><span class=n>t2</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>-</span> <span class=n>lbound</span><span class=p>)</span> <span class=o>/</span> <span class=n>binsize</span><span class=p>)</span>
            <span class=k>if</span> <span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>bin_j</span> <span class=o>&lt;</span> <span class=n>nbins</span><span class=p>:</span>
                <span class=n>C</span><span class=p>[</span><span class=n>bin_j</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
            <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span>

    <span class=c1># Normalize by number of events and bin width</span>
    <span class=n>C</span> <span class=o>=</span> <span class=n>C</span> <span class=o>/</span> <span class=p>(</span><span class=n>nt1</span> <span class=o>*</span> <span class=n>binsize</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>C</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.deconvolve_peth class="doc doc-heading"> <code class="highlight language-python"><span class=n>deconvolve_peth</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Perform deconvolution of a peri-event time histogram (PETH) signal.</p> <p>This function calculates the deconvolved signal based on the input signal and events.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>signal</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array representing the discrete events.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array representing the discrete events.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of a time bin in seconds (default is 0.002 seconds).</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins to use in the PETH (default is 100 bins).</p> </div> </td> <td> <code>100</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>deconvolved</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array representing the deconvolved signal.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>times</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array representing the time points corresponding to the bins.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>Based on DeconvolvePETH.m from https://github.com/ayalab1/neurocode/blob/master/spikes/DeconvolvePETH.m</p> </details> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>292</span>
<span class=normal>293</span>
<span class=normal>294</span>
<span class=normal>295</span>
<span class=normal>296</span>
<span class=normal>297</span>
<span class=normal>298</span>
<span class=normal>299</span>
<span class=normal>300</span>
<span class=normal>301</span>
<span class=normal>302</span>
<span class=normal>303</span>
<span class=normal>304</span>
<span class=normal>305</span>
<span class=normal>306</span>
<span class=normal>307</span>
<span class=normal>308</span>
<span class=normal>309</span>
<span class=normal>310</span>
<span class=normal>311</span>
<span class=normal>312</span>
<span class=normal>313</span>
<span class=normal>314</span>
<span class=normal>315</span>
<span class=normal>316</span>
<span class=normal>317</span>
<span class=normal>318</span>
<span class=normal>319</span>
<span class=normal>320</span>
<span class=normal>321</span>
<span class=normal>322</span>
<span class=normal>323</span>
<span class=normal>324</span>
<span class=normal>325</span>
<span class=normal>326</span>
<span class=normal>327</span>
<span class=normal>328</span>
<span class=normal>329</span>
<span class=normal>330</span>
<span class=normal>331</span>
<span class=normal>332</span>
<span class=normal>333</span>
<span class=normal>334</span>
<span class=normal>335</span>
<span class=normal>336</span>
<span class=normal>337</span>
<span class=normal>338</span>
<span class=normal>339</span>
<span class=normal>340</span>
<span class=normal>341</span>
<span class=normal>342</span>
<span class=normal>343</span>
<span class=normal>344</span>
<span class=normal>345</span>
<span class=normal>346</span>
<span class=normal>347</span>
<span class=normal>348</span>
<span class=normal>349</span>
<span class=normal>350</span>
<span class=normal>351</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>deconvolve_peth</span><span class=p>(</span>
    <span class=n>signal</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Perform deconvolution of a peri-event time histogram (PETH) signal.</span>

<span class=sd>    This function calculates the deconvolved signal based on the input signal and events.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    signal : np.ndarray</span>
<span class=sd>        An array representing the discrete events.</span>
<span class=sd>    events : np.ndarray</span>
<span class=sd>        An array representing the discrete events.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        The width of a time bin in seconds (default is 0.002 seconds).</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        The number of bins to use in the PETH (default is 100 bins).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    deconvolved : np.ndarray</span>
<span class=sd>        An array representing the deconvolved signal.</span>
<span class=sd>    times : np.ndarray</span>
<span class=sd>        An array representing the time points corresponding to the bins.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Based on DeconvolvePETH.m from https://github.com/ayalab1/neurocode/blob/master/spikes/DeconvolvePETH.m</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># calculate time lags for peth</span>
    <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>

    <span class=c1># Calculate the autocorrelogram of the signal and the PETH of the events and the signal</span>
    <span class=n>autocorrelogram</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>raw_peth</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>events</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>

    <span class=c1># If raw_peth all zeros, return zeros</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>raw_peth</span><span class=o>.</span><span class=n>any</span><span class=p>():</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)),</span> <span class=n>times</span>

    <span class=c1># Subtract the mean value from the raw_peth</span>
    <span class=n>const</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>raw_peth</span><span class=p>)</span>
    <span class=n>raw_peth</span> <span class=o>=</span> <span class=n>raw_peth</span> <span class=o>-</span> <span class=n>const</span>

    <span class=c1># Calculate the Toeplitz matrix using the autocorrelogram and</span>
    <span class=c1>#   the cross-correlation of the autocorrelogram</span>
    <span class=n>T0</span> <span class=o>=</span> <span class=n>toeplitz</span><span class=p>(</span>
        <span class=n>autocorrelogram</span><span class=p>,</span>
        <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>([</span><span class=n>autocorrelogram</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>autocorrelogram</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)]),</span>
    <span class=p>)</span>
    <span class=n>T</span> <span class=o>=</span> <span class=n>T0</span><span class=p>[</span><span class=n>n_bins</span><span class=p>:,</span> <span class=p>:</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span>

    <span class=c1># Calculate the deconvolved signal by solving a linear equation</span>
    <span class=n>deconvolved</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>solve</span><span class=p>(</span>
        <span class=n>T</span><span class=p>,</span> <span class=n>raw_peth</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=p>:</span> <span class=nb>int</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span><span class=o>.</span><span class=n>T</span> <span class=o>+</span> <span class=n>const</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>)</span>
    <span class=p>)</span>

    <span class=k>return</span> <span class=n>deconvolved</span><span class=p>,</span> <span class=n>times</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.event_spiking_threshold class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_spiking_threshold</span><span class=p>(</span><span class=n>spikes</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>event_size</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>spiking_thres</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>binsize</span><span class=o>=</span><span class=mf>0.01</span><span class=p>,</span> <span class=n>sigma</span><span class=o>=</span><span class=mf>0.02</span><span class=p>,</span> <span class=n>min_units</span><span class=o>=</span><span class=mi>6</span><span class=p>,</span> <span class=n>show_fig</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>event_spiking_threshold: filter events based on spiking threshold</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>spikes</code> </td> <td> <code><span title=nel.SpikeTrainArray>SpikeTrainArray</span></code> </td> <td> <div class=doc-md-description> <p>Spike train array of neurons.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Event times in seconds.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code>list of float</code> </td> <td> <div class=doc-md-description> <p>Time window (in seconds) to compute event-triggered average, by default [-0.5, 0.5].</p> </div> </td> <td> <code>[-0.5, 0.5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>event_size</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Time window (in seconds) around event to measure firing response, by default 0.1.</p> </div> </td> <td> <code>0.1</code> </td> </tr> <tr class=doc-section-item> <td> <code>spiking_thres</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Spiking threshold in z-score units, by default 0.</p> </div> </td> <td> <code>0</code> </td> </tr> <tr class=doc-section-item> <td> <code>binsize</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Bin size (in seconds) for time-binning the spike trains, by default 0.01.</p> </div> </td> <td> <code>0.01</code> </td> </tr> <tr class=doc-section-item> <td> <code>sigma</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Standard deviation (in seconds) for Gaussian smoothing of spike counts, by default 0.02.</p> </div> </td> <td> <code>0.02</code> </td> </tr> <tr class=doc-section-item> <td> <code>min_units</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Minimum number of units required to compute event-triggered average, by default 6.</p> </div> </td> <td> <code>6</code> </td> </tr> <tr class=doc-section-item> <td> <code>show_fig</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, plots the figure of event-triggered spiking activity, by default False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Boolean array indicating valid events that meet the spiking threshold.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>basepath</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;U:\data\hpc_ctx_project\HP04\day_32_20240430&quot;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>ripples</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_ripples_events</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span>
<span class=go>        basepath,</span>
<span class=go>        brainRegion=&quot;CA1&quot;,</span>
<span class=go>        support=nel.EpochArray([0, loading.load_epoch(basepath).iloc[-1].stopTime])</span>
<span class=go>    )</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>idx</span> <span class=o>=</span> <span class=n>event_spiking_threshold</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>ripples</span><span class=o>.</span><span class=n>peaks</span><span class=o>.</span><span class=n>values</span><span class=p>,</span> <span class=n>show_fig</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Number of valid ripples: </span><span class=si>{</span><span class=n>idx</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span><span class=si>}</span><span class=s2> out of </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>ripples</span><span class=p>)</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=go>Number of valid ripples: 9244 out of 12655</span>
</code></pre></div> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1776</span>
<span class=normal>1777</span>
<span class=normal>1778</span>
<span class=normal>1779</span>
<span class=normal>1780</span>
<span class=normal>1781</span>
<span class=normal>1782</span>
<span class=normal>1783</span>
<span class=normal>1784</span>
<span class=normal>1785</span>
<span class=normal>1786</span>
<span class=normal>1787</span>
<span class=normal>1788</span>
<span class=normal>1789</span>
<span class=normal>1790</span>
<span class=normal>1791</span>
<span class=normal>1792</span>
<span class=normal>1793</span>
<span class=normal>1794</span>
<span class=normal>1795</span>
<span class=normal>1796</span>
<span class=normal>1797</span>
<span class=normal>1798</span>
<span class=normal>1799</span>
<span class=normal>1800</span>
<span class=normal>1801</span>
<span class=normal>1802</span>
<span class=normal>1803</span>
<span class=normal>1804</span>
<span class=normal>1805</span>
<span class=normal>1806</span>
<span class=normal>1807</span>
<span class=normal>1808</span>
<span class=normal>1809</span>
<span class=normal>1810</span>
<span class=normal>1811</span>
<span class=normal>1812</span>
<span class=normal>1813</span>
<span class=normal>1814</span>
<span class=normal>1815</span>
<span class=normal>1816</span>
<span class=normal>1817</span>
<span class=normal>1818</span>
<span class=normal>1819</span>
<span class=normal>1820</span>
<span class=normal>1821</span>
<span class=normal>1822</span>
<span class=normal>1823</span>
<span class=normal>1824</span>
<span class=normal>1825</span>
<span class=normal>1826</span>
<span class=normal>1827</span>
<span class=normal>1828</span>
<span class=normal>1829</span>
<span class=normal>1830</span>
<span class=normal>1831</span>
<span class=normal>1832</span>
<span class=normal>1833</span>
<span class=normal>1834</span>
<span class=normal>1835</span>
<span class=normal>1836</span>
<span class=normal>1837</span>
<span class=normal>1838</span>
<span class=normal>1839</span>
<span class=normal>1840</span>
<span class=normal>1841</span>
<span class=normal>1842</span>
<span class=normal>1843</span>
<span class=normal>1844</span>
<span class=normal>1845</span>
<span class=normal>1846</span>
<span class=normal>1847</span>
<span class=normal>1848</span>
<span class=normal>1849</span>
<span class=normal>1850</span>
<span class=normal>1851</span>
<span class=normal>1852</span>
<span class=normal>1853</span>
<span class=normal>1854</span>
<span class=normal>1855</span>
<span class=normal>1856</span>
<span class=normal>1857</span>
<span class=normal>1858</span>
<span class=normal>1859</span>
<span class=normal>1860</span>
<span class=normal>1861</span>
<span class=normal>1862</span>
<span class=normal>1863</span>
<span class=normal>1864</span>
<span class=normal>1865</span>
<span class=normal>1866</span>
<span class=normal>1867</span>
<span class=normal>1868</span>
<span class=normal>1869</span>
<span class=normal>1870</span>
<span class=normal>1871</span>
<span class=normal>1872</span>
<span class=normal>1873</span>
<span class=normal>1874</span>
<span class=normal>1875</span>
<span class=normal>1876</span>
<span class=normal>1877</span>
<span class=normal>1878</span>
<span class=normal>1879</span>
<span class=normal>1880</span>
<span class=normal>1881</span>
<span class=normal>1882</span>
<span class=normal>1883</span>
<span class=normal>1884</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_spiking_threshold</span><span class=p>(</span>
    <span class=n>spikes</span><span class=p>:</span> <span class=n>SpikeTrainArray</span><span class=p>,</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=nb>list</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
    <span class=n>event_size</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.1</span><span class=p>,</span>
    <span class=n>spiking_thres</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
    <span class=n>binsize</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.01</span><span class=p>,</span>
    <span class=n>sigma</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.02</span><span class=p>,</span>
    <span class=n>min_units</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>6</span><span class=p>,</span>
    <span class=n>show_fig</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    event_spiking_threshold: filter events based on spiking threshold</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    spikes : nel.SpikeTrainArray</span>
<span class=sd>        Spike train array of neurons.</span>
<span class=sd>    events : np.ndarray</span>
<span class=sd>        Event times in seconds.</span>
<span class=sd>    window : list of float, optional</span>
<span class=sd>        Time window (in seconds) to compute event-triggered average, by default [-0.5, 0.5].</span>
<span class=sd>    event_size : float, optional</span>
<span class=sd>        Time window (in seconds) around event to measure firing response, by default 0.1.</span>
<span class=sd>    spiking_thres : float, optional</span>
<span class=sd>        Spiking threshold in z-score units, by default 0.</span>
<span class=sd>    binsize : float, optional</span>
<span class=sd>        Bin size (in seconds) for time-binning the spike trains, by default 0.01.</span>
<span class=sd>    sigma : float, optional</span>
<span class=sd>        Standard deviation (in seconds) for Gaussian smoothing of spike counts, by default 0.02.</span>
<span class=sd>    min_units : int, optional</span>
<span class=sd>        Minimum number of units required to compute event-triggered average, by default 6.</span>
<span class=sd>    show_fig : bool, optional</span>
<span class=sd>        If True, plots the figure of event-triggered spiking activity, by default False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        Boolean array indicating valid events that meet the spiking threshold.</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; basepath = r&quot;U:\\data\\hpc_ctx_project\\HP04\\day_32_20240430&quot;</span>
<span class=sd>    &gt;&gt;&gt; ripples = loading.load_ripples_events(basepath, return_epoch_array=False)</span>
<span class=sd>    &gt;&gt;&gt; st, cell_metrics = loading.load_spikes(</span>
<span class=sd>            basepath,</span>
<span class=sd>            brainRegion=&quot;CA1&quot;,</span>
<span class=sd>            support=nel.EpochArray([0, loading.load_epoch(basepath).iloc[-1].stopTime])</span>
<span class=sd>        )</span>
<span class=sd>    &gt;&gt;&gt; idx = event_spiking_threshold(st, ripples.peaks.values, show_fig=True)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;Number of valid ripples: {idx.sum()} out of {len(ripples)}&quot;)</span>
<span class=sd>    Number of valid ripples: 9244 out of 12655</span>

<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># check if there are enough units to compute a confident event triggered average</span>
    <span class=k>if</span> <span class=n>spikes</span><span class=o>.</span><span class=n>n_active</span> <span class=o>&lt;</span> <span class=n>min_units</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>bool</span><span class=p>)</span>

    <span class=c1># bin spikes</span>
    <span class=n>bst</span> <span class=o>=</span> <span class=n>spikes</span><span class=o>.</span><span class=n>bin</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=n>binsize</span><span class=p>)</span><span class=o>.</span><span class=n>smooth</span><span class=p>(</span><span class=n>sigma</span><span class=o>=</span><span class=n>sigma</span><span class=p>)</span>
    <span class=c1># sum over all neurons and zscore</span>
    <span class=n>bst</span> <span class=o>=</span> <span class=n>bst</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
    <span class=n>bst</span> <span class=o>=</span> <span class=p>(</span><span class=n>bst</span> <span class=o>-</span> <span class=n>bst</span><span class=o>.</span><span class=n>mean</span><span class=p>())</span> <span class=o>/</span> <span class=n>bst</span><span class=o>.</span><span class=n>std</span><span class=p>()</span>
    <span class=c1># get event triggered average</span>
    <span class=n>avg_signal</span><span class=p>,</span> <span class=n>time_lags</span> <span class=o>=</span> <span class=n>event_triggered_average_fast</span><span class=p>(</span>
        <span class=n>bst</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>,</span> <span class=p>:],</span>
        <span class=n>events</span><span class=p>,</span>
        <span class=n>sampling_rate</span><span class=o>=</span><span class=nb>int</span><span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=n>binsize</span><span class=p>),</span>
        <span class=n>window</span><span class=o>=</span><span class=n>window</span><span class=p>,</span>
        <span class=n>return_average</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
    <span class=p>)</span>
    <span class=c1># get the event response within the event size</span>
    <span class=n>idx</span> <span class=o>=</span> <span class=p>(</span><span class=n>time_lags</span> <span class=o>&gt;=</span> <span class=o>-</span><span class=n>event_size</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>time_lags</span> <span class=o>&lt;=</span> <span class=n>event_size</span><span class=p>)</span>
    <span class=n>event_response</span> <span class=o>=</span> <span class=n>avg_signal</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=n>idx</span><span class=p>,</span> <span class=p>:]</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

    <span class=c1># get events that are above threshold</span>
    <span class=n>valid_events</span> <span class=o>=</span> <span class=n>event_response</span> <span class=o>&gt;</span> <span class=n>spiking_thres</span>

    <span class=k>if</span> <span class=n>show_fig</span><span class=p>:</span>
        <span class=kn>import</span><span class=w> </span><span class=nn>matplotlib.pyplot</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>plt</span>
        <span class=kn>import</span><span class=w> </span><span class=nn>seaborn</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>sns</span>

        <span class=n>sorted_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>event_response</span><span class=p>)</span>

        <span class=n>fig</span><span class=p>,</span> <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>5</span><span class=p>),</span> <span class=n>sharey</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span>
            <span class=n>avg_signal</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=p>:,</span> <span class=n>sorted_idx</span><span class=p>],</span>
            <span class=n>aspect</span><span class=o>=</span><span class=s2>&quot;auto&quot;</span><span class=p>,</span>
            <span class=n>extent</span><span class=o>=</span><span class=p>[</span><span class=n>time_lags</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>time_lags</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>event_response</span><span class=p>)],</span>
            <span class=n>vmin</span><span class=o>=-</span><span class=mi>2</span><span class=p>,</span>
            <span class=n>vmax</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span>
            <span class=n>origin</span><span class=o>=</span><span class=s2>&quot;lower&quot;</span><span class=p>,</span>
            <span class=n>interpolation</span><span class=o>=</span><span class=s2>&quot;nearest&quot;</span><span class=p>,</span>
        <span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>axhline</span><span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span><span class=n>event_response</span><span class=p>[</span><span class=n>sorted_idx</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>spiking_thres</span><span class=p>)[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span>
            <span class=n>color</span><span class=o>=</span><span class=s2>&quot;r&quot;</span><span class=p>,</span>
            <span class=n>linestyle</span><span class=o>=</span><span class=s2>&quot;--&quot;</span><span class=p>,</span>
        <span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>event_response</span><span class=p>[</span><span class=n>sorted_idx</span><span class=p>],</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>event_response</span><span class=p>)))</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>axvline</span><span class=p>(</span><span class=n>spiking_thres</span><span class=p>,</span> <span class=n>color</span><span class=o>=</span><span class=s2>&quot;r&quot;</span><span class=p>,</span> <span class=n>linestyle</span><span class=o>=</span><span class=s2>&quot;--&quot;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=s2>&quot;Time from event (s)&quot;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=s2>&quot;Event index&quot;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=s2>&quot;Average response&quot;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=s2>&quot;Event index&quot;</span><span class=p>)</span>
        <span class=n>sns</span><span class=o>.</span><span class=n>despine</span><span class=p>()</span>

    <span class=k>return</span> <span class=n>valid_events</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.event_triggered_average class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_triggered_average</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>sampling_rate</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>return_average</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>return_pandas</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>irregular_sampling</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Calculates the event-triggered averages of signals in a time window relative to the event times of corresponding events for multiple signals.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>timestamps</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of timestamps corresponding to the signal samples.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>signal</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array of shape (n_samples, n_signals) containing the signal values.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, <span title=typing.List>List</span>[<span title=numpy.ndarray>ndarray</span>]]</code> </td> <td> <div class=doc-md-description> <p>One or more 1D arrays of event times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>sampling_rate</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=float>float</span>, None]</code> </td> <td> <div class=doc-md-description> <p>The sampling rate of the signal. If not provided, it will be calculated based on the timestamps.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=typing.List>List</span>[<span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>A list containing two elements: the start and stop times relative to an event for the time interval of signal averaging. Default is [-0.5, 0.5].</p> </div> </td> <td> <code>[-0.5, 0.5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_average</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to return the average of the event-triggered average. Defaults to True. If False, returns the full event-triggered average matrix (n_samples x n_signals x n_events).</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_pandas</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, return the result as a Pandas DataFrame. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>irregular_sampling</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, indicates that the signal is irregularly sampled and interpolation should be used. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, <span title=pandas.DataFrame>DataFrame</span>]</code> </td> <td> <div class=doc-md-description> <p>If <code>return_average</code> is True, returns the event-triggered averages of the signals (n_samples, n_signals) or a Pandas DataFrame if <code>return_pandas</code> is True. If <code>return_average</code> is False, returns the full event-triggered average matrix (n_samples, n_signals, n_events).</p> </div> </td> </tr> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time lags corresponding to the event-triggered averages.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <ul> <li>The function filters out events that do not fit within the valid range of the signal considering the specified window size.</li> <li>If the <code>sampling_rate</code> is not provided, it is calculated based on the timestamps.</li> <li>The function handles both regular and irregular sampling of the signal.</li> </ul> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>peth_avg</span><span class=p>,</span> <span class=n>time_lags</span> <span class=o>=</span> <span class=n>event_triggered_average</span><span class=p>(</span>
<span class=gp>... </span>   <span class=n>timestamps</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>]</span>
<span class=gp>... </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># Get individual event responses</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_matrix</span><span class=p>,</span> <span class=n>time_lags</span> <span class=o>=</span> <span class=n>event_triggered_average</span><span class=p>(</span>
<span class=gp>... </span>   <span class=n>timestamps</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>return_average</span><span class=o>=</span><span class=kc>False</span>
<span class=gp>... </span><span class=p>)</span>
</code></pre></div> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>792</span>
<span class=normal>793</span>
<span class=normal>794</span>
<span class=normal>795</span>
<span class=normal>796</span>
<span class=normal>797</span>
<span class=normal>798</span>
<span class=normal>799</span>
<span class=normal>800</span>
<span class=normal>801</span>
<span class=normal>802</span>
<span class=normal>803</span>
<span class=normal>804</span>
<span class=normal>805</span>
<span class=normal>806</span>
<span class=normal>807</span>
<span class=normal>808</span>
<span class=normal>809</span>
<span class=normal>810</span>
<span class=normal>811</span>
<span class=normal>812</span>
<span class=normal>813</span>
<span class=normal>814</span>
<span class=normal>815</span>
<span class=normal>816</span>
<span class=normal>817</span>
<span class=normal>818</span>
<span class=normal>819</span>
<span class=normal>820</span>
<span class=normal>821</span>
<span class=normal>822</span>
<span class=normal>823</span>
<span class=normal>824</span>
<span class=normal>825</span>
<span class=normal>826</span>
<span class=normal>827</span>
<span class=normal>828</span>
<span class=normal>829</span>
<span class=normal>830</span>
<span class=normal>831</span>
<span class=normal>832</span>
<span class=normal>833</span>
<span class=normal>834</span>
<span class=normal>835</span>
<span class=normal>836</span>
<span class=normal>837</span>
<span class=normal>838</span>
<span class=normal>839</span>
<span class=normal>840</span>
<span class=normal>841</span>
<span class=normal>842</span>
<span class=normal>843</span>
<span class=normal>844</span>
<span class=normal>845</span>
<span class=normal>846</span>
<span class=normal>847</span>
<span class=normal>848</span>
<span class=normal>849</span>
<span class=normal>850</span>
<span class=normal>851</span>
<span class=normal>852</span>
<span class=normal>853</span>
<span class=normal>854</span>
<span class=normal>855</span>
<span class=normal>856</span>
<span class=normal>857</span>
<span class=normal>858</span>
<span class=normal>859</span>
<span class=normal>860</span>
<span class=normal>861</span>
<span class=normal>862</span>
<span class=normal>863</span>
<span class=normal>864</span>
<span class=normal>865</span>
<span class=normal>866</span>
<span class=normal>867</span>
<span class=normal>868</span>
<span class=normal>869</span>
<span class=normal>870</span>
<span class=normal>871</span>
<span class=normal>872</span>
<span class=normal>873</span>
<span class=normal>874</span>
<span class=normal>875</span>
<span class=normal>876</span>
<span class=normal>877</span>
<span class=normal>878</span>
<span class=normal>879</span>
<span class=normal>880</span>
<span class=normal>881</span>
<span class=normal>882</span>
<span class=normal>883</span>
<span class=normal>884</span>
<span class=normal>885</span>
<span class=normal>886</span>
<span class=normal>887</span>
<span class=normal>888</span>
<span class=normal>889</span>
<span class=normal>890</span>
<span class=normal>891</span>
<span class=normal>892</span>
<span class=normal>893</span>
<span class=normal>894</span>
<span class=normal>895</span>
<span class=normal>896</span>
<span class=normal>897</span>
<span class=normal>898</span>
<span class=normal>899</span>
<span class=normal>900</span>
<span class=normal>901</span>
<span class=normal>902</span>
<span class=normal>903</span>
<span class=normal>904</span>
<span class=normal>905</span>
<span class=normal>906</span>
<span class=normal>907</span>
<span class=normal>908</span>
<span class=normal>909</span>
<span class=normal>910</span>
<span class=normal>911</span>
<span class=normal>912</span>
<span class=normal>913</span>
<span class=normal>914</span>
<span class=normal>915</span>
<span class=normal>916</span>
<span class=normal>917</span>
<span class=normal>918</span>
<span class=normal>919</span>
<span class=normal>920</span>
<span class=normal>921</span>
<span class=normal>922</span>
<span class=normal>923</span>
<span class=normal>924</span>
<span class=normal>925</span>
<span class=normal>926</span>
<span class=normal>927</span>
<span class=normal>928</span>
<span class=normal>929</span>
<span class=normal>930</span>
<span class=normal>931</span>
<span class=normal>932</span>
<span class=normal>933</span>
<span class=normal>934</span>
<span class=normal>935</span>
<span class=normal>936</span>
<span class=normal>937</span>
<span class=normal>938</span>
<span class=normal>939</span>
<span class=normal>940</span>
<span class=normal>941</span>
<span class=normal>942</span>
<span class=normal>943</span>
<span class=normal>944</span>
<span class=normal>945</span>
<span class=normal>946</span>
<span class=normal>947</span>
<span class=normal>948</span>
<span class=normal>949</span>
<span class=normal>950</span>
<span class=normal>951</span>
<span class=normal>952</span>
<span class=normal>953</span>
<span class=normal>954</span>
<span class=normal>955</span>
<span class=normal>956</span>
<span class=normal>957</span>
<span class=normal>958</span>
<span class=normal>959</span>
<span class=normal>960</span>
<span class=normal>961</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_triggered_average</span><span class=p>(</span>
    <span class=n>timestamps</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>signal</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>List</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]],</span>
    <span class=n>sampling_rate</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
    <span class=n>return_average</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
    <span class=n>return_pandas</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
    <span class=n>irregular_sampling</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>],</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Calculates the event-triggered averages of signals in a time window</span>
<span class=sd>    relative to the event times of corresponding events for multiple signals.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    timestamps : np.ndarray</span>
<span class=sd>        A 1D array of timestamps corresponding to the signal samples.</span>
<span class=sd>    signal : np.ndarray</span>
<span class=sd>        A 2D array of shape (n_samples, n_signals) containing the signal values.</span>
<span class=sd>    events : Union[np.ndarray, List[np.ndarray]]</span>
<span class=sd>        One or more 1D arrays of event times.</span>
<span class=sd>    sampling_rate : Union[float, None], optional</span>
<span class=sd>        The sampling rate of the signal. If not provided, it will be calculated</span>
<span class=sd>        based on the timestamps.</span>
<span class=sd>    window : List[float], optional</span>
<span class=sd>        A list containing two elements: the start and stop times relative to an event</span>
<span class=sd>        for the time interval of signal averaging. Default is [-0.5, 0.5].</span>
<span class=sd>    return_average : bool, optional</span>
<span class=sd>        Whether to return the average of the event-triggered average. Defaults to True.</span>
<span class=sd>        If False, returns the full event-triggered average matrix (n_samples x n_signals x n_events).</span>
<span class=sd>    return_pandas : bool, optional</span>
<span class=sd>        If True, return the result as a Pandas DataFrame. Default is False.</span>
<span class=sd>    irregular_sampling : bool, optional</span>
<span class=sd>        If True, indicates that the signal is irregularly sampled and interpolation should be used. Default is False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Union[np.ndarray, pd.DataFrame]</span>
<span class=sd>        If `return_average` is True, returns the event-triggered averages of the signals</span>
<span class=sd>        (n_samples, n_signals) or a Pandas DataFrame if `return_pandas` is True.</span>
<span class=sd>        If `return_average` is False, returns the full event-triggered average matrix</span>
<span class=sd>        (n_samples, n_signals, n_events).</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        An array of time lags corresponding to the event-triggered averages.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    - The function filters out events that do not fit within the valid range of the signal</span>
<span class=sd>    considering the specified window size.</span>
<span class=sd>    - If the `sampling_rate` is not provided, it is calculated based on the timestamps.</span>
<span class=sd>    - The function handles both regular and irregular sampling of the signal.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; peth_avg, time_lags = event_triggered_average(</span>
<span class=sd>    ...    timestamps, signal, events, window=[-0.5, 0.5]</span>
<span class=sd>    ... )</span>
<span class=sd>    &gt;&gt;&gt; # Get individual event responses</span>
<span class=sd>    &gt;&gt;&gt; peth_matrix, time_lags = event_triggered_average(</span>
<span class=sd>    ...    timestamps, signal, events, window=[-0.5, 0.5], return_average=False</span>
<span class=sd>    ... )</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Basic input validation</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>window</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>2</span> <span class=ow>or</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;&#39;window&#39; must be [start, stop] with start &lt; stop&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
        <span class=n>signal</span> <span class=o>=</span> <span class=n>signal</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>sampling_rate</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>sampling_rate</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>stats</span><span class=o>.</span><span class=n>mode</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>timestamps</span><span class=p>),</span> <span class=n>keepdims</span><span class=o>=</span><span class=kc>True</span><span class=p>)[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>

    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>events</span><span class=p>,</span> <span class=nb>list</span><span class=p>):</span>
        <span class=n>events</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>events</span><span class=p>)</span>

    <span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span> <span class=o>=</span> <span class=n>window</span>
    <span class=n>window_bins</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(((</span><span class=n>window_stoptime</span> <span class=o>-</span> <span class=n>window_starttime</span><span class=p>)</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)))</span>
    <span class=n>time_lags</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span><span class=p>,</span> <span class=n>window_bins</span><span class=p>)</span>

    <span class=c1># Filter events that fit within the signal range</span>
    <span class=n>min_timestamp</span><span class=p>,</span> <span class=n>max_timestamp</span> <span class=o>=</span> <span class=n>timestamps</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>timestamps</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
    <span class=n>valid_mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>events</span> <span class=o>+</span> <span class=n>window_starttime</span> <span class=o>&gt;=</span> <span class=n>min_timestamp</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span>
        <span class=n>events</span> <span class=o>+</span> <span class=n>window_stoptime</span> <span class=o>&lt;=</span> <span class=n>max_timestamp</span>
    <span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>valid_mask</span><span class=p>):</span>
        <span class=n>warnings</span><span class=o>.</span><span class=n>warn</span><span class=p>(</span><span class=s2>&quot;No events found within the valid signal range&quot;</span><span class=p>)</span>
        <span class=n>empty_shape</span> <span class=o>=</span> <span class=p>(</span><span class=n>window_bins</span><span class=p>,</span> <span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
        <span class=k>if</span> <span class=n>return_average</span><span class=p>:</span>
            <span class=n>result</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=n>empty_shape</span><span class=p>)</span>
            <span class=k>return</span> <span class=p>(</span>
                <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>index</span><span class=o>=</span><span class=n>time_lags</span><span class=p>)</span> <span class=k>if</span> <span class=n>return_pandas</span> <span class=k>else</span> <span class=n>result</span>
            <span class=p>),</span> <span class=n>time_lags</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>full</span><span class=p>(</span><span class=n>empty_shape</span> <span class=o>+</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>),),</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>),</span> <span class=n>time_lags</span>

    <span class=c1># Initialize result matrix: (window_bins, n_signals, n_events) - keep all events</span>
    <span class=n>result_matrix</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>full</span><span class=p>((</span><span class=n>window_bins</span><span class=p>,</span> <span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>)),</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>)</span>

    <span class=c1># For regular sampling, use fast indexing approach similar to event_triggered_average_fast</span>
    <span class=n>dt</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>median</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>timestamps</span><span class=p>))</span>
    <span class=n>data_is_regular</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>allclose</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>timestamps</span><span class=p>),</span> <span class=n>dt</span><span class=p>,</span> <span class=n>rtol</span><span class=o>=</span><span class=mf>1e-3</span><span class=p>)</span>
    <span class=n>use_interpolation</span> <span class=o>=</span> <span class=n>irregular_sampling</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>data_is_regular</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>use_interpolation</span><span class=p>:</span>
        <span class=c1># Fast path: regular sampling - use direct indexing like event_triggered_average_fast</span>
        <span class=c1># Match the exact indexing logic from event_triggered_average_fast</span>
        <span class=n>start_time</span> <span class=o>=</span> <span class=n>timestamps</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># Cache start time for efficiency</span>
        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>event</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>events</span><span class=p>):</span>
            <span class=k>if</span> <span class=ow>not</span> <span class=n>valid_mask</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>  <span class=c1># Skip invalid events (already filled with NaN)</span>
                <span class=k>continue</span>

            <span class=c1># Convert event time to sample indices, accounting for timestamp start time</span>
            <span class=n>event_sample</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>round</span><span class=p>((</span><span class=n>event</span> <span class=o>-</span> <span class=n>start_time</span><span class=p>)</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)</span>
            <span class=n>ts_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span>
                <span class=n>event_sample</span> <span class=o>-</span> <span class=n>window_bins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span>
                <span class=n>event_sample</span> <span class=o>+</span> <span class=n>window_bins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span>
            <span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>

            <span class=c1># Check bounds</span>
            <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>ts_idx</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>ts_idx</span><span class=p>)</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>signal</span><span class=p>):</span>
                <span class=n>result_matrix</span><span class=p>[:,</span> <span class=p>:,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>signal</span><span class=p>[</span><span class=n>ts_idx</span><span class=p>,</span> <span class=p>:]</span>
            <span class=c1># If bounds check fails, keep as NaN (already initialized)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=c1># Slow path: irregular sampling - use interpolation but vectorized</span>
        <span class=n>target_times_template</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span><span class=p>,</span> <span class=n>window_bins</span>
        <span class=p>)</span>

        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>event</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>events</span><span class=p>):</span>
            <span class=k>if</span> <span class=ow>not</span> <span class=n>valid_mask</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>  <span class=c1># Skip invalid events (already filled with NaN)</span>
                <span class=k>continue</span>

            <span class=n>target_times</span> <span class=o>=</span> <span class=n>target_times_template</span> <span class=o>+</span> <span class=n>event</span>

            <span class=c1># Find the range of timestamps that covers our target times</span>
            <span class=n>start_search</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span>
                <span class=n>timestamps</span><span class=p>,</span> <span class=n>target_times</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>dt</span><span class=p>,</span> <span class=n>side</span><span class=o>=</span><span class=s2>&quot;left&quot;</span>
            <span class=p>)</span>
            <span class=n>stop_search</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span>
                <span class=n>timestamps</span><span class=p>,</span> <span class=n>target_times</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dt</span><span class=p>,</span> <span class=n>side</span><span class=o>=</span><span class=s2>&quot;right&quot;</span>
            <span class=p>)</span>

            <span class=k>if</span> <span class=n>start_search</span> <span class=o>&gt;=</span> <span class=n>stop_search</span><span class=p>:</span>
                <span class=c1># Keep as NaN (already initialized)</span>
                <span class=k>continue</span>

            <span class=c1># Extract relevant data for this event</span>
            <span class=n>event_timestamps</span> <span class=o>=</span> <span class=n>timestamps</span><span class=p>[</span><span class=n>start_search</span><span class=p>:</span><span class=n>stop_search</span><span class=p>]</span>
            <span class=n>event_signal</span> <span class=o>=</span> <span class=n>signal</span><span class=p>[</span><span class=n>start_search</span><span class=p>:</span><span class=n>stop_search</span><span class=p>,</span> <span class=p>:]</span>

            <span class=c1># Vectorized interpolation for all channels at once</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>event_timestamps</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]):</span>
                    <span class=n>result_matrix</span><span class=p>[:,</span> <span class=n>j</span><span class=p>,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span>
                        <span class=n>target_times</span><span class=p>,</span> <span class=n>event_timestamps</span><span class=p>,</span> <span class=n>event_signal</span><span class=p>[:,</span> <span class=n>j</span><span class=p>]</span>
                    <span class=p>)</span>
            <span class=c1># If interpolation fails, keep as NaN (already initialized)</span>

    <span class=c1># Return results</span>
    <span class=k>if</span> <span class=n>return_average</span><span class=p>:</span>
        <span class=n>result_avg</span> <span class=o>=</span> <span class=n>bn</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>result_matrix</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>return_pandas</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span>
                <span class=n>result_avg</span><span class=p>,</span> <span class=n>index</span><span class=o>=</span><span class=n>time_lags</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
            <span class=p>)</span>
        <span class=k>return</span> <span class=n>result_avg</span><span class=p>,</span> <span class=n>time_lags</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>result_matrix</span><span class=p>,</span> <span class=n>time_lags</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.event_triggered_average_fast class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_triggered_average_fast</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>sampling_rate</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>return_average</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>return_pandas</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Calculate the event-triggered average of a signal.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>signal</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array of signal data with shape (channels, timepoints).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of event times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>sampling_rate</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The sampling rate of the signal in Hz.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=list>list</span>, <span title=typing.Tuple>Tuple</span>[<span title=float>float</span>, <span title=float>float</span>]]</code> </td> <td> <div class=doc-md-description> <p>A list or tuple specifying the time window (in seconds) to average the signal around each event. Defaults to [-0.5, 0.5].</p> </div> </td> <td> <code>[-0.5, 0.5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_average</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to return the average of the event-triggered average. Defaults to True. If False, returns the full event-triggered average matrix (channels x timepoints x events).</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_pandas</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, returns the average as a Pandas DataFrame. Defaults to False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, <span title=pandas.DataFrame>DataFrame</span>]</code> </td> <td> <div class=doc-md-description> <p>If <code>return_average</code> is True, returns the event-triggered average of the signal (channels x timepoints) or a Pandas DataFrame if <code>return_pandas</code> is True. If <code>return_average</code> is False, returns the full event-triggered average matrix (channels x timebins x events).</p> </div> </td> </tr> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time lags corresponding to the event-triggered averages.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <ul> <li>The function filters out events that do not fit within the valid range of the signal considering the specified window size.</li> <li>Assumes the signal starts at time 0.</li> </ul> </details> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 964</span>
<span class=normal> 965</span>
<span class=normal> 966</span>
<span class=normal> 967</span>
<span class=normal> 968</span>
<span class=normal> 969</span>
<span class=normal> 970</span>
<span class=normal> 971</span>
<span class=normal> 972</span>
<span class=normal> 973</span>
<span class=normal> 974</span>
<span class=normal> 975</span>
<span class=normal> 976</span>
<span class=normal> 977</span>
<span class=normal> 978</span>
<span class=normal> 979</span>
<span class=normal> 980</span>
<span class=normal> 981</span>
<span class=normal> 982</span>
<span class=normal> 983</span>
<span class=normal> 984</span>
<span class=normal> 985</span>
<span class=normal> 986</span>
<span class=normal> 987</span>
<span class=normal> 988</span>
<span class=normal> 989</span>
<span class=normal> 990</span>
<span class=normal> 991</span>
<span class=normal> 992</span>
<span class=normal> 993</span>
<span class=normal> 994</span>
<span class=normal> 995</span>
<span class=normal> 996</span>
<span class=normal> 997</span>
<span class=normal> 998</span>
<span class=normal> 999</span>
<span class=normal>1000</span>
<span class=normal>1001</span>
<span class=normal>1002</span>
<span class=normal>1003</span>
<span class=normal>1004</span>
<span class=normal>1005</span>
<span class=normal>1006</span>
<span class=normal>1007</span>
<span class=normal>1008</span>
<span class=normal>1009</span>
<span class=normal>1010</span>
<span class=normal>1011</span>
<span class=normal>1012</span>
<span class=normal>1013</span>
<span class=normal>1014</span>
<span class=normal>1015</span>
<span class=normal>1016</span>
<span class=normal>1017</span>
<span class=normal>1018</span>
<span class=normal>1019</span>
<span class=normal>1020</span>
<span class=normal>1021</span>
<span class=normal>1022</span>
<span class=normal>1023</span>
<span class=normal>1024</span>
<span class=normal>1025</span>
<span class=normal>1026</span>
<span class=normal>1027</span>
<span class=normal>1028</span>
<span class=normal>1029</span>
<span class=normal>1030</span>
<span class=normal>1031</span>
<span class=normal>1032</span>
<span class=normal>1033</span>
<span class=normal>1034</span>
<span class=normal>1035</span>
<span class=normal>1036</span>
<span class=normal>1037</span>
<span class=normal>1038</span>
<span class=normal>1039</span>
<span class=normal>1040</span>
<span class=normal>1041</span>
<span class=normal>1042</span>
<span class=normal>1043</span>
<span class=normal>1044</span>
<span class=normal>1045</span>
<span class=normal>1046</span>
<span class=normal>1047</span>
<span class=normal>1048</span>
<span class=normal>1049</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_triggered_average_fast</span><span class=p>(</span>
    <span class=n>signal</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>sampling_rate</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>list</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]]</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
    <span class=n>return_average</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
    <span class=n>return_pandas</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>],</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Calculate the event-triggered average of a signal.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    signal : np.ndarray</span>
<span class=sd>        A 2D array of signal data with shape (channels, timepoints).</span>

<span class=sd>    events : np.ndarray</span>
<span class=sd>        A 1D array of event times.</span>

<span class=sd>    sampling_rate : int</span>
<span class=sd>        The sampling rate of the signal in Hz.</span>

<span class=sd>    window : Union[list, Tuple[float, float]], optional</span>
<span class=sd>        A list or tuple specifying the time window (in seconds) to average the signal</span>
<span class=sd>        around each event. Defaults to [-0.5, 0.5].</span>

<span class=sd>    return_average : bool, optional</span>
<span class=sd>        Whether to return the average of the event-triggered average. Defaults to True.</span>
<span class=sd>        If False, returns the full event-triggered average matrix (channels x timepoints x events).</span>

<span class=sd>    return_pandas : bool, optional</span>
<span class=sd>        If True, returns the average as a Pandas DataFrame. Defaults to False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Union[np.ndarray, pd.DataFrame]</span>
<span class=sd>        If `return_average` is True, returns the event-triggered average of the signal</span>
<span class=sd>        (channels x timepoints) or a Pandas DataFrame if `return_pandas` is True.</span>
<span class=sd>        If `return_average` is False, returns the full event-triggered average matrix (channels x timebins x events).</span>

<span class=sd>    np.ndarray</span>
<span class=sd>        An array of time lags corresponding to the event-triggered averages.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    - The function filters out events that do not fit within the valid range of the signal</span>
<span class=sd>    considering the specified window size.</span>
<span class=sd>    - Assumes the signal starts at time 0.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span> <span class=o>=</span> <span class=n>window</span>
    <span class=n>window_bins</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(((</span><span class=n>window_stoptime</span> <span class=o>-</span> <span class=n>window_starttime</span><span class=p>)</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)))</span>
    <span class=n>time_lags</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span><span class=p>,</span> <span class=n>window_bins</span><span class=p>)</span>

    <span class=c1># Create valid mask instead of filtering events</span>
    <span class=n>valid_mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>events</span> <span class=o>*</span> <span class=n>sampling_rate</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span>
        <span class=n>events</span> <span class=o>*</span> <span class=n>sampling_rate</span> <span class=o>&lt;</span> <span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span>
    <span class=p>)</span>

    <span class=c1># Initialize result matrix with all events, filled with NaN</span>
    <span class=n>avg_signal</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>full</span><span class=p>(</span>
        <span class=p>[</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>)],</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>signal</span><span class=o>.</span><span class=n>dtype</span>
    <span class=p>)</span>

    <span class=c1># Process only valid events</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>event</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>events</span><span class=p>):</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=n>valid_mask</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>  <span class=c1># Skip invalid events (already filled with NaN)</span>
            <span class=k>continue</span>

        <span class=n>ts_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>round</span><span class=p>(</span><span class=n>event</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span>
            <span class=n>np</span><span class=o>.</span><span class=n>round</span><span class=p>(</span><span class=n>event</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span>
        <span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>
        <span class=n>avg_signal</span><span class=p>[:,</span> <span class=p>:,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>signal</span><span class=p>[:,</span> <span class=n>ts_idx</span><span class=p>]</span>

    <span class=k>if</span> <span class=n>return_pandas</span> <span class=ow>and</span> <span class=n>return_average</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span>
            <span class=n>index</span><span class=o>=</span><span class=n>time_lags</span><span class=p>,</span>
            <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span>
            <span class=n>data</span><span class=o>=</span><span class=n>bn</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>avg_signal</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span><span class=o>.</span><span class=n>T</span><span class=p>,</span>
        <span class=p>)</span>

    <span class=k>if</span> <span class=n>return_average</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>bn</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>avg_signal</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>2</span><span class=p>),</span> <span class=n>time_lags</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>avg_signal</span><span class=p>,</span> <span class=n>time_lags</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.event_triggered_average_irregular_sample class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_triggered_average_irregular_sample</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the average and standard deviation of data values within a window around each reference time, specifically for irregularly sampled data.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>timestamps</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of times associated with data.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of data values.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_ref</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of reference times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of each bin in the window, in seconds. Default is 0.002 seconds.</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins in the window. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=tuple>tuple</span>, None]</code> </td> <td> <div class=doc-md-description> <p>A tuple containing the start and end times of the window to be plotted around each reference time. If not provided, the window will be centered around each reference time and have a width of <code>n_bins * bin_width</code> seconds.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Tuple>Tuple</span>[<span title=pandas.DataFrame>DataFrame</span>, <span title=pandas.DataFrame>DataFrame</span>]</code> </td> <td> <div class=doc-md-description> <p>Two DataFrames: the first containing the average values, the second the standard deviation of data values within the window around each reference time.</p> </div> </td> </tr> </tbody> </table> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>719</span>
<span class=normal>720</span>
<span class=normal>721</span>
<span class=normal>722</span>
<span class=normal>723</span>
<span class=normal>724</span>
<span class=normal>725</span>
<span class=normal>726</span>
<span class=normal>727</span>
<span class=normal>728</span>
<span class=normal>729</span>
<span class=normal>730</span>
<span class=normal>731</span>
<span class=normal>732</span>
<span class=normal>733</span>
<span class=normal>734</span>
<span class=normal>735</span>
<span class=normal>736</span>
<span class=normal>737</span>
<span class=normal>738</span>
<span class=normal>739</span>
<span class=normal>740</span>
<span class=normal>741</span>
<span class=normal>742</span>
<span class=normal>743</span>
<span class=normal>744</span>
<span class=normal>745</span>
<span class=normal>746</span>
<span class=normal>747</span>
<span class=normal>748</span>
<span class=normal>749</span>
<span class=normal>750</span>
<span class=normal>751</span>
<span class=normal>752</span>
<span class=normal>753</span>
<span class=normal>754</span>
<span class=normal>755</span>
<span class=normal>756</span>
<span class=normal>757</span>
<span class=normal>758</span>
<span class=normal>759</span>
<span class=normal>760</span>
<span class=normal>761</span>
<span class=normal>762</span>
<span class=normal>763</span>
<span class=normal>764</span>
<span class=normal>765</span>
<span class=normal>766</span>
<span class=normal>767</span>
<span class=normal>768</span>
<span class=normal>769</span>
<span class=normal>770</span>
<span class=normal>771</span>
<span class=normal>772</span>
<span class=normal>773</span>
<span class=normal>774</span>
<span class=normal>775</span>
<span class=normal>776</span>
<span class=normal>777</span>
<span class=normal>778</span>
<span class=normal>779</span>
<span class=normal>780</span>
<span class=normal>781</span>
<span class=normal>782</span>
<span class=normal>783</span>
<span class=normal>784</span>
<span class=normal>785</span>
<span class=normal>786</span>
<span class=normal>787</span>
<span class=normal>788</span>
<span class=normal>789</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_triggered_average_irregular_sample</span><span class=p>(</span>
    <span class=n>timestamps</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>time_ref</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>tuple</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>,</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the average and standard deviation of data values within a window around</span>
<span class=sd>    each reference time, specifically for irregularly sampled data.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    timestamps : np.ndarray</span>
<span class=sd>        A 1D array of times associated with data.</span>
<span class=sd>    data : np.ndarray</span>
<span class=sd>        A 1D array of data values.</span>
<span class=sd>    time_ref : np.ndarray</span>
<span class=sd>        A 1D array of reference times.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        The width of each bin in the window, in seconds. Default is 0.002 seconds.</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        The number of bins in the window. Default is 100.</span>
<span class=sd>    window : Union[tuple, None], optional</span>
<span class=sd>        A tuple containing the start and end times of the window to be plotted around each reference time.</span>
<span class=sd>        If not provided, the window will be centered around each reference time and have a</span>
<span class=sd>        width of `n_bins * bin_width` seconds.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Tuple[pd.DataFrame, pd.DataFrame]</span>
<span class=sd>        Two DataFrames: the first containing the average values, the second the</span>
<span class=sd>        standard deviation of data values within the window around each reference time.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=p>)</span>
    <span class=n>x</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>y</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>time_ref</span><span class=p>):</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=p>(</span><span class=n>timestamps</span> <span class=o>&gt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>times</span><span class=o>.</span><span class=n>min</span><span class=p>())</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>timestamps</span> <span class=o>&lt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>times</span><span class=o>.</span><span class=n>max</span><span class=p>())</span>
        <span class=n>x</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>timestamps</span> <span class=o>-</span> <span class=n>r</span><span class=p>)[</span><span class=n>idx</span><span class=p>])</span>
        <span class=n>y</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span>

    <span class=n>temp_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>()</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>temp_df</span><span class=p>,</span> <span class=n>temp_df</span>
    <span class=n>temp_df</span><span class=p>[</span><span class=s2>&quot;time&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
    <span class=n>temp_df</span><span class=p>[</span><span class=s2>&quot;data&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
    <span class=n>temp_df</span> <span class=o>=</span> <span class=n>temp_df</span><span class=o>.</span><span class=n>sort_values</span><span class=p>(</span><span class=n>by</span><span class=o>=</span><span class=s2>&quot;time&quot;</span><span class=p>,</span> <span class=n>ascending</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

    <span class=n>average_val</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
    <span class=n>std_val</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
        <span class=n>average_val</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp_df</span><span class=p>[</span>
            <span class=n>temp_df</span><span class=o>.</span><span class=n>time</span><span class=o>.</span><span class=n>between</span><span class=p>(</span><span class=n>times</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>times</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span>
        <span class=p>]</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>mean</span><span class=p>()</span>
        <span class=n>std_val</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp_df</span><span class=p>[</span><span class=n>temp_df</span><span class=o>.</span><span class=n>time</span><span class=o>.</span><span class=n>between</span><span class=p>(</span><span class=n>times</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>times</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])]</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>std</span><span class=p>()</span>

    <span class=n>avg</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>avg</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>average_val</span>

    <span class=n>std</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>std</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>std_val</span>

    <span class=k>return</span> <span class=n>avg</span><span class=p>,</span> <span class=n>std</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.get_rank_order class="doc doc-heading"> <code class="highlight language-python"><span class=n>get_rank_order</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>method</span><span class=o>=</span><span class=s1>&#39;peak_fr&#39;</span><span class=p>,</span> <span class=n>ref</span><span class=o>=</span><span class=s1>&#39;cells&#39;</span><span class=p>,</span> <span class=n>padding</span><span class=o>=</span><span class=mf>0.05</span><span class=p>,</span> <span class=n>dt</span><span class=o>=</span><span class=mf>0.001</span><span class=p>,</span> <span class=n>sigma</span><span class=o>=</span><span class=mf>0.01</span><span class=p>,</span> <span class=n>min_units</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Calculate the rank order of spike trains within specified epochs.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>st</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span> or <span title=nelpy.array>array</span></code> </td> <td> <div class=doc-md-description> <p>Spike train data. Can be a nelpy array containing spike times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>epochs</code> </td> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>An object containing the epochs (windows) in which to calculate the rank order.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>method</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Method to calculate rank order. Choices are 'first_spike' or 'peak_fr'. Defaults to 'peak_fr'.</p> </div> </td> <td> <code>&#39;peak_fr&#39;</code> </td> </tr> <tr class=doc-section-item> <td> <code>ref</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Reference frame for rank order. Choices are 'cells' or 'epoch'. Defaults to 'cells'.</p> </div> </td> <td> <code>&#39;cells&#39;</code> </td> </tr> <tr class=doc-section-item> <td> <code>padding</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Padding (in seconds) to apply to the epochs. Defaults to 0.05 seconds.</p> </div> </td> <td> <code>0.05</code> </td> </tr> <tr class=doc-section-item> <td> <code>dt</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Bin width (in seconds) for finding relative time in the epoch reference. Defaults to 0.001 seconds.</p> </div> </td> <td> <code>0.001</code> </td> </tr> <tr class=doc-section-item> <td> <code>sigma</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Smoothing sigma (in seconds) for the 'peak_fr' method. Defaults to 0.01 seconds.</p> </div> </td> <td> <code>0.01</code> </td> </tr> <tr class=doc-section-item> <td> <code>min_units</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Minimum number of active units required to compute the rank order. Defaults to 5.</p> </div> </td> <td> <code>5</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>median_rank</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The median rank order across all epochs, normalized between 0 and 1.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>rank_order</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array of rank orders, where each column corresponds to an epoch, and each row corresponds to a cell, normalized between 0 and 1.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>putativeCellType</span><span class=o>=</span><span class=s1>&#39;Pyr&#39;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>forward_replay</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>starts</span><span class=p>,</span> <span class=n>stops</span><span class=p>])</span><span class=o>.</span><span class=n>T</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>median_rank</span><span class=p>,</span> <span class=n>rank_order</span> <span class=o>=</span> <span class=n>get_rank_order</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>forward_replay</span><span class=p>)</span>
</code></pre></div> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1408</span>
<span class=normal>1409</span>
<span class=normal>1410</span>
<span class=normal>1411</span>
<span class=normal>1412</span>
<span class=normal>1413</span>
<span class=normal>1414</span>
<span class=normal>1415</span>
<span class=normal>1416</span>
<span class=normal>1417</span>
<span class=normal>1418</span>
<span class=normal>1419</span>
<span class=normal>1420</span>
<span class=normal>1421</span>
<span class=normal>1422</span>
<span class=normal>1423</span>
<span class=normal>1424</span>
<span class=normal>1425</span>
<span class=normal>1426</span>
<span class=normal>1427</span>
<span class=normal>1428</span>
<span class=normal>1429</span>
<span class=normal>1430</span>
<span class=normal>1431</span>
<span class=normal>1432</span>
<span class=normal>1433</span>
<span class=normal>1434</span>
<span class=normal>1435</span>
<span class=normal>1436</span>
<span class=normal>1437</span>
<span class=normal>1438</span>
<span class=normal>1439</span>
<span class=normal>1440</span>
<span class=normal>1441</span>
<span class=normal>1442</span>
<span class=normal>1443</span>
<span class=normal>1444</span>
<span class=normal>1445</span>
<span class=normal>1446</span>
<span class=normal>1447</span>
<span class=normal>1448</span>
<span class=normal>1449</span>
<span class=normal>1450</span>
<span class=normal>1451</span>
<span class=normal>1452</span>
<span class=normal>1453</span>
<span class=normal>1454</span>
<span class=normal>1455</span>
<span class=normal>1456</span>
<span class=normal>1457</span>
<span class=normal>1458</span>
<span class=normal>1459</span>
<span class=normal>1460</span>
<span class=normal>1461</span>
<span class=normal>1462</span>
<span class=normal>1463</span>
<span class=normal>1464</span>
<span class=normal>1465</span>
<span class=normal>1466</span>
<span class=normal>1467</span>
<span class=normal>1468</span>
<span class=normal>1469</span>
<span class=normal>1470</span>
<span class=normal>1471</span>
<span class=normal>1472</span>
<span class=normal>1473</span>
<span class=normal>1474</span>
<span class=normal>1475</span>
<span class=normal>1476</span>
<span class=normal>1477</span>
<span class=normal>1478</span>
<span class=normal>1479</span>
<span class=normal>1480</span>
<span class=normal>1481</span>
<span class=normal>1482</span>
<span class=normal>1483</span>
<span class=normal>1484</span>
<span class=normal>1485</span>
<span class=normal>1486</span>
<span class=normal>1487</span>
<span class=normal>1488</span>
<span class=normal>1489</span>
<span class=normal>1490</span>
<span class=normal>1491</span>
<span class=normal>1492</span>
<span class=normal>1493</span>
<span class=normal>1494</span>
<span class=normal>1495</span>
<span class=normal>1496</span>
<span class=normal>1497</span>
<span class=normal>1498</span>
<span class=normal>1499</span>
<span class=normal>1500</span>
<span class=normal>1501</span>
<span class=normal>1502</span>
<span class=normal>1503</span>
<span class=normal>1504</span>
<span class=normal>1505</span>
<span class=normal>1506</span>
<span class=normal>1507</span>
<span class=normal>1508</span>
<span class=normal>1509</span>
<span class=normal>1510</span>
<span class=normal>1511</span>
<span class=normal>1512</span>
<span class=normal>1513</span>
<span class=normal>1514</span>
<span class=normal>1515</span>
<span class=normal>1516</span>
<span class=normal>1517</span>
<span class=normal>1518</span>
<span class=normal>1519</span>
<span class=normal>1520</span>
<span class=normal>1521</span>
<span class=normal>1522</span>
<span class=normal>1523</span>
<span class=normal>1524</span>
<span class=normal>1525</span>
<span class=normal>1526</span>
<span class=normal>1527</span>
<span class=normal>1528</span>
<span class=normal>1529</span>
<span class=normal>1530</span>
<span class=normal>1531</span>
<span class=normal>1532</span>
<span class=normal>1533</span>
<span class=normal>1534</span>
<span class=normal>1535</span>
<span class=normal>1536</span>
<span class=normal>1537</span>
<span class=normal>1538</span>
<span class=normal>1539</span>
<span class=normal>1540</span>
<span class=normal>1541</span>
<span class=normal>1542</span>
<span class=normal>1543</span>
<span class=normal>1544</span>
<span class=normal>1545</span>
<span class=normal>1546</span>
<span class=normal>1547</span>
<span class=normal>1548</span>
<span class=normal>1549</span>
<span class=normal>1550</span>
<span class=normal>1551</span>
<span class=normal>1552</span>
<span class=normal>1553</span>
<span class=normal>1554</span>
<span class=normal>1555</span>
<span class=normal>1556</span>
<span class=normal>1557</span>
<span class=normal>1558</span>
<span class=normal>1559</span>
<span class=normal>1560</span>
<span class=normal>1561</span>
<span class=normal>1562</span>
<span class=normal>1563</span>
<span class=normal>1564</span>
<span class=normal>1565</span>
<span class=normal>1566</span>
<span class=normal>1567</span>
<span class=normal>1568</span>
<span class=normal>1569</span>
<span class=normal>1570</span>
<span class=normal>1571</span>
<span class=normal>1572</span>
<span class=normal>1573</span>
<span class=normal>1574</span>
<span class=normal>1575</span>
<span class=normal>1576</span>
<span class=normal>1577</span>
<span class=normal>1578</span>
<span class=normal>1579</span>
<span class=normal>1580</span>
<span class=normal>1581</span>
<span class=normal>1582</span>
<span class=normal>1583</span>
<span class=normal>1584</span>
<span class=normal>1585</span>
<span class=normal>1586</span>
<span class=normal>1587</span>
<span class=normal>1588</span>
<span class=normal>1589</span>
<span class=normal>1590</span>
<span class=normal>1591</span>
<span class=normal>1592</span>
<span class=normal>1593</span>
<span class=normal>1594</span>
<span class=normal>1595</span>
<span class=normal>1596</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>get_rank_order</span><span class=p>(</span>
    <span class=n>st</span><span class=p>:</span> <span class=n>SpikeTrainArray</span><span class=p>,</span>  <span class=c1># Assuming &#39;nelpy.array&#39; is a custom type</span>
    <span class=n>epochs</span><span class=p>:</span> <span class=n>EpochArray</span><span class=p>,</span>
    <span class=n>method</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&quot;peak_fr&quot;</span><span class=p>,</span>  <span class=c1># &#39;first_spike&#39; or &#39;peak_fr&#39;</span>
    <span class=n>ref</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&quot;cells&quot;</span><span class=p>,</span>  <span class=c1># &#39;cells&#39; or &#39;epoch&#39;</span>
    <span class=n>padding</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.05</span><span class=p>,</span>
    <span class=n>dt</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.001</span><span class=p>,</span>
    <span class=n>sigma</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.01</span><span class=p>,</span>
    <span class=n>min_units</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Calculate the rank order of spike trains within specified epochs.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    st : np.ndarray or nelpy.array</span>
<span class=sd>        Spike train data. Can be a nelpy array containing spike times.</span>

<span class=sd>    epochs : nelpy.EpochArray</span>
<span class=sd>        An object containing the epochs (windows) in which to calculate the rank order.</span>

<span class=sd>    method : str, optional</span>
<span class=sd>        Method to calculate rank order. Choices are &#39;first_spike&#39; or &#39;peak_fr&#39;.</span>
<span class=sd>        Defaults to &#39;peak_fr&#39;.</span>

<span class=sd>    ref : str, optional</span>
<span class=sd>        Reference frame for rank order. Choices are &#39;cells&#39; or &#39;epoch&#39;.</span>
<span class=sd>        Defaults to &#39;cells&#39;.</span>

<span class=sd>    padding : float, optional</span>
<span class=sd>        Padding (in seconds) to apply to the epochs. Defaults to 0.05 seconds.</span>

<span class=sd>    dt : float, optional</span>
<span class=sd>        Bin width (in seconds) for finding relative time in the epoch reference.</span>
<span class=sd>        Defaults to 0.001 seconds.</span>

<span class=sd>    sigma : float, optional</span>
<span class=sd>        Smoothing sigma (in seconds) for the &#39;peak_fr&#39; method. Defaults to 0.01 seconds.</span>

<span class=sd>    min_units : int, optional</span>
<span class=sd>        Minimum number of active units required to compute the rank order. Defaults to 5.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    median_rank : np.ndarray</span>
<span class=sd>        The median rank order across all epochs, normalized between 0 and 1.</span>

<span class=sd>    rank_order : np.ndarray</span>
<span class=sd>        A 2D array of rank orders, where each column corresponds to an epoch,</span>
<span class=sd>        and each row corresponds to a cell, normalized between 0 and 1.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; st, _ = loading.load_spikes(basepath, putativeCellType=&#39;Pyr&#39;)</span>
<span class=sd>    &gt;&gt;&gt; forward_replay = nel.EpochArray(np.array([starts, stops]).T)</span>
<span class=sd>    &gt;&gt;&gt; median_rank, rank_order = get_rank_order(st, forward_replay)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># filter out specific warnings</span>
    <span class=n>warnings</span><span class=o>.</span><span class=n>filterwarnings</span><span class=p>(</span>
        <span class=s2>&quot;ignore&quot;</span><span class=p>,</span> <span class=n>message</span><span class=o>=</span><span class=s2>&quot;ignoring events outside of eventarray support&quot;</span>
    <span class=p>)</span>
    <span class=n>warnings</span><span class=o>.</span><span class=n>filterwarnings</span><span class=p>(</span><span class=s2>&quot;ignore&quot;</span><span class=p>,</span> <span class=n>message</span><span class=o>=</span><span class=s2>&quot;Mean of empty slice&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>method</span> <span class=ow>not</span> <span class=ow>in</span> <span class=p>[</span><span class=s2>&quot;first_spike&quot;</span><span class=p>,</span> <span class=s2>&quot;peak_fr&quot;</span><span class=p>]:</span>
        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&quot;method &quot;</span> <span class=o>+</span> <span class=n>method</span> <span class=o>+</span> <span class=s2>&quot; not implemented&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>ref</span> <span class=ow>not</span> <span class=ow>in</span> <span class=p>[</span><span class=s2>&quot;cells&quot;</span><span class=p>,</span> <span class=s2>&quot;epoch&quot;</span><span class=p>]:</span>
        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&quot;ref &quot;</span> <span class=o>+</span> <span class=n>ref</span> <span class=o>+</span> <span class=s2>&quot; not implemented&quot;</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>get_min_ts</span><span class=p>(</span><span class=n>st_temp</span><span class=p>):</span>
        <span class=n>min_ts</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>ts</span> <span class=ow>in</span> <span class=n>st_temp</span><span class=o>.</span><span class=n>data</span><span class=p>:</span>
            <span class=c1># nan if no spikes</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>ts</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
                <span class=n>min_ts</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>min_ts</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nanmin</span><span class=p>(</span><span class=n>ts</span><span class=p>))</span>
        <span class=k>return</span> <span class=n>min_ts</span>

    <span class=k>def</span><span class=w> </span><span class=nf>rank_order_first_spike</span><span class=p>(</span><span class=n>st_epoch</span><span class=p>,</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>dt</span><span class=p>,</span> <span class=n>min_units</span><span class=p>,</span> <span class=n>ref</span><span class=p>):</span>
        <span class=c1># set up empty matrix for rank order</span>
        <span class=n>rank_order</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>ones</span><span class=p>([</span><span class=n>st_epoch</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>])</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>

        <span class=n>unit_id</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>st_epoch</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=n>st_epoch</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>epochs</span>

        <span class=c1># iter over every event</span>
        <span class=k>for</span> <span class=n>event_i</span><span class=p>,</span> <span class=n>st_temp</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>st_epoch</span><span class=p>):</span>
            <span class=k>if</span> <span class=n>ref</span> <span class=o>==</span> <span class=s2>&quot;cells&quot;</span><span class=p>:</span>
                <span class=c1># get firing order</span>
                <span class=n>idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>st_temp</span><span class=o>.</span><span class=n>get_event_firing_order</span><span class=p>())</span> <span class=o>-</span> <span class=mi>1</span>
                <span class=c1># reorder unit ids by order and remove non-active</span>
                <span class=n>units</span> <span class=o>=</span> <span class=n>unit_id</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=n>st_temp</span><span class=o>.</span><span class=n>n_events</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>]</span>
                <span class=c1># how many are left?</span>
                <span class=n>nUnits</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>units</span><span class=p>)</span>

                <span class=k>if</span> <span class=n>nUnits</span> <span class=o>&lt;</span> <span class=n>min_units</span><span class=p>:</span>
                    <span class=n>rank_order</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=c1># arange 1 to n units in order of units</span>
                    <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>nUnits</span><span class=p>)</span>
                    <span class=c1># normalize by n units</span>
                    <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>/</span> <span class=n>nUnits</span>
            <span class=k>elif</span> <span class=n>ref</span> <span class=o>==</span> <span class=s2>&quot;epoch&quot;</span><span class=p>:</span>
                <span class=c1># find first spike time for each cell</span>
                <span class=n>min_ts</span> <span class=o>=</span> <span class=n>get_min_ts</span><span class=p>(</span><span class=n>st_temp</span><span class=p>)</span>
                <span class=c1># make time stamps for interpolation</span>
                <span class=n>epoch_ts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>epochs</span><span class=p>[</span><span class=n>event_i</span><span class=p>]</span><span class=o>.</span><span class=n>start</span><span class=p>,</span> <span class=n>epochs</span><span class=p>[</span><span class=n>event_i</span><span class=p>]</span><span class=o>.</span><span class=n>stop</span><span class=p>,</span> <span class=n>dt</span><span class=p>)</span>
                <span class=c1># make normalized range 0-1</span>
                <span class=n>norm_range</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>epoch_ts</span><span class=p>))</span>
                <span class=c1># get spike order relative to normalized range</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>min_ts</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>min_units</span><span class=p>:</span>
                    <span class=n>rank_order</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>rank_order</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span><span class=n>min_ts</span><span class=p>,</span> <span class=n>epoch_ts</span><span class=p>,</span> <span class=n>norm_range</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>rank_order</span>

    <span class=k>def</span><span class=w> </span><span class=nf>rank_order_fr</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>dt</span><span class=p>,</span> <span class=n>sigma</span><span class=p>,</span> <span class=n>min_units</span><span class=p>,</span> <span class=n>ref</span><span class=p>):</span>
        <span class=c1># set up empty matrix for rank order</span>
        <span class=n>rank_order</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>([</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>])</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>

        <span class=n>unit_id</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>

        <span class=n>edges</span> <span class=o>=</span> <span class=n>split_epoch_by_width</span><span class=p>(</span><span class=n>epochs</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>dt</span><span class=p>)</span>

        <span class=n>z_t</span> <span class=o>=</span> <span class=n>count_in_interval</span><span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>edges</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>edges</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>],</span> <span class=n>par_type</span><span class=o>=</span><span class=s2>&quot;counts&quot;</span><span class=p>)</span>
        <span class=n>_</span><span class=p>,</span> <span class=n>interval_id</span> <span class=o>=</span> <span class=n>in_intervals</span><span class=p>(</span><span class=n>edges</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>return_interval</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

        <span class=c1># iter over epochs</span>
        <span class=k>for</span> <span class=n>event_i</span><span class=p>,</span> <span class=n>epochs_temp</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>epochs</span><span class=p>):</span>
            <span class=c1># smooth spike train in order to estimate peak</span>
            <span class=c1># z_t_temp.smooth(sigma=sigma, inplace=True)</span>
            <span class=n>z_t_temp</span> <span class=o>=</span> <span class=n>z_t</span><span class=p>[:,</span> <span class=n>interval_id</span> <span class=o>==</span> <span class=n>event_i</span><span class=p>]</span>
            <span class=c1># smooth spike train in order to estimate peak</span>
            <span class=n>z_t_temp</span> <span class=o>=</span> <span class=n>gaussian_filter1d</span><span class=p>(</span><span class=n>z_t_temp</span><span class=p>,</span> <span class=n>sigma</span> <span class=o>/</span> <span class=n>dt</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>ref</span> <span class=o>==</span> <span class=s2>&quot;cells&quot;</span><span class=p>:</span>
                <span class=c1># find loc of each peak and get sorted idx of active units</span>
                <span class=n>idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>z_t_temp</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>))</span>
                <span class=c1># reorder unit ids by order and remove non-active</span>
                <span class=n>units</span> <span class=o>=</span> <span class=n>unit_id</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>z_t_temp</span><span class=p>[</span><span class=n>idx</span><span class=p>,</span> <span class=p>:]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>]</span>

                <span class=n>nUnits</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>units</span><span class=p>)</span>

                <span class=k>if</span> <span class=n>nUnits</span> <span class=o>&lt;</span> <span class=n>min_units</span><span class=p>:</span>
                    <span class=n>rank_order</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=c1># arange 1 to n units in order of units</span>
                    <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>nUnits</span><span class=p>)</span>
                    <span class=c1># normalize by n units</span>
                    <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>/</span> <span class=n>nUnits</span>
            <span class=k>elif</span> <span class=n>ref</span> <span class=o>==</span> <span class=s2>&quot;epoch&quot;</span><span class=p>:</span>
                <span class=c1># iterate over each cell</span>
                <span class=k>for</span> <span class=n>cell_i</span><span class=p>,</span> <span class=n>unit</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>z_t_temp</span><span class=p>):</span>
                    <span class=c1># if the cell is not active apply nan</span>
                    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>unit</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>):</span>
                        <span class=n>rank_order</span><span class=p>[</span><span class=n>cell_i</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                    <span class=k>else</span><span class=p>:</span>
                        <span class=c1># calculate normalized rank order (0-1)</span>
                        <span class=n>rank_order</span><span class=p>[</span><span class=n>cell_i</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>unit</span><span class=p>)</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>unit</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>rank_order</span>

    <span class=c1># expand epochs by padding amount</span>
    <span class=n>epochs</span> <span class=o>=</span> <span class=n>epochs</span><span class=o>.</span><span class=n>expand</span><span class=p>(</span><span class=n>padding</span><span class=p>)</span>

    <span class=c1># check if no active cells</span>
    <span class=k>if</span> <span class=n>st</span><span class=o>.</span><span class=n>n_active</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>)</span>
        <span class=p>)</span>

    <span class=c1># check if there are any spikes in the epoch</span>
    <span class=n>st_epoch</span> <span class=o>=</span> <span class=n>count_in_interval</span><span class=p>(</span>
        <span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>epochs</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>epochs</span><span class=o>.</span><span class=n>stops</span><span class=p>,</span> <span class=n>par_type</span><span class=o>=</span><span class=s2>&quot;counts&quot;</span>
    <span class=p>)</span>

    <span class=c1># if no spikes in epoch, break out</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>st_epoch</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>all</span><span class=p>():</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>)</span>
        <span class=p>)</span>

    <span class=c1># set up empty matrix for rank order</span>
    <span class=k>if</span> <span class=n>method</span> <span class=o>==</span> <span class=s2>&quot;peak_fr&quot;</span><span class=p>:</span>
        <span class=n>rank_order</span> <span class=o>=</span> <span class=n>rank_order_fr</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>dt</span><span class=p>,</span> <span class=n>sigma</span><span class=p>,</span> <span class=n>min_units</span><span class=p>,</span> <span class=n>ref</span><span class=p>)</span>
    <span class=k>elif</span> <span class=n>method</span> <span class=o>==</span> <span class=s2>&quot;first_spike&quot;</span><span class=p>:</span>
        <span class=n>rank_order</span> <span class=o>=</span> <span class=n>rank_order_first_spike</span><span class=p>(</span><span class=n>st</span><span class=p>[</span><span class=n>epochs</span><span class=p>],</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>dt</span><span class=p>,</span> <span class=n>min_units</span><span class=p>,</span> <span class=n>ref</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&quot;method &quot;</span> <span class=o>+</span> <span class=n>method</span> <span class=o>+</span> <span class=s2>&quot; not implemented&quot;</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>nanmedian</span><span class=p>(</span><span class=n>rank_order</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span> <span class=n>rank_order</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.get_raster_points class="doc doc-heading"> <code class="highlight language-python"><span class=n>get_raster_points</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Generate points for a raster plot centered around each reference time in the <code>time_ref</code> array.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of time values.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_ref</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of reference times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of each bin in the raster plot, in seconds. Default is 0.002 seconds.</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins in the raster plot. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=tuple>tuple</span></code> </td> <td> <div class=doc-md-description> <p>A tuple containing the start and end times of the window to be plotted around each reference time. If not provided, the window will be centered around each reference time and have a width of <code>n_bins * bin_width</code> seconds.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>x</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of x values representing the time offsets of each data point relative to the corresponding reference time.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>y</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of y values representing the reference times.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>times</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of time values corresponding to the bins in the raster plot.</p> </div> </td> </tr> </tbody> </table> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>354</span>
<span class=normal>355</span>
<span class=normal>356</span>
<span class=normal>357</span>
<span class=normal>358</span>
<span class=normal>359</span>
<span class=normal>360</span>
<span class=normal>361</span>
<span class=normal>362</span>
<span class=normal>363</span>
<span class=normal>364</span>
<span class=normal>365</span>
<span class=normal>366</span>
<span class=normal>367</span>
<span class=normal>368</span>
<span class=normal>369</span>
<span class=normal>370</span>
<span class=normal>371</span>
<span class=normal>372</span>
<span class=normal>373</span>
<span class=normal>374</span>
<span class=normal>375</span>
<span class=normal>376</span>
<span class=normal>377</span>
<span class=normal>378</span>
<span class=normal>379</span>
<span class=normal>380</span>
<span class=normal>381</span>
<span class=normal>382</span>
<span class=normal>383</span>
<span class=normal>384</span>
<span class=normal>385</span>
<span class=normal>386</span>
<span class=normal>387</span>
<span class=normal>388</span>
<span class=normal>389</span>
<span class=normal>390</span>
<span class=normal>391</span>
<span class=normal>392</span>
<span class=normal>393</span>
<span class=normal>394</span>
<span class=normal>395</span>
<span class=normal>396</span>
<span class=normal>397</span>
<span class=normal>398</span>
<span class=normal>399</span>
<span class=normal>400</span>
<span class=normal>401</span>
<span class=normal>402</span>
<span class=normal>403</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>get_raster_points</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>time_ref</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Generate points for a raster plot centered around each reference time in the `time_ref` array.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : ndarray</span>
<span class=sd>        A 1D array of time values.</span>
<span class=sd>    time_ref : ndarray</span>
<span class=sd>        A 1D array of reference times.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        The width of each bin in the raster plot, in seconds. Default is 0.002 seconds.</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        The number of bins in the raster plot. Default is 100.</span>
<span class=sd>    window : tuple, optional</span>
<span class=sd>        A tuple containing the start and end times of the window to be plotted around each reference time.</span>
<span class=sd>        If not provided, the window will be centered around each reference time and have a width of `n_bins * bin_width` seconds.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    x : ndarray</span>
<span class=sd>        A 1D array of x values representing the time offsets of each data point relative to the corresponding reference time.</span>
<span class=sd>    y : ndarray</span>
<span class=sd>        A 1D array of y values representing the reference times.</span>
<span class=sd>    times : ndarray</span>
<span class=sd>        A 1D array of time values corresponding to the bins in the raster plot.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=p>)</span>

    <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=n>y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>time_ref</span><span class=p>):</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=p>(</span><span class=n>data</span> <span class=o>&gt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>times</span><span class=o>.</span><span class=n>min</span><span class=p>())</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>data</span> <span class=o>&lt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>times</span><span class=o>.</span><span class=n>max</span><span class=p>())</span>
        <span class=n>cur_data</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>
        <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>concatenate</span><span class=p>((</span><span class=n>x</span><span class=p>,</span> <span class=n>cur_data</span> <span class=o>-</span> <span class=n>r</span><span class=p>))</span>
        <span class=n>y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>concatenate</span><span class=p>((</span><span class=n>y</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ones_like</span><span class=p>(</span><span class=n>cur_data</span><span class=p>)</span> <span class=o>*</span> <span class=n>i</span><span class=p>))</span>

    <span class=k>return</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>times</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.joint_peth class="doc doc-heading"> <code class="highlight language-python"><span class=n>joint_peth</span><span class=p>(</span><span class=n>peth_1</span><span class=p>,</span> <span class=n>peth_2</span><span class=p>,</span> <span class=n>smooth_std</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Produce a joint histogram for the co-occurrence of two sets of signals around events.</p> <p>This analysis tests for interactions. For example, the interaction of ripples and spindles around the occurrence of delta waves. It is a good way to control whether the relationships between two variables is entirely explained by a third variable (the events serving as basis for the PETHs).</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>peth_1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The first peri-event time histogram (PETH) signal, shape (n_events, n_time).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>peth_2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The second peri-event time histogram (PETH) signal, shape (n_events, n_time).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>smooth_std</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The standard deviation of the Gaussian smoothing kernel (default is 2).</p> </div> </td> <td> <code>2</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>joint</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The joint histogram of the two PETH signals (n_time, n_time).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>expected</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The expected histogram of the two PETH signals (n_time, n_time).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>difference</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The difference between the joint and expected histograms of the two PETH signals (n_time, n_time).</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.process.peri_event</span><span class=w> </span><span class=kn>import</span> <span class=n>joint_peth</span><span class=p>,</span> <span class=n>peth_matrix</span><span class=p>,</span> <span class=n>joint_peth</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.spikes.spike_tools</span><span class=w> </span><span class=kn>import</span> <span class=n>get_spindices</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.io</span><span class=w> </span><span class=kn>import</span> <span class=n>loading</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load ripples, delta waves, and PFC pyramidal cell spikes from basepath</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>basepath</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;Z:\Data\HMC1\day8&quot;</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>ripples</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_ripples_events</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>delta_waves</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_events</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>epoch_name</span><span class=o>=</span><span class=s2>&quot;deltaWaves&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span><span class=n>cm</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span><span class=n>brainRegion</span><span class=o>=</span><span class=s2>&quot;PFC&quot;</span><span class=p>,</span><span class=n>putativeCellType</span><span class=o>=</span><span class=s2>&quot;Pyr&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># flatten spikes (nelpy has .flatten(), but get_spindices is much faster)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>spikes</span> <span class=o>=</span> <span class=n>get_spindices</span><span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># create peri-event time histograms (PETHs) for the three signals</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>labels</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&quot;spikes&quot;</span><span class=p>,</span> <span class=s2>&quot;ripple&quot;</span><span class=p>,</span> <span class=s2>&quot;delta&quot;</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_1</span><span class=p>,</span><span class=n>ts</span> <span class=o>=</span> <span class=n>peth_matrix</span><span class=p>(</span><span class=n>spikes</span><span class=o>.</span><span class=n>spike_times</span><span class=o>.</span><span class=n>values</span><span class=p>,</span> <span class=n>delta_waves</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.02</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>101</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_2</span><span class=p>,</span><span class=n>ts</span> <span class=o>=</span> <span class=n>peth_matrix</span><span class=p>(</span><span class=n>ripples</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>delta_waves</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.02</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>101</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># calculate the joint, expected, and difference histograms</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>joint</span><span class=p>,</span> <span class=n>expected</span><span class=p>,</span> <span class=n>difference</span> <span class=o>=</span> <span class=n>joint_peth</span><span class=p>(</span><span class=n>peth_1</span><span class=o>.</span><span class=n>T</span><span class=p>,</span> <span class=n>peth_2</span><span class=o>.</span><span class=n>T</span><span class=p>,</span> <span class=n>smooth_std</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
</code></pre></div> <details class=note open> <summary>Notes</summary> <p>Note: sometimes the difference between "joint" and "expected" may be dominated due to brain state effects (e.g. if both ripples are spindles are more common around delta waves taking place in early SWS and have decreased rates around delta waves in late SWS, then all the values of "joint" would be larger than the value of "expected". In such a case, to investigate the timing effects in particular and ignore such global changes (correlations across the rows of "PETH1" and "PETH2"), consider normalizing the rows of the PETHs before calling joint_peth.</p> <p>See Sirota et al. (2003)</p> <p>Adapted from JointPETH.m, Copyright (C) 2018-2022 by Ralitsa Todorova</p> </details> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>189</span>
<span class=normal>190</span>
<span class=normal>191</span>
<span class=normal>192</span>
<span class=normal>193</span>
<span class=normal>194</span>
<span class=normal>195</span>
<span class=normal>196</span>
<span class=normal>197</span>
<span class=normal>198</span>
<span class=normal>199</span>
<span class=normal>200</span>
<span class=normal>201</span>
<span class=normal>202</span>
<span class=normal>203</span>
<span class=normal>204</span>
<span class=normal>205</span>
<span class=normal>206</span>
<span class=normal>207</span>
<span class=normal>208</span>
<span class=normal>209</span>
<span class=normal>210</span>
<span class=normal>211</span>
<span class=normal>212</span>
<span class=normal>213</span>
<span class=normal>214</span>
<span class=normal>215</span>
<span class=normal>216</span>
<span class=normal>217</span>
<span class=normal>218</span>
<span class=normal>219</span>
<span class=normal>220</span>
<span class=normal>221</span>
<span class=normal>222</span>
<span class=normal>223</span>
<span class=normal>224</span>
<span class=normal>225</span>
<span class=normal>226</span>
<span class=normal>227</span>
<span class=normal>228</span>
<span class=normal>229</span>
<span class=normal>230</span>
<span class=normal>231</span>
<span class=normal>232</span>
<span class=normal>233</span>
<span class=normal>234</span>
<span class=normal>235</span>
<span class=normal>236</span>
<span class=normal>237</span>
<span class=normal>238</span>
<span class=normal>239</span>
<span class=normal>240</span>
<span class=normal>241</span>
<span class=normal>242</span>
<span class=normal>243</span>
<span class=normal>244</span>
<span class=normal>245</span>
<span class=normal>246</span>
<span class=normal>247</span>
<span class=normal>248</span>
<span class=normal>249</span>
<span class=normal>250</span>
<span class=normal>251</span>
<span class=normal>252</span>
<span class=normal>253</span>
<span class=normal>254</span>
<span class=normal>255</span>
<span class=normal>256</span>
<span class=normal>257</span>
<span class=normal>258</span>
<span class=normal>259</span>
<span class=normal>260</span>
<span class=normal>261</span>
<span class=normal>262</span>
<span class=normal>263</span>
<span class=normal>264</span>
<span class=normal>265</span>
<span class=normal>266</span>
<span class=normal>267</span>
<span class=normal>268</span>
<span class=normal>269</span>
<span class=normal>270</span>
<span class=normal>271</span>
<span class=normal>272</span>
<span class=normal>273</span>
<span class=normal>274</span>
<span class=normal>275</span>
<span class=normal>276</span>
<span class=normal>277</span>
<span class=normal>278</span>
<span class=normal>279</span>
<span class=normal>280</span>
<span class=normal>281</span>
<span class=normal>282</span>
<span class=normal>283</span>
<span class=normal>284</span>
<span class=normal>285</span>
<span class=normal>286</span>
<span class=normal>287</span>
<span class=normal>288</span>
<span class=normal>289</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>joint_peth</span><span class=p>(</span>
    <span class=n>peth_1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>peth_2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>smooth_std</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>2</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Produce a joint histogram for the co-occurrence of two sets of signals around events.</span>

<span class=sd>    This analysis tests for interactions. For example, the interaction of</span>
<span class=sd>    ripples and spindles around the occurrence of delta waves. It is a good way</span>
<span class=sd>    to control whether the relationships between two variables is entirely explained</span>
<span class=sd>    by a third variable (the events serving as basis for the PETHs).</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    peth_1 : np.ndarray</span>
<span class=sd>        The first peri-event time histogram (PETH) signal, shape (n_events, n_time).</span>
<span class=sd>    peth_2 : np.ndarray</span>
<span class=sd>        The second peri-event time histogram (PETH) signal, shape (n_events, n_time).</span>
<span class=sd>    smooth_std : float, optional</span>
<span class=sd>        The standard deviation of the Gaussian smoothing kernel (default is 2).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    joint : np.ndarray</span>
<span class=sd>        The joint histogram of the two PETH signals (n_time, n_time).</span>
<span class=sd>    expected : np.ndarray</span>
<span class=sd>        The expected histogram of the two PETH signals (n_time, n_time).</span>
<span class=sd>    difference : np.ndarray</span>
<span class=sd>        The difference between the joint and expected histograms of the two PETH signals (n_time, n_time).</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.process.peri_event import joint_peth, peth_matrix, joint_peth</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.spikes.spike_tools import get_spindices</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.io import loading</span>

<span class=sd>    &gt;&gt;&gt; # load ripples, delta waves, and PFC pyramidal cell spikes from basepath</span>

<span class=sd>    &gt;&gt;&gt; basepath = r&quot;Z:\\Data\\HMC1\\day8&quot;</span>

<span class=sd>    &gt;&gt;&gt; ripples = loading.load_ripples_events(basepath, return_epoch_array=True)</span>
<span class=sd>    &gt;&gt;&gt; delta_waves = loading.load_events(basepath, epoch_name=&quot;deltaWaves&quot;)</span>
<span class=sd>    &gt;&gt;&gt; st,cm = loading.load_spikes(basepath,brainRegion=&quot;PFC&quot;,putativeCellType=&quot;Pyr&quot;)</span>

<span class=sd>    &gt;&gt;&gt; # flatten spikes (nelpy has .flatten(), but get_spindices is much faster)</span>
<span class=sd>    &gt;&gt;&gt; spikes = get_spindices(st.data)</span>

<span class=sd>    &gt;&gt;&gt; # create peri-event time histograms (PETHs) for the three signals</span>
<span class=sd>    &gt;&gt;&gt; window=[-1,1]</span>
<span class=sd>    &gt;&gt;&gt; labels = [&quot;spikes&quot;, &quot;ripple&quot;, &quot;delta&quot;]</span>
<span class=sd>    &gt;&gt;&gt; peth_1,ts = peth_matrix(spikes.spike_times.values, delta_waves.starts, bin_width=0.02, n_bins=101)</span>
<span class=sd>    &gt;&gt;&gt; peth_2,ts = peth_matrix(ripples.starts, delta_waves.starts, bin_width=0.02, n_bins=101)</span>

<span class=sd>    &gt;&gt;&gt; # calculate the joint, expected, and difference histograms</span>
<span class=sd>    &gt;&gt;&gt; joint, expected, difference = joint_peth(peth_1.T, peth_2.T, smooth_std=2)</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Note: sometimes the difference between &quot;joint&quot; and &quot;expected&quot; may be dominated due to</span>
<span class=sd>    brain state effects (e.g. if both ripples are spindles are more common around delta</span>
<span class=sd>    waves taking place in early SWS and have decreased rates around delta waves in late</span>
<span class=sd>    SWS, then all the values of &quot;joint&quot; would be larger than the value of &quot;expected&quot;.</span>
<span class=sd>    In such a case, to investigate the timing effects in particular and ignore such</span>
<span class=sd>    global changes (correlations across the rows of &quot;PETH1&quot; and &quot;PETH2&quot;), consider</span>
<span class=sd>    normalizing the rows of the PETHs before calling joint_peth.</span>

<span class=sd>    See Sirota et al. (2003)</span>

<span class=sd>    Adapted from JointPETH.m, Copyright (C) 2018-2022 by Ralitsa Todorova</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=kn>from</span><span class=w> </span><span class=nn>scipy.ndimage</span><span class=w> </span><span class=kn>import</span> <span class=n>gaussian_filter</span>

    <span class=c1># make inputs np.ndarrays</span>
    <span class=n>peth_1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>peth_1</span><span class=p>)</span>
    <span class=n>peth_2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>peth_2</span><span class=p>)</span>

    <span class=c1># calculate the joint histogram</span>
    <span class=n>joint</span> <span class=o>=</span> <span class=n>peth_1</span><span class=o>.</span><span class=n>T</span> <span class=o>@</span> <span class=n>peth_2</span>

    <span class=c1># smooth the 2d joint histogram</span>
    <span class=n>joint</span> <span class=o>=</span> <span class=n>gaussian_filter</span><span class=p>(</span><span class=n>joint</span><span class=p>,</span> <span class=n>smooth_std</span><span class=p>)</span>

    <span class=c1># calculate the expected histogram</span>
    <span class=n>expected</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>peth_1</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>),</span> <span class=p>[</span><span class=n>peth_1</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=mi>1</span><span class=p>])</span><span class=o>.</span><span class=n>T</span> <span class=o>@</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>peth_2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>),</span> <span class=p>[</span><span class=n>peth_2</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=mi>1</span><span class=p>]</span>
    <span class=p>)</span>

    <span class=c1># smooth the 2d expected histogram</span>
    <span class=n>expected</span> <span class=o>=</span> <span class=n>gaussian_filter</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=n>smooth_std</span><span class=p>)</span>

    <span class=c1># normalize the joint and expected histograms</span>
    <span class=n>joint</span> <span class=o>=</span> <span class=n>joint</span> <span class=o>/</span> <span class=n>peth_1</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>expected</span> <span class=o>=</span> <span class=n>expected</span> <span class=o>/</span> <span class=n>peth_1</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>

    <span class=c1># square root the joint and expected histograms so result is Hz</span>
    <span class=n>joint</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>joint</span><span class=p>)</span>
    <span class=n>expected</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>expected</span><span class=p>)</span>

    <span class=c1># calculate the difference between the joint and expected histograms</span>
    <span class=n>difference</span> <span class=o>=</span> <span class=n>joint</span> <span class=o>-</span> <span class=n>expected</span>

    <span class=k>return</span> <span class=n>joint</span><span class=p>,</span> <span class=n>expected</span><span class=p>,</span> <span class=n>difference</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.nearest_event_delay class="doc doc-heading"> <code class="highlight language-python"><span class=n>nearest_event_delay</span><span class=p>(</span><span class=n>ts_1</span><span class=p>,</span> <span class=n>ts_2</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Return for each timestamp in ts_1 the nearest timestamp in ts_2 and the delay between the two.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>ts_1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of timestamps.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>ts_2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of timestamps (must be monotonically increasing).</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>nearest_ts</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Nearest timestamps in ts_2 for each timestamp in ts_1.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>delays</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Delays between ts_1 and nearest_ts.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>nearest_index</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Index of nearest_ts in ts_2.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Raises:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=ValueError>ValueError</span></code> </td> <td> <div class=doc-md-description> <p>If ts_1 or ts_2 are empty or not monotonically increasing.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>Both ts_1 and ts_2 must be monotonically increasing arrays of timestamps.</p> </details> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1707</span>
<span class=normal>1708</span>
<span class=normal>1709</span>
<span class=normal>1710</span>
<span class=normal>1711</span>
<span class=normal>1712</span>
<span class=normal>1713</span>
<span class=normal>1714</span>
<span class=normal>1715</span>
<span class=normal>1716</span>
<span class=normal>1717</span>
<span class=normal>1718</span>
<span class=normal>1719</span>
<span class=normal>1720</span>
<span class=normal>1721</span>
<span class=normal>1722</span>
<span class=normal>1723</span>
<span class=normal>1724</span>
<span class=normal>1725</span>
<span class=normal>1726</span>
<span class=normal>1727</span>
<span class=normal>1728</span>
<span class=normal>1729</span>
<span class=normal>1730</span>
<span class=normal>1731</span>
<span class=normal>1732</span>
<span class=normal>1733</span>
<span class=normal>1734</span>
<span class=normal>1735</span>
<span class=normal>1736</span>
<span class=normal>1737</span>
<span class=normal>1738</span>
<span class=normal>1739</span>
<span class=normal>1740</span>
<span class=normal>1741</span>
<span class=normal>1742</span>
<span class=normal>1743</span>
<span class=normal>1744</span>
<span class=normal>1745</span>
<span class=normal>1746</span>
<span class=normal>1747</span>
<span class=normal>1748</span>
<span class=normal>1749</span>
<span class=normal>1750</span>
<span class=normal>1751</span>
<span class=normal>1752</span>
<span class=normal>1753</span>
<span class=normal>1754</span>
<span class=normal>1755</span>
<span class=normal>1756</span>
<span class=normal>1757</span>
<span class=normal>1758</span>
<span class=normal>1759</span>
<span class=normal>1760</span>
<span class=normal>1761</span>
<span class=normal>1762</span>
<span class=normal>1763</span>
<span class=normal>1764</span>
<span class=normal>1765</span>
<span class=normal>1766</span>
<span class=normal>1767</span>
<span class=normal>1768</span>
<span class=normal>1769</span>
<span class=normal>1770</span>
<span class=normal>1771</span>
<span class=normal>1772</span>
<span class=normal>1773</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>nearest_event_delay</span><span class=p>(</span>
    <span class=n>ts_1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>ts_2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Return for each timestamp in ts_1 the nearest timestamp in ts_2 and the delay between the two.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    ts_1 : np.ndarray</span>
<span class=sd>        1D array of timestamps.</span>
<span class=sd>    ts_2 : np.ndarray</span>
<span class=sd>        1D array of timestamps (must be monotonically increasing).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    nearest_ts : np.ndarray</span>
<span class=sd>        Nearest timestamps in ts_2 for each timestamp in ts_1.</span>
<span class=sd>    delays : np.ndarray</span>
<span class=sd>        Delays between ts_1 and nearest_ts.</span>
<span class=sd>    nearest_index : np.ndarray</span>
<span class=sd>        Index of nearest_ts in ts_2.</span>

<span class=sd>    Raises</span>
<span class=sd>    ------</span>
<span class=sd>    ValueError</span>
<span class=sd>        If ts_1 or ts_2 are empty or not monotonically increasing.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Both ts_1 and ts_2 must be monotonically increasing arrays of timestamps.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>ts_1</span><span class=p>,</span> <span class=n>ts_2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>ts_1</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>ts_2</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>all</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>ts_2</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ts_2 must be monotonically increasing&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>all</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>ts_1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ts_1 must be monotonically increasing&quot;</span><span class=p>)</span>
    <span class=c1># check if empty</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>ts_1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ts_1 is empty&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>ts_2</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ts_2 is empty&quot;</span><span class=p>)</span>

    <span class=c1># Use searchsorted to find the indices where elements of ts_1 should be inserted</span>
    <span class=n>nearest_indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>ts_2</span><span class=p>,</span> <span class=n>ts_1</span><span class=p>,</span> <span class=n>side</span><span class=o>=</span><span class=s2>&quot;left&quot;</span><span class=p>)</span>

    <span class=c1># Calculate indices for the elements before and after the insertion points</span>
    <span class=n>before</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>maximum</span><span class=p>(</span><span class=n>nearest_indices</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
    <span class=n>after</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>minimum</span><span class=p>(</span><span class=n>nearest_indices</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>ts_2</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

    <span class=c1># Determine the nearest timestamp for each element in ts_1</span>
    <span class=n>nearest_ts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>ts_1</span> <span class=o>-</span> <span class=n>ts_2</span><span class=p>[</span><span class=n>before</span><span class=p>])</span> <span class=o>&lt;</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>ts_1</span> <span class=o>-</span> <span class=n>ts_2</span><span class=p>[</span><span class=n>after</span><span class=p>]),</span>
        <span class=n>ts_2</span><span class=p>[</span><span class=n>before</span><span class=p>],</span>
        <span class=n>ts_2</span><span class=p>[</span><span class=n>after</span><span class=p>],</span>
    <span class=p>)</span>

    <span class=c1># Calculate delays between ts_1 and nearest_ts</span>
    <span class=n>delays</span> <span class=o>=</span> <span class=n>ts_1</span> <span class=o>-</span> <span class=n>nearest_ts</span>

    <span class=c1># Find the nearest_index using the absolute difference</span>
    <span class=n>absolute_diff_before</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>ts_1</span> <span class=o>-</span> <span class=n>ts_2</span><span class=p>[</span><span class=n>before</span><span class=p>])</span>
    <span class=n>absolute_diff_after</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>ts_1</span> <span class=o>-</span> <span class=n>ts_2</span><span class=p>[</span><span class=n>after</span><span class=p>])</span>
    <span class=n>nearest_index</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span><span class=n>absolute_diff_before</span> <span class=o>&lt;</span> <span class=n>absolute_diff_after</span><span class=p>,</span> <span class=n>before</span><span class=p>,</span> <span class=n>after</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>nearest_ts</span><span class=p>,</span> <span class=n>delays</span><span class=p>,</span> <span class=n>nearest_index</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.peth class="doc doc-heading"> <code class="highlight language-python"><span class=n>peth</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>average</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute peri-event time histogram (PETH) for nelpy data objects or numpy arrays.</p> <p>This is a high-level function that handles multiple data types and automatically computes the appropriate PETH based on the input data type. For point process data (spikes/events), it computes firing rates (Hz). For continuous data (analog signals), it computes event-triggered averages.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code>nelpy object or np.ndarray</code> </td> <td> <div class=doc-md-description> <p>Data can be: - AnalogSignalArray: continuous signals - PositionArray: 2D/3D position data (x, y, [z] coordinates) - SpikeTrainArray: spike trains - BinnedSpikeTrainArray: binned spike trains - EventArray: event times - BinnedEventArray: binned events - np.ndarray: array of spike times (object array) or continuous signal</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of event times to align data to.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>Time window around events [start, end] in seconds. If None, uses symmetric window based on n_bins and bin_width.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Width of time bins in seconds (default 0.002).</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of bins (default 100). Ignored if window is specified.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>average</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True (default), returns averaged PETH across all events as DataFrame. If False, returns event-wise PETH matrix and time bins array.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span> or <span title=typing.Tuple>Tuple</span>[<span title=numpy.ndarray>ndarray</span>, <span title=numpy.ndarray>ndarray</span>]</code> </td> <td> <div class=doc-md-description> <p>If average=True: DataFrame with time bins as index and each series/signal as columns. Values are rates (Hz) for point process data or averaged signal values for continuous data. If average=False: Tuple of (peth_matrix, time_bins) where: - peth_matrix: 3D array with shape (n_time_bins, n_signals, n_events) - time_bins: 1D array of time bin centers</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># With SpikeTrainArray - averaged across events</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span><span class=n>basepath</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>ripples</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_ripples_events</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_df</span> <span class=o>=</span> <span class=n>peth</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>ripples</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.01</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Get event-wise matrix for detailed analysis</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_matrix</span><span class=p>,</span> <span class=n>time_bins</span> <span class=o>=</span> <span class=n>peth</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>ripples</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
<span class=gp>... </span>                              <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.01</span><span class=p>,</span> <span class=n>average</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># peth_matrix.shape: (n_time_bins, n_units, n_events)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># Can now analyze individual events</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>strong_events</span> <span class=o>=</span> <span class=n>peth_matrix</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>))</span> <span class=o>&gt;</span> <span class=n>threshold</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># With AnalogSignalArray</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span><span class=w> </span><span class=nn>numpy</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>np</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>nelpy</span><span class=w> </span><span class=kn>import</span> <span class=n>AnalogSignalArray</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>timestamps</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>signal</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>([</span>
<span class=gp>... </span>    <span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=n>timestamps</span><span class=p>),</span>
<span class=gp>... </span>    <span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=n>timestamps</span><span class=p>),</span>
<span class=gp>... </span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>lfp</span> <span class=o>=</span> <span class=n>AnalogSignalArray</span><span class=p>(</span><span class=n>timestamps</span><span class=o>=</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=n>signal</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>events</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_df</span> <span class=o>=</span> <span class=n>peth</span><span class=p>(</span><span class=n>lfp</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>])</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Get event-wise continuous data</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>lfp_matrix</span><span class=p>,</span> <span class=n>time_lags</span> <span class=o>=</span> <span class=n>peth</span><span class=p>(</span><span class=n>lfp</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>],</span> <span class=n>average</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># With PositionArray</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>nelpy</span><span class=w> </span><span class=kn>import</span> <span class=n>PositionArray</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>x_pos</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=n>timestamps</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>y_pos</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=n>timestamps</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>position</span> <span class=o>=</span> <span class=n>PositionArray</span><span class=p>(</span><span class=n>timestamps</span><span class=o>=</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>([</span><span class=n>x_pos</span><span class=p>,</span> <span class=n>y_pos</span><span class=p>]))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_df</span> <span class=o>=</span> <span class=n>peth</span><span class=p>(</span><span class=n>position</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>])</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># With numpy array</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>spikes</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>spike_train_1</span><span class=p>,</span> <span class=n>spike_train_2</span><span class=p>],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>object</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_df</span> <span class=o>=</span> <span class=n>peth</span><span class=p>(</span><span class=n>spikes</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>])</span>
</code></pre></div> <details class=note open> <summary>Notes</summary> <ul> <li>For point process data (spikes/events), uses crossCorr to compute firing rates</li> <li>For continuous data (analog signals), uses event_triggered_average<ul> <li>For continuous data, output resolution follows the signal sampling rate; <code>bin_width</code> is ignored unless you resample beforehand</li> <li>For numpy/object arrays of spike times, each spike train must be sorted in ascending order (crossCorr assumes sorted targets)</li> </ul> </li> <li>Returns rates in Hz for point process data</li> <li>Handles both regular and irregularly sampled continuous data</li> </ul> </details> <details class=see-also open> <summary>See Also</summary> <p>compute_psth : Lower-level PSTH computation for numpy arrays event_triggered_average : Event-triggered averaging for continuous signals crossCorr : Cross-correlogram computation</p> </details> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1052</span>
<span class=normal>1053</span>
<span class=normal>1054</span>
<span class=normal>1055</span>
<span class=normal>1056</span>
<span class=normal>1057</span>
<span class=normal>1058</span>
<span class=normal>1059</span>
<span class=normal>1060</span>
<span class=normal>1061</span>
<span class=normal>1062</span>
<span class=normal>1063</span>
<span class=normal>1064</span>
<span class=normal>1065</span>
<span class=normal>1066</span>
<span class=normal>1067</span>
<span class=normal>1068</span>
<span class=normal>1069</span>
<span class=normal>1070</span>
<span class=normal>1071</span>
<span class=normal>1072</span>
<span class=normal>1073</span>
<span class=normal>1074</span>
<span class=normal>1075</span>
<span class=normal>1076</span>
<span class=normal>1077</span>
<span class=normal>1078</span>
<span class=normal>1079</span>
<span class=normal>1080</span>
<span class=normal>1081</span>
<span class=normal>1082</span>
<span class=normal>1083</span>
<span class=normal>1084</span>
<span class=normal>1085</span>
<span class=normal>1086</span>
<span class=normal>1087</span>
<span class=normal>1088</span>
<span class=normal>1089</span>
<span class=normal>1090</span>
<span class=normal>1091</span>
<span class=normal>1092</span>
<span class=normal>1093</span>
<span class=normal>1094</span>
<span class=normal>1095</span>
<span class=normal>1096</span>
<span class=normal>1097</span>
<span class=normal>1098</span>
<span class=normal>1099</span>
<span class=normal>1100</span>
<span class=normal>1101</span>
<span class=normal>1102</span>
<span class=normal>1103</span>
<span class=normal>1104</span>
<span class=normal>1105</span>
<span class=normal>1106</span>
<span class=normal>1107</span>
<span class=normal>1108</span>
<span class=normal>1109</span>
<span class=normal>1110</span>
<span class=normal>1111</span>
<span class=normal>1112</span>
<span class=normal>1113</span>
<span class=normal>1114</span>
<span class=normal>1115</span>
<span class=normal>1116</span>
<span class=normal>1117</span>
<span class=normal>1118</span>
<span class=normal>1119</span>
<span class=normal>1120</span>
<span class=normal>1121</span>
<span class=normal>1122</span>
<span class=normal>1123</span>
<span class=normal>1124</span>
<span class=normal>1125</span>
<span class=normal>1126</span>
<span class=normal>1127</span>
<span class=normal>1128</span>
<span class=normal>1129</span>
<span class=normal>1130</span>
<span class=normal>1131</span>
<span class=normal>1132</span>
<span class=normal>1133</span>
<span class=normal>1134</span>
<span class=normal>1135</span>
<span class=normal>1136</span>
<span class=normal>1137</span>
<span class=normal>1138</span>
<span class=normal>1139</span>
<span class=normal>1140</span>
<span class=normal>1141</span>
<span class=normal>1142</span>
<span class=normal>1143</span>
<span class=normal>1144</span>
<span class=normal>1145</span>
<span class=normal>1146</span>
<span class=normal>1147</span>
<span class=normal>1148</span>
<span class=normal>1149</span>
<span class=normal>1150</span>
<span class=normal>1151</span>
<span class=normal>1152</span>
<span class=normal>1153</span>
<span class=normal>1154</span>
<span class=normal>1155</span>
<span class=normal>1156</span>
<span class=normal>1157</span>
<span class=normal>1158</span>
<span class=normal>1159</span>
<span class=normal>1160</span>
<span class=normal>1161</span>
<span class=normal>1162</span>
<span class=normal>1163</span>
<span class=normal>1164</span>
<span class=normal>1165</span>
<span class=normal>1166</span>
<span class=normal>1167</span>
<span class=normal>1168</span>
<span class=normal>1169</span>
<span class=normal>1170</span>
<span class=normal>1171</span>
<span class=normal>1172</span>
<span class=normal>1173</span>
<span class=normal>1174</span>
<span class=normal>1175</span>
<span class=normal>1176</span>
<span class=normal>1177</span>
<span class=normal>1178</span>
<span class=normal>1179</span>
<span class=normal>1180</span>
<span class=normal>1181</span>
<span class=normal>1182</span>
<span class=normal>1183</span>
<span class=normal>1184</span>
<span class=normal>1185</span>
<span class=normal>1186</span>
<span class=normal>1187</span>
<span class=normal>1188</span>
<span class=normal>1189</span>
<span class=normal>1190</span>
<span class=normal>1191</span>
<span class=normal>1192</span>
<span class=normal>1193</span>
<span class=normal>1194</span>
<span class=normal>1195</span>
<span class=normal>1196</span>
<span class=normal>1197</span>
<span class=normal>1198</span>
<span class=normal>1199</span>
<span class=normal>1200</span>
<span class=normal>1201</span>
<span class=normal>1202</span>
<span class=normal>1203</span>
<span class=normal>1204</span>
<span class=normal>1205</span>
<span class=normal>1206</span>
<span class=normal>1207</span>
<span class=normal>1208</span>
<span class=normal>1209</span>
<span class=normal>1210</span>
<span class=normal>1211</span>
<span class=normal>1212</span>
<span class=normal>1213</span>
<span class=normal>1214</span>
<span class=normal>1215</span>
<span class=normal>1216</span>
<span class=normal>1217</span>
<span class=normal>1218</span>
<span class=normal>1219</span>
<span class=normal>1220</span>
<span class=normal>1221</span>
<span class=normal>1222</span>
<span class=normal>1223</span>
<span class=normal>1224</span>
<span class=normal>1225</span>
<span class=normal>1226</span>
<span class=normal>1227</span>
<span class=normal>1228</span>
<span class=normal>1229</span>
<span class=normal>1230</span>
<span class=normal>1231</span>
<span class=normal>1232</span>
<span class=normal>1233</span>
<span class=normal>1234</span>
<span class=normal>1235</span>
<span class=normal>1236</span>
<span class=normal>1237</span>
<span class=normal>1238</span>
<span class=normal>1239</span>
<span class=normal>1240</span>
<span class=normal>1241</span>
<span class=normal>1242</span>
<span class=normal>1243</span>
<span class=normal>1244</span>
<span class=normal>1245</span>
<span class=normal>1246</span>
<span class=normal>1247</span>
<span class=normal>1248</span>
<span class=normal>1249</span>
<span class=normal>1250</span>
<span class=normal>1251</span>
<span class=normal>1252</span>
<span class=normal>1253</span>
<span class=normal>1254</span>
<span class=normal>1255</span>
<span class=normal>1256</span>
<span class=normal>1257</span>
<span class=normal>1258</span>
<span class=normal>1259</span>
<span class=normal>1260</span>
<span class=normal>1261</span>
<span class=normal>1262</span>
<span class=normal>1263</span>
<span class=normal>1264</span>
<span class=normal>1265</span>
<span class=normal>1266</span>
<span class=normal>1267</span>
<span class=normal>1268</span>
<span class=normal>1269</span>
<span class=normal>1270</span>
<span class=normal>1271</span>
<span class=normal>1272</span>
<span class=normal>1273</span>
<span class=normal>1274</span>
<span class=normal>1275</span>
<span class=normal>1276</span>
<span class=normal>1277</span>
<span class=normal>1278</span>
<span class=normal>1279</span>
<span class=normal>1280</span>
<span class=normal>1281</span>
<span class=normal>1282</span>
<span class=normal>1283</span>
<span class=normal>1284</span>
<span class=normal>1285</span>
<span class=normal>1286</span>
<span class=normal>1287</span>
<span class=normal>1288</span>
<span class=normal>1289</span>
<span class=normal>1290</span>
<span class=normal>1291</span>
<span class=normal>1292</span>
<span class=normal>1293</span>
<span class=normal>1294</span>
<span class=normal>1295</span>
<span class=normal>1296</span>
<span class=normal>1297</span>
<span class=normal>1298</span>
<span class=normal>1299</span>
<span class=normal>1300</span>
<span class=normal>1301</span>
<span class=normal>1302</span>
<span class=normal>1303</span>
<span class=normal>1304</span>
<span class=normal>1305</span>
<span class=normal>1306</span>
<span class=normal>1307</span>
<span class=normal>1308</span>
<span class=normal>1309</span>
<span class=normal>1310</span>
<span class=normal>1311</span>
<span class=normal>1312</span>
<span class=normal>1313</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>peth</span><span class=p>(</span>
    <span class=n>data</span><span class=p>,</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>list</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>average</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Union</span><span class=p>[</span><span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute peri-event time histogram (PETH) for nelpy data objects or numpy arrays.</span>

<span class=sd>    This is a high-level function that handles multiple data types and automatically</span>
<span class=sd>    computes the appropriate PETH based on the input data type. For point process data</span>
<span class=sd>    (spikes/events), it computes firing rates (Hz). For continuous data (analog signals),</span>
<span class=sd>    it computes event-triggered averages.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : nelpy object or np.ndarray</span>
<span class=sd>        Data can be:</span>
<span class=sd>        - AnalogSignalArray: continuous signals</span>
<span class=sd>        - PositionArray: 2D/3D position data (x, y, [z] coordinates)</span>
<span class=sd>        - SpikeTrainArray: spike trains</span>
<span class=sd>        - BinnedSpikeTrainArray: binned spike trains</span>
<span class=sd>        - EventArray: event times</span>
<span class=sd>        - BinnedEventArray: binned events</span>
<span class=sd>        - np.ndarray: array of spike times (object array) or continuous signal</span>
<span class=sd>    events : np.ndarray</span>
<span class=sd>        1D array of event times to align data to.</span>
<span class=sd>    window : list, optional</span>
<span class=sd>        Time window around events [start, end] in seconds.</span>
<span class=sd>        If None, uses symmetric window based on n_bins and bin_width.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        Width of time bins in seconds (default 0.002).</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        Number of bins (default 100). Ignored if window is specified.</span>
<span class=sd>    average : bool, optional</span>
<span class=sd>        If True (default), returns averaged PETH across all events as DataFrame.</span>
<span class=sd>        If False, returns event-wise PETH matrix and time bins array.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame or Tuple[np.ndarray, np.ndarray]</span>
<span class=sd>        If average=True:</span>
<span class=sd>            DataFrame with time bins as index and each series/signal as columns.</span>
<span class=sd>            Values are rates (Hz) for point process data or averaged</span>
<span class=sd>            signal values for continuous data.</span>
<span class=sd>        If average=False:</span>
<span class=sd>            Tuple of (peth_matrix, time_bins) where:</span>
<span class=sd>            - peth_matrix: 3D array with shape (n_time_bins, n_signals, n_events)</span>
<span class=sd>            - time_bins: 1D array of time bin centers</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; # With SpikeTrainArray - averaged across events</span>
<span class=sd>    &gt;&gt;&gt; st, _ = loading.load_spikes(basepath)</span>
<span class=sd>    &gt;&gt;&gt; ripples = loading.load_ripples_events(basepath, return_epoch_array=True)</span>
<span class=sd>    &gt;&gt;&gt; peth_df = peth(st, ripples.starts, window=[-0.5, 0.5], bin_width=0.01)</span>

<span class=sd>    &gt;&gt;&gt; # Get event-wise matrix for detailed analysis</span>
<span class=sd>    &gt;&gt;&gt; peth_matrix, time_bins = peth(st, ripples.starts, window=[-0.5, 0.5],</span>
<span class=sd>    ...                               bin_width=0.01, average=False)</span>
<span class=sd>    &gt;&gt;&gt; # peth_matrix.shape: (n_time_bins, n_units, n_events)</span>
<span class=sd>    &gt;&gt;&gt; # Can now analyze individual events</span>
<span class=sd>    &gt;&gt;&gt; strong_events = peth_matrix.sum(axis=(0,1)) &gt; threshold</span>

<span class=sd>    &gt;&gt;&gt; # With AnalogSignalArray</span>
<span class=sd>    &gt;&gt;&gt; import numpy as np</span>
<span class=sd>    &gt;&gt;&gt; from nelpy import AnalogSignalArray</span>
<span class=sd>    &gt;&gt;&gt; timestamps = np.linspace(0, 5, 100)</span>
<span class=sd>    &gt;&gt;&gt; signal = np.vstack([</span>
<span class=sd>    ...     np.sin(2 * np.pi * timestamps),</span>
<span class=sd>    ...     np.cos(2 * np.pi * timestamps),</span>
<span class=sd>    ... ])</span>
<span class=sd>    &gt;&gt;&gt; lfp = AnalogSignalArray(timestamps=timestamps, data=signal)</span>
<span class=sd>    &gt;&gt;&gt; events = np.array([1.0, 2.0, 3.0])</span>
<span class=sd>    &gt;&gt;&gt; peth_df = peth(lfp, events, window=[-0.2, 0.2])</span>

<span class=sd>    &gt;&gt;&gt; # Get event-wise continuous data</span>
<span class=sd>    &gt;&gt;&gt; lfp_matrix, time_lags = peth(lfp, events, window=[-0.2, 0.2], average=False)</span>

<span class=sd>    &gt;&gt;&gt; # With PositionArray</span>
<span class=sd>    &gt;&gt;&gt; from nelpy import PositionArray</span>
<span class=sd>    &gt;&gt;&gt; x_pos = np.sin(2 * np.pi * timestamps)</span>
<span class=sd>    &gt;&gt;&gt; y_pos = np.cos(2 * np.pi * timestamps)</span>
<span class=sd>    &gt;&gt;&gt; position = PositionArray(timestamps=timestamps, data=np.vstack([x_pos, y_pos]))</span>
<span class=sd>    &gt;&gt;&gt; peth_df = peth(position, events, window=[-0.5, 0.5])</span>

<span class=sd>    &gt;&gt;&gt; # With numpy array</span>
<span class=sd>    &gt;&gt;&gt; spikes = np.array([spike_train_1, spike_train_2], dtype=object)</span>
<span class=sd>    &gt;&gt;&gt; peth_df = peth(spikes, events, window=[-0.5, 0.5])</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    - For point process data (spikes/events), uses crossCorr to compute firing rates</span>
<span class=sd>    - For continuous data (analog signals), uses event_triggered_average</span>
<span class=sd>        - For continuous data, output resolution follows the signal sampling rate;</span>
<span class=sd>            `bin_width` is ignored unless you resample beforehand</span>
<span class=sd>        - For numpy/object arrays of spike times, each spike train must be sorted in</span>
<span class=sd>            ascending order (crossCorr assumes sorted targets)</span>
<span class=sd>    - Returns rates in Hz for point process data</span>
<span class=sd>    - Handles both regular and irregularly sampled continuous data</span>

<span class=sd>    See Also</span>
<span class=sd>    --------</span>
<span class=sd>    compute_psth : Lower-level PSTH computation for numpy arrays</span>
<span class=sd>    event_triggered_average : Event-triggered averaging for continuous signals</span>
<span class=sd>    crossCorr : Cross-correlogram computation</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># Determine data type and extract spike/signal data</span>
    <span class=n>is_continuous</span> <span class=o>=</span> <span class=kc>False</span>

    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span>
        <span class=n>data</span><span class=p>,</span>
        <span class=p>(</span><span class=n>AnalogSignalArray</span><span class=p>,</span> <span class=n>PositionArray</span><span class=p>,</span> <span class=n>BinnedSpikeTrainArray</span><span class=p>,</span> <span class=n>BinnedEventArray</span><span class=p>),</span>
    <span class=p>):</span>
        <span class=c1># Continuous signal data (includes position and binned spike/event data)</span>
        <span class=n>is_continuous</span> <span class=o>=</span> <span class=kc>True</span>

        <span class=c1># Use bin_centers for binned data, abscissa_vals for others</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=p>(</span><span class=n>BinnedSpikeTrainArray</span><span class=p>,</span> <span class=n>BinnedEventArray</span><span class=p>)):</span>
            <span class=n>timestamps</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>bin_centers</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>timestamps</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>abscissa_vals</span>

        <span class=n>signal</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>T</span>  <span class=c1># transpose to (n_samples, n_signals)</span>
        <span class=c1># Use n_signals if available (AnalogSignalArray/PositionArray), otherwise n_series (BinnedSpikeTrainArray)</span>
        <span class=n>n_series</span> <span class=o>=</span> <span class=nb>getattr</span><span class=p>(</span>
            <span class=n>data</span><span class=p>,</span> <span class=s2>&quot;n_series&quot;</span><span class=p>,</span> <span class=nb>getattr</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=s2>&quot;n_signals&quot;</span><span class=p>,</span> <span class=n>data</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=p>)</span>

    <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=p>(</span><span class=n>SpikeTrainArray</span><span class=p>,</span> <span class=n>EventArray</span><span class=p>)):</span>
        <span class=c1># Point process data - extract spike times</span>
        <span class=n>is_continuous</span> <span class=o>=</span> <span class=kc>False</span>
        <span class=n>spike_data</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>data</span>
        <span class=n>n_series</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>spike_data</span><span class=p>)</span>

    <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>):</span>
        <span class=c1># Numpy array - determine if continuous or point process</span>
        <span class=k>if</span> <span class=n>data</span><span class=o>.</span><span class=n>dtype</span> <span class=o>==</span> <span class=nb>object</span><span class=p>:</span>
            <span class=c1># Object array - assume point process</span>
            <span class=n>is_continuous</span> <span class=o>=</span> <span class=kc>False</span>
            <span class=n>spike_data</span> <span class=o>=</span> <span class=n>data</span>
            <span class=n>n_series</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>spike_data</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=c1># Regular array - could be continuous or point process</span>
            <span class=c1># If 2D, assume continuous; if 1D, assume point process</span>
            <span class=k>if</span> <span class=n>data</span><span class=o>.</span><span class=n>ndim</span> <span class=o>==</span> <span class=mi>2</span><span class=p>:</span>
                <span class=c1># Continuous data</span>
                <span class=n>is_continuous</span> <span class=o>=</span> <span class=kc>True</span>
                <span class=c1># Need timestamps - if not provided, we can&#39;t use event_triggered_average</span>
                <span class=c1># Fall back to treating as point process</span>
                <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                    <span class=s2>&quot;For continuous numpy arrays, please use AnalogSignalArray or provide &quot;</span>
                    <span class=s2>&quot;timestamps separately via event_triggered_average function.&quot;</span>
                <span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=c1># 1D array - single point process</span>
                <span class=n>is_continuous</span> <span class=o>=</span> <span class=kc>False</span>
                <span class=n>spike_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>data</span><span class=p>],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>object</span><span class=p>)</span>
                <span class=n>n_series</span> <span class=o>=</span> <span class=mi>1</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
            <span class=sa>f</span><span class=s2>&quot;Unsupported data type: </span><span class=si>{</span><span class=nb>type</span><span class=p>(</span><span class=n>data</span><span class=p>)</span><span class=si>}</span><span class=s2>. &quot;</span>
            <span class=s2>&quot;Must be AnalogSignalArray, PositionArray, SpikeTrainArray, BinnedSpikeTrainArray, &quot;</span>
            <span class=s2>&quot;EventArray, BinnedEventArray, or np.ndarray&quot;</span>
        <span class=p>)</span>

    <span class=c1># Calculate time bins</span>
    <span class=n>window_original</span> <span class=o>=</span> <span class=kc>None</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=c1># Check if window is symmetric around 0, if not make it so</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>!=</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>|</span> <span class=p>(</span>
            <span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>/</span> <span class=o>-</span><span class=mi>2</span> <span class=o>!=</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=p>):</span>
            <span class=n>window_original</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>window</span><span class=p>)</span>
            <span class=n>window</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>window</span><span class=p>)),</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>window</span><span class=p>))]</span>

        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
        <span class=n>n_bins</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=p>)</span>

    <span class=c1># Compute PETH based on data type</span>
    <span class=k>if</span> <span class=n>is_continuous</span><span class=p>:</span>
        <span class=c1># Continuous data - use event_triggered_average</span>
        <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>window</span> <span class=o>=</span> <span class=p>[</span><span class=n>times</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>times</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span>

        <span class=c1># Calculate sampling rate</span>
        <span class=n>sampling_rate</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>np</span><span class=o>.</span><span class=n>median</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>timestamps</span><span class=p>))</span>

        <span class=c1># Compute event-triggered average</span>
        <span class=n>result</span><span class=p>,</span> <span class=n>time_lags</span> <span class=o>=</span> <span class=n>event_triggered_average</span><span class=p>(</span>
            <span class=n>timestamps</span><span class=p>,</span>
            <span class=n>signal</span><span class=p>,</span>
            <span class=n>events</span><span class=p>,</span>
            <span class=n>sampling_rate</span><span class=o>=</span><span class=n>sampling_rate</span><span class=p>,</span>
            <span class=n>window</span><span class=o>=</span><span class=n>window</span><span class=p>,</span>
            <span class=n>return_average</span><span class=o>=</span><span class=n>average</span><span class=p>,</span>
            <span class=n>return_pandas</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
        <span class=p>)</span>

        <span class=k>if</span> <span class=n>average</span><span class=p>:</span>
            <span class=c1># Create DataFrame from averaged result</span>
            <span class=n>peth_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>index</span><span class=o>=</span><span class=n>time_lags</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>n_series</span><span class=p>))</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=c1># Return matrix directly: (n_time_bins, n_signals, n_events)</span>
            <span class=c1># event_triggered_average already returns in the correct shape</span>
            <span class=k>return</span> <span class=n>result</span><span class=p>,</span> <span class=n>time_lags</span>

    <span class=k>else</span><span class=p>:</span>
        <span class=c1># Point process data</span>
        <span class=k>if</span> <span class=n>average</span><span class=p>:</span>
            <span class=c1># Use crossCorr for averaged PETH</span>
            <span class=n>peth_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>n_series</span><span class=p>))</span>

            <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>spike_data</span><span class=p>):</span>
                <span class=c1># Ensure spike times are float64</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
                    <span class=n>s</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>s</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([],</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>
                <span class=n>peth_df</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>events</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=c1># Use peth_matrix for event-wise PETH</span>
            <span class=c1># Build matrix for each spike train: (n_time_bins, n_signals, n_events)</span>
            <span class=n>matrices_list</span> <span class=o>=</span> <span class=p>[]</span>
            <span class=n>window_arg</span> <span class=o>=</span> <span class=kc>None</span> <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=kc>None</span> <span class=k>else</span> <span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>

            <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>spike_data</span><span class=p>):</span>
                <span class=c1># Ensure spike times are float64</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
                    <span class=n>s</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>s</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([],</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>

                <span class=c1># peth_matrix returns (n_time_bins, n_events)</span>
                <span class=n>H</span><span class=p>,</span> <span class=n>t</span> <span class=o>=</span> <span class=n>peth_matrix</span><span class=p>(</span>
                    <span class=n>s</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=n>n_bins</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=n>window_arg</span>
                <span class=p>)</span>
                <span class=n>matrices_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>H</span><span class=p>)</span>

            <span class=c1># Stack into (n_time_bins, n_signals, n_events)</span>
            <span class=n>result_matrix</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>stack</span><span class=p>(</span><span class=n>matrices_list</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>

            <span class=c1># If window was not symmetric, trim the time dimension</span>
            <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>window_original</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
                <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>t</span> <span class=o>&gt;=</span> <span class=n>window_original</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>t</span> <span class=o>&lt;=</span> <span class=n>window_original</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
                <span class=n>result_matrix</span> <span class=o>=</span> <span class=n>result_matrix</span><span class=p>[</span><span class=n>mask</span><span class=p>,</span> <span class=p>:,</span> <span class=p>:]</span>
                <span class=n>t</span> <span class=o>=</span> <span class=n>t</span><span class=p>[</span><span class=n>mask</span><span class=p>]</span>

            <span class=k>return</span> <span class=n>result_matrix</span><span class=p>,</span> <span class=n>t</span>

    <span class=c1># If window was not symmetric, remove the extra bins (only for averaged DataFrame)</span>
    <span class=k>if</span> <span class=n>average</span> <span class=ow>and</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>window_original</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>peth_df</span> <span class=o>=</span> <span class=n>peth_df</span><span class=o>.</span><span class=n>loc</span><span class=p>[</span><span class=n>window_original</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>:</span> <span class=n>window_original</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=p>:]</span>

    <span class=k>return</span> <span class=n>peth_df</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.peth_matrix class="doc doc-heading"> <code class="highlight language-python"><span class=n>peth_matrix</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Generate a peri-event time histogram (PETH) matrix.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of time values.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_ref</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of reference times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of each bin in the PETH matrix, in seconds. Default is 0.002 seconds.</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins in the PETH matrix. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=tuple>tuple</span></code> </td> <td> <div class=doc-md-description> <p>A tuple containing the start and end times of the window to be plotted around each reference time. If not provided, the window will be centered around each reference time and have a width of <code>n_bins * bin_width</code> seconds. Use a tuple to avoid numba reflected-list warnings.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>H</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array representing the PETH matrix with rates in Hz. Shape is (n_time_bins, n_events).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>t</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of time values corresponding to the bins in the PETH matrix.</p> </div> </td> </tr> </tbody> </table> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>406</span>
<span class=normal>407</span>
<span class=normal>408</span>
<span class=normal>409</span>
<span class=normal>410</span>
<span class=normal>411</span>
<span class=normal>412</span>
<span class=normal>413</span>
<span class=normal>414</span>
<span class=normal>415</span>
<span class=normal>416</span>
<span class=normal>417</span>
<span class=normal>418</span>
<span class=normal>419</span>
<span class=normal>420</span>
<span class=normal>421</span>
<span class=normal>422</span>
<span class=normal>423</span>
<span class=normal>424</span>
<span class=normal>425</span>
<span class=normal>426</span>
<span class=normal>427</span>
<span class=normal>428</span>
<span class=normal>429</span>
<span class=normal>430</span>
<span class=normal>431</span>
<span class=normal>432</span>
<span class=normal>433</span>
<span class=normal>434</span>
<span class=normal>435</span>
<span class=normal>436</span>
<span class=normal>437</span>
<span class=normal>438</span>
<span class=normal>439</span>
<span class=normal>440</span>
<span class=normal>441</span>
<span class=normal>442</span>
<span class=normal>443</span>
<span class=normal>444</span>
<span class=normal>445</span>
<span class=normal>446</span>
<span class=normal>447</span>
<span class=normal>448</span>
<span class=normal>449</span>
<span class=normal>450</span>
<span class=normal>451</span>
<span class=normal>452</span>
<span class=normal>453</span>
<span class=normal>454</span>
<span class=normal>455</span>
<span class=normal>456</span>
<span class=normal>457</span>
<span class=normal>458</span>
<span class=normal>459</span>
<span class=normal>460</span>
<span class=normal>461</span>
<span class=normal>462</span>
<span class=normal>463</span>
<span class=normal>464</span>
<span class=normal>465</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>parallel</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>peth_matrix</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>time_ref</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>],</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Generate a peri-event time histogram (PETH) matrix.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : ndarray</span>
<span class=sd>        A 1D array of time values.</span>
<span class=sd>    time_ref : ndarray</span>
<span class=sd>        A 1D array of reference times.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        The width of each bin in the PETH matrix, in seconds. Default is 0.002 seconds.</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        The number of bins in the PETH matrix. Default is 100.</span>
<span class=sd>    window : tuple, optional</span>
<span class=sd>        A tuple containing the start and end times of the window to be plotted around each reference time.</span>
<span class=sd>        If not provided, the window will be centered around each reference time and have a width of `n_bins * bin_width` seconds.</span>
<span class=sd>        Use a tuple to avoid numba reflected-list warnings.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    H : ndarray</span>
<span class=sd>        A 2D array representing the PETH matrix with rates in Hz.</span>
<span class=sd>        Shape is (n_time_bins, n_events).</span>
<span class=sd>    t : ndarray</span>
<span class=sd>        A 1D array of time values corresponding to the bins in the PETH matrix.</span>

<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
        <span class=c1># Compute n_bins from window-based times</span>
        <span class=n>n_bins</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
        <span class=c1># Ensure n_bins is odd, same way crossCorr does it</span>
        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>floor</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>==</span> <span class=n>n_bins</span><span class=p>:</span>
            <span class=n>n_bins</span> <span class=o>=</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=c1># Ensure n_bins is odd before computing times (crossCorr expects odd)</span>
        <span class=n>n_bins</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>n_bins</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>floor</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>==</span> <span class=n>n_bins</span><span class=p>:</span>
            <span class=n>n_bins</span> <span class=o>=</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>

        <span class=n>times</span> <span class=o>=</span> <span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>bin_width</span> <span class=o>*</span> <span class=n>n_bins</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
            <span class=o>-</span> <span class=p>(</span><span class=n>bin_width</span> <span class=o>*</span> <span class=n>n_bins</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
            <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span>
        <span class=p>)</span>

    <span class=n>H</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_ref</span><span class=p>)))</span>

    <span class=k>for</span> <span class=n>event_i</span> <span class=ow>in</span> <span class=n>prange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>time_ref</span><span class=p>)):</span>
        <span class=n>H</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>([</span><span class=n>time_ref</span><span class=p>[</span><span class=n>event_i</span><span class=p>]],</span> <span class=n>data</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>H</span><span class=p>,</span> <span class=n>times</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.relative_times class="doc doc-heading"> <code class="highlight language-python"><span class=n>relative_times</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>intervals</span><span class=p>,</span> <span class=n>values</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]))</span></code> </h2> <div class="doc doc-contents "> <p>Calculate relative times and interval IDs for a set of time points.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>t</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time points.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>intervals</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time intervals, represented as pairs of start and end times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>values</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of values to assign to interval bounds. The default is [0,1].</p> </div> </td> <td> <code><span title=numpy.array>array</span>([0, 1])</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>rt</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of relative times, one for each time point (same len as t).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>intervalID</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of interval IDs, one for each time point (same len as t).</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>t</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span> <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>9</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>relative_times</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>intervals</span><span class=p>)</span>
<span class=go>    (array([nan, 0. , 0.5, 1. , 0. , 0.5, 1. , 0. , 0.5, 1. ]),</span>
<span class=go>    array([nan,  0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.]))</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>t</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span> <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>9</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>values</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=o>*</span><span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>relative_times</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>intervals</span><span class=p>,</span> <span class=n>values</span><span class=p>)</span>
<span class=go>    (array([       nan, 0.        , 3.14159265, 6.28318531, 0.        ,</span>
<span class=go>            3.14159265, 6.28318531, 0.        , 3.14159265, 6.28318531]),</span>
<span class=go>    array([nan,  0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.]))</span>
</code></pre></div> <details class=note open> <summary>Notes</summary> <p>Intervals are defined as pairs of start and end times. The relative time is the time within the interval, normalized to the interval duration. The interval ID is the index of the interval in the intervals array. The values array can be used to assign a value to each interval.</p> <p>By Ryan H, based on RelativeTimes.m by Ralitsa Todorova</p> </details> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1632</span>
<span class=normal>1633</span>
<span class=normal>1634</span>
<span class=normal>1635</span>
<span class=normal>1636</span>
<span class=normal>1637</span>
<span class=normal>1638</span>
<span class=normal>1639</span>
<span class=normal>1640</span>
<span class=normal>1641</span>
<span class=normal>1642</span>
<span class=normal>1643</span>
<span class=normal>1644</span>
<span class=normal>1645</span>
<span class=normal>1646</span>
<span class=normal>1647</span>
<span class=normal>1648</span>
<span class=normal>1649</span>
<span class=normal>1650</span>
<span class=normal>1651</span>
<span class=normal>1652</span>
<span class=normal>1653</span>
<span class=normal>1654</span>
<span class=normal>1655</span>
<span class=normal>1656</span>
<span class=normal>1657</span>
<span class=normal>1658</span>
<span class=normal>1659</span>
<span class=normal>1660</span>
<span class=normal>1661</span>
<span class=normal>1662</span>
<span class=normal>1663</span>
<span class=normal>1664</span>
<span class=normal>1665</span>
<span class=normal>1666</span>
<span class=normal>1667</span>
<span class=normal>1668</span>
<span class=normal>1669</span>
<span class=normal>1670</span>
<span class=normal>1671</span>
<span class=normal>1672</span>
<span class=normal>1673</span>
<span class=normal>1674</span>
<span class=normal>1675</span>
<span class=normal>1676</span>
<span class=normal>1677</span>
<span class=normal>1678</span>
<span class=normal>1679</span>
<span class=normal>1680</span>
<span class=normal>1681</span>
<span class=normal>1682</span>
<span class=normal>1683</span>
<span class=normal>1684</span>
<span class=normal>1685</span>
<span class=normal>1686</span>
<span class=normal>1687</span>
<span class=normal>1688</span>
<span class=normal>1689</span>
<span class=normal>1690</span>
<span class=normal>1691</span>
<span class=normal>1692</span>
<span class=normal>1693</span>
<span class=normal>1694</span>
<span class=normal>1695</span>
<span class=normal>1696</span>
<span class=normal>1697</span>
<span class=normal>1698</span>
<span class=normal>1699</span>
<span class=normal>1700</span>
<span class=normal>1701</span>
<span class=normal>1702</span>
<span class=normal>1703</span>
<span class=normal>1704</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>relative_times</span><span class=p>(</span>
    <span class=n>t</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>intervals</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>values</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Calculate relative times and interval IDs for a set of time points.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    t : np.ndarray</span>
<span class=sd>        An array of time points.</span>
<span class=sd>    intervals : np.ndarray</span>
<span class=sd>        An array of time intervals, represented as pairs of start and end times.</span>
<span class=sd>    values : np.ndarray, optional</span>
<span class=sd>        An array of values to assign to interval bounds. The default is [0,1].</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    rt : np.ndarray</span>
<span class=sd>        An array of relative times, one for each time point (same len as t).</span>
<span class=sd>    intervalID : np.ndarray</span>
<span class=sd>        An array of interval IDs, one for each time point (same len as t).</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; t = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class=sd>    &gt;&gt;&gt; intervals = np.array([[1, 3], [4, 6], [7, 9]])</span>
<span class=sd>    &gt;&gt;&gt; relative_times(t, intervals)</span>
<span class=sd>        (array([nan, 0. , 0.5, 1. , 0. , 0.5, 1. , 0. , 0.5, 1. ]),</span>
<span class=sd>        array([nan,  0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.]))</span>

<span class=sd>    &gt;&gt;&gt; t = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class=sd>    &gt;&gt;&gt; intervals = np.array([[1, 3], [4, 6], [7, 9]])</span>
<span class=sd>    &gt;&gt;&gt; values = np.array([0, 2*np.pi])</span>
<span class=sd>    &gt;&gt;&gt; relative_times(t, intervals, values)</span>
<span class=sd>        (array([       nan, 0.        , 3.14159265, 6.28318531, 0.        ,</span>
<span class=sd>                3.14159265, 6.28318531, 0.        , 3.14159265, 6.28318531]),</span>
<span class=sd>        array([nan,  0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.]))</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Intervals are defined as pairs of start and end times. The relative time is the time</span>
<span class=sd>    within the interval, normalized to the interval duration. The interval ID is the index</span>
<span class=sd>    of the interval in the intervals array. The values array can be used to assign a value</span>
<span class=sd>    to each interval.</span>

<span class=sd>    By Ryan H, based on RelativeTimes.m by Ralitsa Todorova</span>

<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>rt</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
    <span class=n>intervalID</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>

    <span class=n>start_times</span> <span class=o>=</span> <span class=n>intervals</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span>
    <span class=n>end_times</span> <span class=o>=</span> <span class=n>intervals</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>]</span>
    <span class=n>values_diff</span> <span class=o>=</span> <span class=n>values</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>values</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>intervals_diff</span> <span class=o>=</span> <span class=n>end_times</span> <span class=o>-</span> <span class=n>start_times</span>
    <span class=n>intervals_scale</span> <span class=o>=</span> <span class=n>values_diff</span> <span class=o>/</span> <span class=n>intervals_diff</span>

    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>)):</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>start_times</span><span class=p>,</span> <span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
        <span class=k>if</span> <span class=n>idx</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>end_times</span><span class=p>[</span><span class=n>idx</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]:</span>
            <span class=n>interval_i</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>-</span> <span class=mi>1</span>
        <span class=k>elif</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>start_times</span><span class=p>)</span> <span class=ow>and</span> <span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>start_times</span><span class=p>[</span><span class=n>idx</span><span class=p>]:</span>
            <span class=n>interval_i</span> <span class=o>=</span> <span class=n>idx</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>continue</span>

        <span class=n>scale</span> <span class=o>=</span> <span class=n>intervals_scale</span><span class=p>[</span><span class=n>interval_i</span><span class=p>]</span>
        <span class=n>rt</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>start_times</span><span class=p>[</span><span class=n>interval_i</span><span class=p>])</span> <span class=o>*</span> <span class=n>scale</span><span class=p>)</span> <span class=o>+</span> <span class=n>values</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=n>intervalID</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>interval_i</span>

    <span class=k>return</span> <span class=n>rt</span><span class=p>,</span> <span class=n>intervalID</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peri_event.sync class="doc doc-heading"> <code class="highlight language-python"><span class=n>sync</span><span class=p>(</span><span class=n>samples</span><span class=p>,</span> <span class=n>sync_times</span><span class=p>,</span> <span class=n>durations</span><span class=o>=</span><span class=p>(</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>),</span> <span class=n>fast</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Synchronize sample timestamps to reference events.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>samples</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Sample array with timestamps in the first column. Can be shape (n_samples,) or (n_samples, n_features). Assumed to be sorted by default.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>sync_times</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of synchronizing event times. Assumed to be sorted by default.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>durations</code> </td> <td> <code>tuple of float</code> </td> <td> <div class=doc-md-description> <p>Time window around each event as (start, stop), in seconds. Defaults to (-0.5, 0.5).</p> </div> </td> <td> <code>(-0.5, 0.5)</code> </td> </tr> <tr class=doc-section-item> <td> <code>fast</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, assumes <code>samples</code> and <code>sync_times</code> are already sorted and skips sorting. If False, sorts the inputs (slower but handles unsorted data). Defaults to True.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>synchronized</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Samples that fall within event windows, with first column replaced by time relative to event.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>Ie</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Event indices for each synchronized sample, referencing the original <code>sync_times</code> order (0-based indices).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>Is</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Sample indices for each synchronized sample, referencing the original <code>samples</code> order (0-based indices).</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>By default, this function assumes both <code>samples</code> and <code>sync_times</code> are sorted in ascending order for maximum performance. If your data is unsorted, set <code>fast=False</code> to enable automatic sorting (with index remapping).</p> <p>Similar to get_raster_points but returns the synchronized samples in a single array and also returns the indices of the events and samples that correspond to each synchronized sample. Also is much faster than get_raster_points.</p> </details> <details class=references open> <summary>References</summary> <ul> <li>Original MATLAB implementation: Sync.m from FMAToolbox</li> </ul> </details> <p><span class=doc-section-title>Examples:</span></p> <p>Basic usage with 1D timestamps:</p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>samples</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.9</span><span class=p>,</span> <span class=mf>1.1</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>2.1</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>sync_times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>synchronized</span><span class=p>,</span> <span class=n>Ie</span><span class=p>,</span> <span class=n>Is</span> <span class=o>=</span> <span class=n>sync</span><span class=p>(</span><span class=n>samples</span><span class=p>,</span> <span class=n>sync_times</span><span class=p>,</span> <span class=n>durations</span><span class=o>=</span><span class=p>(</span><span class=o>-</span><span class=mf>0.15</span><span class=p>,</span> <span class=mf>0.15</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>synchronized</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span>
<span class=go>array([-0.1,  0.1,  0. ,  0.1])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Ie</span>
<span class=go>array([0, 0, 1, 1])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Is</span>
<span class=go>array([0, 1, 2, 3])</span>
</code></pre></div> <p>Usage with unsorted samples and extra columns:</p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>samples</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>2.0</span><span class=p>,</span> <span class=mf>20.0</span><span class=p>],</span> <span class=p>[</span><span class=mf>0.9</span><span class=p>,</span> <span class=mf>9.0</span><span class=p>],</span> <span class=p>[</span><span class=mf>1.1</span><span class=p>,</span> <span class=mf>11.0</span><span class=p>],</span> <span class=p>[</span><span class=mf>2.1</span><span class=p>,</span> <span class=mf>21.0</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>sync_times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>2.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>synchronized</span><span class=p>,</span> <span class=n>Ie</span><span class=p>,</span> <span class=n>Is</span> <span class=o>=</span> <span class=n>sync</span><span class=p>(</span><span class=n>samples</span><span class=p>,</span> <span class=n>sync_times</span><span class=p>,</span> <span class=n>durations</span><span class=o>=</span><span class=p>(</span><span class=o>-</span><span class=mf>0.15</span><span class=p>,</span> <span class=mf>0.15</span><span class=p>),</span> <span class=n>fast</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>synchronized</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span>
<span class=go>array([-0.1,  0.1,  0. ,  0.1])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Ie</span>  <span class=c1># indices into original sync_times</span>
<span class=go>array([1, 1, 0, 0])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Is</span>  <span class=c1># indices into original samples</span>
<span class=go>array([1, 2, 0, 3])</span>
</code></pre></div> <p>Real-world example with spike times and ripple events:</p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>basepath</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;U:\data\hpc_ctx_project\HP17\hp17_day48_20250603&quot;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>cm</span> <span class=o>=</span> <span class=n>npy</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>brainRegion</span><span class=o>=</span><span class=s2>&quot;CA1&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>ripples</span> <span class=o>=</span> <span class=n>npy</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>load_ripples_events</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>sleep_states</span> <span class=o>=</span> <span class=n>npy</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>load_SleepState_states</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>nrem</span> <span class=o>=</span> <span class=n>sleep_states</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;NREMstate&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>synchronized</span><span class=p>,</span> <span class=n>Ie</span><span class=p>,</span> <span class=n>Is</span> <span class=o>=</span> <span class=n>npy</span><span class=o>.</span><span class=n>process</span><span class=o>.</span><span class=n>sync</span><span class=p>(</span>
<span class=gp>... </span>    <span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>ripples</span><span class=p>[</span><span class=n>nrem</span><span class=p>]</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>durations</span><span class=o>=</span><span class=p>(</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>)</span>
<span class=gp>... </span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>synchronized</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>Ie</span><span class=p>,</span> <span class=n>s</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>alpha</span><span class=o>=</span><span class=mf>0.2</span><span class=p>,</span> <span class=n>marker</span><span class=o>=</span><span class=s2>&quot;|&quot;</span><span class=p>,</span> <span class=n>color</span><span class=o>=</span><span class=s2>&quot;k&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>axvline</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>color</span><span class=o>=</span><span class=s2>&quot;r&quot;</span><span class=p>,</span> <span class=n>ls</span><span class=o>=</span><span class=s2>&quot;--&quot;</span><span class=p>,</span> <span class=n>lw</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s2>&quot;Time from event (s)&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>ylabel</span><span class=p>(</span><span class=s2>&quot;Event #&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=s2>&quot;Event-aligned raster&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>xlim</span><span class=p>(</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>ylim</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>Ie</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</code></pre></div> <details class=mkdocstrings-source> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>556</span>
<span class=normal>557</span>
<span class=normal>558</span>
<span class=normal>559</span>
<span class=normal>560</span>
<span class=normal>561</span>
<span class=normal>562</span>
<span class=normal>563</span>
<span class=normal>564</span>
<span class=normal>565</span>
<span class=normal>566</span>
<span class=normal>567</span>
<span class=normal>568</span>
<span class=normal>569</span>
<span class=normal>570</span>
<span class=normal>571</span>
<span class=normal>572</span>
<span class=normal>573</span>
<span class=normal>574</span>
<span class=normal>575</span>
<span class=normal>576</span>
<span class=normal>577</span>
<span class=normal>578</span>
<span class=normal>579</span>
<span class=normal>580</span>
<span class=normal>581</span>
<span class=normal>582</span>
<span class=normal>583</span>
<span class=normal>584</span>
<span class=normal>585</span>
<span class=normal>586</span>
<span class=normal>587</span>
<span class=normal>588</span>
<span class=normal>589</span>
<span class=normal>590</span>
<span class=normal>591</span>
<span class=normal>592</span>
<span class=normal>593</span>
<span class=normal>594</span>
<span class=normal>595</span>
<span class=normal>596</span>
<span class=normal>597</span>
<span class=normal>598</span>
<span class=normal>599</span>
<span class=normal>600</span>
<span class=normal>601</span>
<span class=normal>602</span>
<span class=normal>603</span>
<span class=normal>604</span>
<span class=normal>605</span>
<span class=normal>606</span>
<span class=normal>607</span>
<span class=normal>608</span>
<span class=normal>609</span>
<span class=normal>610</span>
<span class=normal>611</span>
<span class=normal>612</span>
<span class=normal>613</span>
<span class=normal>614</span>
<span class=normal>615</span>
<span class=normal>616</span>
<span class=normal>617</span>
<span class=normal>618</span>
<span class=normal>619</span>
<span class=normal>620</span>
<span class=normal>621</span>
<span class=normal>622</span>
<span class=normal>623</span>
<span class=normal>624</span>
<span class=normal>625</span>
<span class=normal>626</span>
<span class=normal>627</span>
<span class=normal>628</span>
<span class=normal>629</span>
<span class=normal>630</span>
<span class=normal>631</span>
<span class=normal>632</span>
<span class=normal>633</span>
<span class=normal>634</span>
<span class=normal>635</span>
<span class=normal>636</span>
<span class=normal>637</span>
<span class=normal>638</span>
<span class=normal>639</span>
<span class=normal>640</span>
<span class=normal>641</span>
<span class=normal>642</span>
<span class=normal>643</span>
<span class=normal>644</span>
<span class=normal>645</span>
<span class=normal>646</span>
<span class=normal>647</span>
<span class=normal>648</span>
<span class=normal>649</span>
<span class=normal>650</span>
<span class=normal>651</span>
<span class=normal>652</span>
<span class=normal>653</span>
<span class=normal>654</span>
<span class=normal>655</span>
<span class=normal>656</span>
<span class=normal>657</span>
<span class=normal>658</span>
<span class=normal>659</span>
<span class=normal>660</span>
<span class=normal>661</span>
<span class=normal>662</span>
<span class=normal>663</span>
<span class=normal>664</span>
<span class=normal>665</span>
<span class=normal>666</span>
<span class=normal>667</span>
<span class=normal>668</span>
<span class=normal>669</span>
<span class=normal>670</span>
<span class=normal>671</span>
<span class=normal>672</span>
<span class=normal>673</span>
<span class=normal>674</span>
<span class=normal>675</span>
<span class=normal>676</span>
<span class=normal>677</span>
<span class=normal>678</span>
<span class=normal>679</span>
<span class=normal>680</span>
<span class=normal>681</span>
<span class=normal>682</span>
<span class=normal>683</span>
<span class=normal>684</span>
<span class=normal>685</span>
<span class=normal>686</span>
<span class=normal>687</span>
<span class=normal>688</span>
<span class=normal>689</span>
<span class=normal>690</span>
<span class=normal>691</span>
<span class=normal>692</span>
<span class=normal>693</span>
<span class=normal>694</span>
<span class=normal>695</span>
<span class=normal>696</span>
<span class=normal>697</span>
<span class=normal>698</span>
<span class=normal>699</span>
<span class=normal>700</span>
<span class=normal>701</span>
<span class=normal>702</span>
<span class=normal>703</span>
<span class=normal>704</span>
<span class=normal>705</span>
<span class=normal>706</span>
<span class=normal>707</span>
<span class=normal>708</span>
<span class=normal>709</span>
<span class=normal>710</span>
<span class=normal>711</span>
<span class=normal>712</span>
<span class=normal>713</span>
<span class=normal>714</span>
<span class=normal>715</span>
<span class=normal>716</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>sync</span><span class=p>(</span>
    <span class=n>samples</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>sync_times</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>durations</span><span class=p>:</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>),</span>
    <span class=n>fast</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Synchronize sample timestamps to reference events.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    samples : np.ndarray</span>
<span class=sd>        Sample array with timestamps in the first column. Can be shape (n_samples,)</span>
<span class=sd>        or (n_samples, n_features). Assumed to be sorted by default.</span>
<span class=sd>    sync_times : np.ndarray</span>
<span class=sd>        1D array of synchronizing event times. Assumed to be sorted by default.</span>
<span class=sd>    durations : tuple of float, optional</span>
<span class=sd>        Time window around each event as (start, stop), in seconds.</span>
<span class=sd>        Defaults to (-0.5, 0.5).</span>
<span class=sd>    fast : bool, optional</span>
<span class=sd>        If True, assumes `samples` and `sync_times` are already sorted and skips sorting.</span>
<span class=sd>        If False, sorts the inputs (slower but handles unsorted data).</span>
<span class=sd>        Defaults to True.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    synchronized : np.ndarray</span>
<span class=sd>        Samples that fall within event windows, with first column replaced by</span>
<span class=sd>        time relative to event.</span>
<span class=sd>    Ie : np.ndarray</span>
<span class=sd>        Event indices for each synchronized sample, referencing the original</span>
<span class=sd>        `sync_times` order (0-based indices).</span>
<span class=sd>    Is : np.ndarray</span>
<span class=sd>        Sample indices for each synchronized sample, referencing the original</span>
<span class=sd>        `samples` order (0-based indices).</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    By default, this function assumes both `samples` and `sync_times` are sorted</span>
<span class=sd>    in ascending order for maximum performance. If your data is unsorted, set</span>
<span class=sd>    `fast=False` to enable automatic sorting (with index remapping).</span>

<span class=sd>    Similar to get_raster_points but returns the synchronized samples in a</span>
<span class=sd>    single array and also returns the indices of the events and samples that</span>
<span class=sd>    correspond to each synchronized sample. Also is much faster than get_raster_points.</span>


<span class=sd>    References</span>
<span class=sd>    ----------</span>
<span class=sd>    - Original MATLAB implementation: Sync.m from FMAToolbox</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    Basic usage with 1D timestamps:</span>

<span class=sd>    &gt;&gt;&gt; samples = np.array([0.9, 1.1, 2.0, 2.1, 3.0])</span>
<span class=sd>    &gt;&gt;&gt; sync_times = np.array([1.0, 2.0])</span>
<span class=sd>    &gt;&gt;&gt; synchronized, Ie, Is = sync(samples, sync_times, durations=(-0.15, 0.15))</span>
<span class=sd>    &gt;&gt;&gt; synchronized[:, 0]</span>
<span class=sd>    array([-0.1,  0.1,  0. ,  0.1])</span>
<span class=sd>    &gt;&gt;&gt; Ie</span>
<span class=sd>    array([0, 0, 1, 1])</span>
<span class=sd>    &gt;&gt;&gt; Is</span>
<span class=sd>    array([0, 1, 2, 3])</span>

<span class=sd>    Usage with unsorted samples and extra columns:</span>

<span class=sd>    &gt;&gt;&gt; samples = np.array([[2.0, 20.0], [0.9, 9.0], [1.1, 11.0], [2.1, 21.0]])</span>
<span class=sd>    &gt;&gt;&gt; sync_times = np.array([2.0, 1.0])</span>
<span class=sd>    &gt;&gt;&gt; synchronized, Ie, Is = sync(samples, sync_times, durations=(-0.15, 0.15), fast=False)</span>
<span class=sd>    &gt;&gt;&gt; synchronized[:, 0]</span>
<span class=sd>    array([-0.1,  0.1,  0. ,  0.1])</span>
<span class=sd>    &gt;&gt;&gt; Ie  # indices into original sync_times</span>
<span class=sd>    array([1, 1, 0, 0])</span>
<span class=sd>    &gt;&gt;&gt; Is  # indices into original samples</span>
<span class=sd>    array([1, 2, 0, 3])</span>

<span class=sd>    Real-world example with spike times and ripple events:</span>

<span class=sd>    &gt;&gt;&gt; basepath = r&quot;U:\data\hpc_ctx_project\HP17\hp17_day48_20250603&quot;</span>
<span class=sd>    &gt;&gt;&gt; st, cm = npy.io.load_spikes(basepath, brainRegion=&quot;CA1&quot;)</span>
<span class=sd>    &gt;&gt;&gt; ripples = npy.io.load_ripples_events(basepath, return_epoch_array=True)</span>
<span class=sd>    &gt;&gt;&gt; sleep_states = npy.io.load_SleepState_states(basepath, return_epoch_array=True)</span>
<span class=sd>    &gt;&gt;&gt; nrem = sleep_states.get(&quot;NREMstate&quot;)</span>
<span class=sd>    &gt;&gt;&gt; synchronized, Ie, Is = npy.process.sync(</span>
<span class=sd>    ...     st.data[1], ripples[nrem].starts, durations=(-0.5, 0.5)</span>
<span class=sd>    ... )</span>

<span class=sd>    &gt;&gt;&gt; plt.figure(figsize=(6, 4))</span>
<span class=sd>    &gt;&gt;&gt; plt.scatter(synchronized[:, 0], Ie, s=4, alpha=0.2, marker=&quot;|&quot;, color=&quot;k&quot;)</span>
<span class=sd>    &gt;&gt;&gt; plt.axvline(0, color=&quot;r&quot;, ls=&quot;--&quot;, lw=2)</span>
<span class=sd>    &gt;&gt;&gt; plt.xlabel(&quot;Time from event (s)&quot;)</span>
<span class=sd>    &gt;&gt;&gt; plt.ylabel(&quot;Event #&quot;)</span>
<span class=sd>    &gt;&gt;&gt; plt.title(&quot;Event-aligned raster&quot;)</span>
<span class=sd>    &gt;&gt;&gt; plt.xlim(-0.5, 0.5)</span>
<span class=sd>    &gt;&gt;&gt; plt.ylim(0, np.max(Ie) + 1)</span>
<span class=sd>    &gt;&gt;&gt; plt.show()</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>samples</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>samples</span><span class=p>)</span>
    <span class=n>sync_times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>sync_times</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>samples</span><span class=o>.</span><span class=n>ndim</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
        <span class=n>samples</span> <span class=o>=</span> <span class=n>samples</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>samples</span><span class=o>.</span><span class=n>ndim</span> <span class=o>!=</span> <span class=mi>2</span> <span class=ow>or</span> <span class=n>samples</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;&#39;samples&#39; must be a 1D array or a 2D array with timestamps in column 0&quot;</span>
        <span class=p>)</span>
    <span class=k>if</span> <span class=n>sync_times</span><span class=o>.</span><span class=n>ndim</span> <span class=o>==</span> <span class=mi>2</span> <span class=ow>and</span> <span class=n>sync_times</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
        <span class=n>sync_times</span> <span class=o>=</span> <span class=n>sync_times</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>sync_times</span><span class=o>.</span><span class=n>ndim</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;&#39;sync_times&#39; must be a 1D array or a 2D column vector&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>durations</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>2</span> <span class=ow>or</span> <span class=n>durations</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>durations</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;&#39;durations&#39; must be (start, stop) with start &lt;= stop&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>sync_times</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>samples</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=n>samples</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>])),</span>
            <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>),</span>
            <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>),</span>
        <span class=p>)</span>

    <span class=n>sort_samples</span> <span class=o>=</span> <span class=kc>None</span>
    <span class=n>sort_sync</span> <span class=o>=</span> <span class=kc>None</span>

    <span class=n>work_samples</span> <span class=o>=</span> <span class=n>samples</span>
    <span class=n>work_sync</span> <span class=o>=</span> <span class=n>sync_times</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>fast</span><span class=p>:</span>
        <span class=n>sort_samples</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>samples</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>kind</span><span class=o>=</span><span class=s2>&quot;mergesort&quot;</span><span class=p>)</span>
        <span class=n>work_samples</span> <span class=o>=</span> <span class=n>samples</span><span class=p>[</span><span class=n>sort_samples</span><span class=p>]</span>

        <span class=n>sort_sync</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>sync_times</span><span class=p>,</span> <span class=n>kind</span><span class=o>=</span><span class=s2>&quot;mergesort&quot;</span><span class=p>)</span>
        <span class=n>work_sync</span> <span class=o>=</span> <span class=n>sync_times</span><span class=p>[</span><span class=n>sort_sync</span><span class=p>]</span>

    <span class=n>sample_times</span> <span class=o>=</span> <span class=n>work_samples</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span>

    <span class=c1># Use numba-compiled functions for the core sweep and index filling</span>
    <span class=n>starts</span><span class=p>,</span> <span class=n>stops</span><span class=p>,</span> <span class=n>events_with_hits</span><span class=p>,</span> <span class=n>total_hits</span> <span class=o>=</span> <span class=n>_sync_find_windows</span><span class=p>(</span>
        <span class=n>sample_times</span><span class=p>,</span> <span class=n>work_sync</span><span class=p>,</span> <span class=n>durations</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>durations</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=p>)</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>starts</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=n>samples</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>])),</span>
            <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>),</span>
            <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([],</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>int</span><span class=p>),</span>
        <span class=p>)</span>

    <span class=n>Is</span><span class=p>,</span> <span class=n>Ie</span> <span class=o>=</span> <span class=n>_sync_fill_indices</span><span class=p>(</span><span class=n>starts</span><span class=p>,</span> <span class=n>stops</span><span class=p>,</span> <span class=n>events_with_hits</span><span class=p>,</span> <span class=n>total_hits</span><span class=p>)</span>

    <span class=c1># Ensure synchronized has floating dtype so relative times are preserved</span>
    <span class=c1># If samples were integer, subtraction would silently truncate to integers</span>
    <span class=n>synchronized</span> <span class=o>=</span> <span class=n>work_samples</span><span class=p>[</span><span class=n>Is</span><span class=p>]</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>,</span> <span class=n>copy</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
    <span class=n>synchronized</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>synchronized</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>work_sync</span><span class=p>[</span><span class=n>Ie</span><span class=p>]</span>

    <span class=k>if</span> <span class=n>sort_samples</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>Is</span> <span class=o>=</span> <span class=n>sort_samples</span><span class=p>[</span><span class=n>Is</span><span class=p>]</span>
    <span class=k>if</span> <span class=n>sort_sync</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>Ie</span> <span class=o>=</span> <span class=n>sort_sync</span><span class=p>[</span><span class=n>Ie</span><span class=p>]</span>

    <span class=k>return</span> <span class=n>synchronized</span><span class=p>,</span> <span class=n>Ie</span><span class=p>,</span> <span class=n>Is</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> </div> </div> </div> </article> </div> <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> Back to top </button> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../intervals/ class="md-footer__link md-footer__link--prev" aria-label="Previous:  intervals"> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </div> <div class=md-footer__title> <span class=md-footer__direction> Previous </span> <div class=md-ellipsis> intervals </div> </div> </a> <a href=../precession_utils/ class="md-footer__link md-footer__link--next" aria-label="Next:  precession_utils"> <div class=md-footer__title> <span class=md-footer__direction> Next </span> <div class=md-ellipsis> precession_utils </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <div class=md-progress data-md-component=progress role=progressbar></div> <script id=__config type=application/json>{"annotate": null, "base": "../../../..", "features": ["announce.dismiss", "content.action.edit", "content.action.view", "content.code.annotate", "content.code.copy", "content.tooltips", "content.tabs.link", "navigation.footer", "navigation.indexes", "navigation.instant.prefetch", "navigation.instant.preview", "navigation.instant.progress", "navigation.path", "navigation.sections", "navigation.tabs", "navigation.tabs.sticky", "navigation.top", "navigation.tracking", "search.highlight", "search.suggest", "toc.follow"], "search": "../../../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script> <script src=../../../../assets/javascripts/bundle.79ae519e.min.js></script> </body> </html>