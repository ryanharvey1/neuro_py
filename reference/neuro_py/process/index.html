<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=../plotting/ rel=prev><link href=../raw/ rel=next><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.21"><title>neuro_py.process - neuro_py</title><link rel=stylesheet href=../../../assets/stylesheets/main.2a3383ac.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/_mkdocstrings.css><link rel=stylesheet href=../../../stylesheets/extra.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#neuro_py.process class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=neuro_py class="md-header__button md-logo" aria-label=neuro_py data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> neuro_py </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> neuro_py.process </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=light data-md-color-primary=custom data-md-color-accent=custom aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=indigo data-md-color-accent=blue aria-label="Switch to system preference" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to system preference" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/ryanharvey1/neuro_py title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> ryanharvey1/neuro_py </div> </a> </div> </nav> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../.. class=md-tabs__link> Home </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../ class=md-tabs__link> API Reference </a> </li> <li class=md-tabs__item> <a href=../../../tutorials/attractor_landscape/ class=md-tabs__link> Tutorials </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=neuro_py class="md-nav__button md-logo" aria-label=neuro_py data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> neuro_py </label> <div class=md-nav__source> <a href=https://github.com/ryanharvey1/neuro_py title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> ryanharvey1/neuro_py </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2 checked> <div class="md-nav__link md-nav__container"> <a href=../ class="md-nav__link "> <span class=md-ellipsis> API Reference </span> </a> <label class="md-nav__link " for=__nav_2 id=__nav_2_label tabindex> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=true> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> API Reference </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_2> <label class=md-nav__link for=__nav_2_2 id=__nav_2_2_label tabindex> <span class=md-ellipsis> behavior </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2_2> <span class="md-nav__icon md-icon"></span> behavior </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../behavior/cheeseboard/ class=md-nav__link> <span class=md-ellipsis> cheeseboard </span> </a> </li> <li class=md-nav__item> <a href=../behavior/circle_maze/ class=md-nav__link> <span class=md-ellipsis> circle_maze </span> </a> </li> <li class=md-nav__item> <a href=../behavior/get_trials/ class=md-nav__link> <span class=md-ellipsis> get_trials </span> </a> </li> <li class=md-nav__item> <a href=../behavior/kinematics/ class=md-nav__link> <span class=md-ellipsis> kinematics </span> </a> </li> <li class=md-nav__item> <a href=../behavior/linear_positions/ class=md-nav__link> <span class=md-ellipsis> linear_positions </span> </a> </li> <li class=md-nav__item> <a href=../behavior/linearization/ class=md-nav__link> <span class=md-ellipsis> linearization </span> </a> </li> <li class=md-nav__item> <a href=../behavior/linearization_pipeline/ class=md-nav__link> <span class=md-ellipsis> linearization_pipeline </span> </a> </li> <li class=md-nav__item> <a href=../behavior/preprocessing/ class=md-nav__link> <span class=md-ellipsis> preprocessing </span> </a> </li> <li class=md-nav__item> <a href=../behavior/well_traversal_classification/ class=md-nav__link> <span class=md-ellipsis> well_traversal_classification </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_3> <label class=md-nav__link for=__nav_2_3 id=__nav_2_3_label tabindex> <span class=md-ellipsis> detectors </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_3_label aria-expanded=false> <label class=md-nav__title for=__nav_2_3> <span class="md-nav__icon md-icon"></span> detectors </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../detectors/dentate_spike/ class=md-nav__link> <span class=md-ellipsis> dentate_spike </span> </a> </li> <li class=md-nav__item> <a href=../detectors/up_down_state/ class=md-nav__link> <span class=md-ellipsis> up_down_state </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_4> <div class="md-nav__link md-nav__container"> <a href=../ensemble/decoding/ class="md-nav__link "> <span class=md-ellipsis> ensemble </span> </a> <label class="md-nav__link " for=__nav_2_4 id=__nav_2_4_label tabindex> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_4_label aria-expanded=false> <label class=md-nav__title for=__nav_2_4> <span class="md-nav__icon md-icon"></span> ensemble </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../ensemble/assembly/ class=md-nav__link> <span class=md-ellipsis> assembly </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/assembly_reactivation/ class=md-nav__link> <span class=md-ellipsis> assembly_reactivation </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/dynamics/ class=md-nav__link> <span class=md-ellipsis> dynamics </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/explained_variance/ class=md-nav__link> <span class=md-ellipsis> explained_variance </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/geometry/ class=md-nav__link> <span class=md-ellipsis> geometry </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/pairwise_bias_correlation/ class=md-nav__link> <span class=md-ellipsis> pairwise_bias_correlation </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/replay/ class=md-nav__link> <span class=md-ellipsis> replay </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/similarity_index/ class=md-nav__link> <span class=md-ellipsis> similarity_index </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/similaritymat/ class=md-nav__link> <span class=md-ellipsis> similaritymat </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_5> <label class=md-nav__link for=__nav_2_5 id=__nav_2_5_label tabindex> <span class=md-ellipsis> decoding </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_5_label aria-expanded=false> <label class=md-nav__title for=__nav_2_5> <span class="md-nav__icon md-icon"></span> decoding </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../ensemble/decoding/bayesian/ class=md-nav__link> <span class=md-ellipsis> bayesian </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/decoding/lstm/ class=md-nav__link> <span class=md-ellipsis> lstm </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/decoding/m2mlstm/ class=md-nav__link> <span class=md-ellipsis> m2mlstm </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/decoding/mlp/ class=md-nav__link> <span class=md-ellipsis> mlp </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/decoding/pipeline/ class=md-nav__link> <span class=md-ellipsis> pipeline </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/decoding/preprocess/ class=md-nav__link> <span class=md-ellipsis> preprocess </span> </a> </li> <li class=md-nav__item> <a href=../ensemble/decoding/transformer/ class=md-nav__link> <span class=md-ellipsis> transformer </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_6> <label class=md-nav__link for=__nav_2_6 id=__nav_2_6_label tabindex> <span class=md-ellipsis> io </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_6_label aria-expanded=false> <label class=md-nav__title for=__nav_2_6> <span class="md-nav__icon md-icon"></span> io </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../io/loading/ class=md-nav__link> <span class=md-ellipsis> loading </span> </a> </li> <li class=md-nav__item> <a href=../io/saving/ class=md-nav__link> <span class=md-ellipsis> saving </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_7> <label class=md-nav__link for=__nav_2_7 id=__nav_2_7_label tabindex> <span class=md-ellipsis> lfp </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_7_label aria-expanded=false> <label class=md-nav__title for=__nav_2_7> <span class="md-nav__icon md-icon"></span> lfp </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../lfp/CSD/ class=md-nav__link> <span class=md-ellipsis> CSD </span> </a> </li> <li class=md-nav__item> <a href=../lfp/preprocessing/ class=md-nav__link> <span class=md-ellipsis> preprocessing </span> </a> </li> <li class=md-nav__item> <a href=../lfp/spectral/ class=md-nav__link> <span class=md-ellipsis> spectral </span> </a> </li> <li class=md-nav__item> <a href=../lfp/theta_cycles/ class=md-nav__link> <span class=md-ellipsis> theta_cycles </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_8> <label class=md-nav__link for=__nav_2_8 id=__nav_2_8_label tabindex> <span class=md-ellipsis> plotting </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_8_label aria-expanded=false> <label class=md-nav__title for=__nav_2_8> <span class="md-nav__icon md-icon"></span> plotting </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../plotting/decorators/ class=md-nav__link> <span class=md-ellipsis> decorators </span> </a> </li> <li class=md-nav__item> <a href=../plotting/events/ class=md-nav__link> <span class=md-ellipsis> events </span> </a> </li> <li class=md-nav__item> <a href=../plotting/figure_helpers/ class=md-nav__link> <span class=md-ellipsis> figure_helpers </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_9> <label class=md-nav__link for=__nav_2_9 id=__nav_2_9_label tabindex> <span class=md-ellipsis> process </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_9_label aria-expanded=false> <label class=md-nav__title for=__nav_2_9> <span class="md-nav__icon md-icon"></span> process </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=batch_analysis/ class=md-nav__link> <span class=md-ellipsis> batch_analysis </span> </a> </li> <li class=md-nav__item> <a href=correlations/ class=md-nav__link> <span class=md-ellipsis> correlations </span> </a> </li> <li class=md-nav__item> <a href=intervals/ class=md-nav__link> <span class=md-ellipsis> intervals </span> </a> </li> <li class=md-nav__item> <a href=peri_event/ class=md-nav__link> <span class=md-ellipsis> peri_event </span> </a> </li> <li class=md-nav__item> <a href=precession_utils/ class=md-nav__link> <span class=md-ellipsis> precession_utils </span> </a> </li> <li class=md-nav__item> <a href=pychronux/ class=md-nav__link> <span class=md-ellipsis> pychronux </span> </a> </li> <li class=md-nav__item> <a href=utils/ class=md-nav__link> <span class=md-ellipsis> utils </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_10> <label class=md-nav__link for=__nav_2_10 id=__nav_2_10_label tabindex> <span class=md-ellipsis> raw </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_10_label aria-expanded=false> <label class=md-nav__title for=__nav_2_10> <span class="md-nav__icon md-icon"></span> raw </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../raw/preprocessing/ class=md-nav__link> <span class=md-ellipsis> preprocessing </span> </a> </li> <li class=md-nav__item> <a href=../raw/spike_sorting/ class=md-nav__link> <span class=md-ellipsis> spike_sorting </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_11> <label class=md-nav__link for=__nav_2_11 id=__nav_2_11_label tabindex> <span class=md-ellipsis> session </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_11_label aria-expanded=false> <label class=md-nav__title for=__nav_2_11> <span class="md-nav__icon md-icon"></span> session </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../session/locate_epochs/ class=md-nav__link> <span class=md-ellipsis> locate_epochs </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_12> <label class=md-nav__link for=__nav_2_12 id=__nav_2_12_label tabindex> <span class=md-ellipsis> spikes </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_12_label aria-expanded=false> <label class=md-nav__title for=__nav_2_12> <span class="md-nav__icon md-icon"></span> spikes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../spikes/spike_tools/ class=md-nav__link> <span class=md-ellipsis> spike_tools </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_13> <label class=md-nav__link for=__nav_2_13 id=__nav_2_13_label tabindex> <span class=md-ellipsis> stats </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_13_label aria-expanded=false> <label class=md-nav__title for=__nav_2_13> <span class="md-nav__icon md-icon"></span> stats </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../stats/circ_stats/ class=md-nav__link> <span class=md-ellipsis> circ_stats </span> </a> </li> <li class=md-nav__item> <a href=../stats/regression/ class=md-nav__link> <span class=md-ellipsis> regression </span> </a> </li> <li class=md-nav__item> <a href=../stats/stats/ class=md-nav__link> <span class=md-ellipsis> stats </span> </a> </li> <li class=md-nav__item> <a href=../stats/system_identifier/ class=md-nav__link> <span class=md-ellipsis> system_identifier </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_14> <label class=md-nav__link for=__nav_2_14 id=__nav_2_14_label tabindex> <span class=md-ellipsis> tuning </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_14_label aria-expanded=false> <label class=md-nav__title for=__nav_2_14> <span class="md-nav__icon md-icon"></span> tuning </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../tuning/fields/ class=md-nav__link> <span class=md-ellipsis> fields </span> </a> </li> <li class=md-nav__item> <a href=../tuning/maps/ class=md-nav__link> <span class=md-ellipsis> maps </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_15> <label class=md-nav__link for=__nav_2_15 id=__nav_2_15_label tabindex> <span class=md-ellipsis> util </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_15_label aria-expanded=false> <label class=md-nav__title for=__nav_2_15> <span class="md-nav__icon md-icon"></span> util </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../util/array/ class=md-nav__link> <span class=md-ellipsis> array </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Tutorials </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Tutorials </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../tutorials/attractor_landscape/ class=md-nav__link> <span class=md-ellipsis> Attractor Estimation </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/batch_analysis/ class=md-nav__link> <span class=md-ellipsis> Batch Analysis </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/bias_correlation/ class=md-nav__link> <span class=md-ellipsis> Bias Correlation </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/explained_variance/ class=md-nav__link> <span class=md-ellipsis> Explained Variance </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/decoding/ class=md-nav__link> <span class=md-ellipsis> Neural Decoding </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/neural_geodynamics/ class=md-nav__link> <span class=md-ellipsis> Neural Geodynamics </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/reactivation/ class=md-nav__link> <span class=md-ellipsis> Reactivation </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/spatial_map/ class=md-nav__link> <span class=md-ellipsis> Spatial Map </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#neuro_py.process class=md-nav__link> <span class=md-ellipsis> process </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.acf_power class=md-nav__link> <span class=md-ellipsis> acf_power </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.average_diagonal class=md-nav__link> <span class=md-ellipsis> average_diagonal </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.circular_shift class=md-nav__link> <span class=md-ellipsis> circular_shift </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.compute_AutoCorrs class=md-nav__link> <span class=md-ellipsis> compute_AutoCorrs </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.compute_cross_correlogram class=md-nav__link> <span class=md-ellipsis> compute_cross_correlogram </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.compute_image_spread class=md-nav__link> <span class=md-ellipsis> compute_image_spread </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.compute_psth class=md-nav__link> <span class=md-ellipsis> compute_psth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.corrcc class=md-nav__link> <span class=md-ellipsis> corrcc </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.corrcc_uniform class=md-nav__link> <span class=md-ellipsis> corrcc_uniform </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.count_events class=md-nav__link> <span class=md-ellipsis> count_events </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.count_in_interval class=md-nav__link> <span class=md-ellipsis> count_in_interval </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.crossCorr class=md-nav__link> <span class=md-ellipsis> crossCorr </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.decode_file_path class=md-nav__link> <span class=md-ellipsis> decode_file_path </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.deconvolve_peth class=md-nav__link> <span class=md-ellipsis> deconvolve_peth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.dpsschk class=md-nav__link> <span class=md-ellipsis> dpsschk </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.encode_file_path class=md-nav__link> <span class=md-ellipsis> encode_file_path </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.event_spiking_threshold class=md-nav__link> <span class=md-ellipsis> event_spiking_threshold </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.event_triggered_average class=md-nav__link> <span class=md-ellipsis> event_triggered_average </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.event_triggered_average_fast class=md-nav__link> <span class=md-ellipsis> event_triggered_average_fast </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.event_triggered_average_irregular_sample class=md-nav__link> <span class=md-ellipsis> event_triggered_average_irregular_sample </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.event_triggered_cross_correlation class=md-nav__link> <span class=md-ellipsis> event_triggered_cross_correlation </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.fast_acf class=md-nav__link> <span class=md-ellipsis> fast_acf </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.find_intersecting_intervals class=md-nav__link> <span class=md-ellipsis> find_intersecting_intervals </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.find_interval class=md-nav__link> <span class=md-ellipsis> find_interval </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.get_rank_order class=md-nav__link> <span class=md-ellipsis> get_rank_order </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.get_raster_points class=md-nav__link> <span class=md-ellipsis> get_raster_points </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.get_tapers class=md-nav__link> <span class=md-ellipsis> get_tapers </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.getfgrid class=md-nav__link> <span class=md-ellipsis> getfgrid </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.in_intervals class=md-nav__link> <span class=md-ellipsis> in_intervals </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.in_intervals_interval class=md-nav__link> <span class=md-ellipsis> in_intervals_interval </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.joint_peth class=md-nav__link> <span class=md-ellipsis> joint_peth </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.load_results class=md-nav__link> <span class=md-ellipsis> load_results </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.mtcoherencept class=md-nav__link> <span class=md-ellipsis> mtcoherencept </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.mtcsdpt class=md-nav__link> <span class=md-ellipsis> mtcsdpt </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.mtfftc class=md-nav__link> <span class=md-ellipsis> mtfftc </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.mtfftpt class=md-nav__link> <span class=md-ellipsis> mtfftpt </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.mtspectrumc class=md-nav__link> <span class=md-ellipsis> mtspectrumc </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.mtspectrumpt class=md-nav__link> <span class=md-ellipsis> mtspectrumpt </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.nearest_event_delay class=md-nav__link> <span class=md-ellipsis> nearest_event_delay </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.nonspatial_phase_precession class=md-nav__link> <span class=md-ellipsis> nonspatial_phase_precession </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.overlap_intersect class=md-nav__link> <span class=md-ellipsis> overlap_intersect </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.pairwise_corr class=md-nav__link> <span class=md-ellipsis> pairwise_corr </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.pairwise_cross_corr class=md-nav__link> <span class=md-ellipsis> pairwise_cross_corr </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.pairwise_event_triggered_cross_correlation class=md-nav__link> <span class=md-ellipsis> pairwise_event_triggered_cross_correlation </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.pairwise_spatial_corr class=md-nav__link> <span class=md-ellipsis> pairwise_spatial_corr </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.peth_matrix class=md-nav__link> <span class=md-ellipsis> peth_matrix </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.point_spectra class=md-nav__link> <span class=md-ellipsis> point_spectra </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.randomize_epochs class=md-nav__link> <span class=md-ellipsis> randomize_epochs </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.relative_times class=md-nav__link> <span class=md-ellipsis> relative_times </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.remove_inactive_cells class=md-nav__link> <span class=md-ellipsis> remove_inactive_cells </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.remove_inactive_cells_pre_task_post class=md-nav__link> <span class=md-ellipsis> remove_inactive_cells_pre_task_post </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.shift_epoch_array class=md-nav__link> <span class=md-ellipsis> shift_epoch_array </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.spatial_phase_precession class=md-nav__link> <span class=md-ellipsis> spatial_phase_precession </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.split_epoch_by_width class=md-nav__link> <span class=md-ellipsis> split_epoch_by_width </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.split_epoch_equal_parts class=md-nav__link> <span class=md-ellipsis> split_epoch_equal_parts </span> </a> </li> <li class=md-nav__item> <a href=#neuro_py.process.truncate_epoch class=md-nav__link> <span class=md-ellipsis> truncate_epoch </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <a href=https://github.com/ryanharvey1/neuro_py/edit/main/docs/neuro_py/process/__init__.py title="Edit this page" class="md-content__button md-icon" rel=edit> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg> </a> <a href=https://github.com/ryanharvey1/neuro_py/raw/main/docs/neuro_py/process/__init__.py title="View source of this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"/></svg> </a> <h1> process</h1> <div class="doc doc-object doc-module"> <a id=neuro_py.process></a> <div class="doc doc-contents first"> <div class="doc doc-children"> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.acf_power class="doc doc-heading"> <code class="highlight language-python"><span class=n>acf_power</span><span class=p>(</span><span class=n>acf</span><span class=p>,</span> <span class=n>norm</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the power spectrum of the signal by calculating the FFT of the autocorrelation function (ACF).</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>acf</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of counts for the ACF.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>norm</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, normalize the power spectrum. Default is True.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>psd</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array representing the power spectrum of the signal.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>The power spectrum is computed by taking the Fourier Transform of the ACF, then squaring the absolute values of the FFT result. The Nyquist frequency is accounted for by returning only the first half of the spectrum.</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/precession_utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>384</span>
<span class=normal>385</span>
<span class=normal>386</span>
<span class=normal>387</span>
<span class=normal>388</span>
<span class=normal>389</span>
<span class=normal>390</span>
<span class=normal>391</span>
<span class=normal>392</span>
<span class=normal>393</span>
<span class=normal>394</span>
<span class=normal>395</span>
<span class=normal>396</span>
<span class=normal>397</span>
<span class=normal>398</span>
<span class=normal>399</span>
<span class=normal>400</span>
<span class=normal>401</span>
<span class=normal>402</span>
<span class=normal>403</span>
<span class=normal>404</span>
<span class=normal>405</span>
<span class=normal>406</span>
<span class=normal>407</span>
<span class=normal>408</span>
<span class=normal>409</span>
<span class=normal>410</span>
<span class=normal>411</span>
<span class=normal>412</span>
<span class=normal>413</span>
<span class=normal>414</span>
<span class=normal>415</span>
<span class=normal>416</span>
<span class=normal>417</span>
<span class=normal>418</span>
<span class=normal>419</span>
<span class=normal>420</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>acf_power</span><span class=p>(</span><span class=n>acf</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>norm</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the power spectrum of the signal by calculating the FFT of the autocorrelation function (ACF).</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    acf : np.ndarray</span>
<span class=sd>        1D array of counts for the ACF.</span>
<span class=sd>    norm : bool, optional</span>
<span class=sd>        If True, normalize the power spectrum. Default is True.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    psd : np.ndarray</span>
<span class=sd>        1D array representing the power spectrum of the signal.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    The power spectrum is computed by taking the Fourier Transform of the ACF,</span>
<span class=sd>    then squaring the absolute values of the FFT result.</span>
<span class=sd>    The Nyquist frequency is accounted for by returning only the first half of the spectrum.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># Take the FFT</span>
    <span class=n>fft</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>fft</span><span class=o>.</span><span class=n>fft</span><span class=p>(</span><span class=n>acf</span><span class=p>)</span>

    <span class=c1># Compute the power spectrum</span>
    <span class=nb>pow</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>fft</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span>

    <span class=c1># Account for Nyquist frequency</span>
    <span class=n>psd</span> <span class=o>=</span> <span class=nb>pow</span><span class=p>[:</span> <span class=nb>pow</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>//</span> <span class=mi>2</span><span class=p>]</span>

    <span class=c1># Normalize if required</span>
    <span class=k>if</span> <span class=n>norm</span><span class=p>:</span>
        <span class=n>psd</span> <span class=o>=</span> <span class=n>psd</span> <span class=o>/</span> <span class=n>np</span><span class=o>.</span><span class=n>trapezoid</span><span class=p>(</span><span class=n>psd</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>psd</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.average_diagonal class="doc doc-heading"> <code class="highlight language-python"><span class=n>average_diagonal</span><span class=p>(</span><span class=n>mat</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Average values over all offset diagonals of a 2D array.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>mat</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>2D array from which to compute the average values over diagonals.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>output</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array containing the average values over all offset diagonals.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>The method used for computing averages is based on the concept of accumulating values along each diagonal offset and then dividing by the number of elements in each diagonal.</p> </details> <details class=reference open> <summary>Reference</summary> <p>https://stackoverflow.com/questions/71362928/average-values-over-all-offset-diagonals</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 91</span>
<span class=normal> 92</span>
<span class=normal> 93</span>
<span class=normal> 94</span>
<span class=normal> 95</span>
<span class=normal> 96</span>
<span class=normal> 97</span>
<span class=normal> 98</span>
<span class=normal> 99</span>
<span class=normal>100</span>
<span class=normal>101</span>
<span class=normal>102</span>
<span class=normal>103</span>
<span class=normal>104</span>
<span class=normal>105</span>
<span class=normal>106</span>
<span class=normal>107</span>
<span class=normal>108</span>
<span class=normal>109</span>
<span class=normal>110</span>
<span class=normal>111</span>
<span class=normal>112</span>
<span class=normal>113</span>
<span class=normal>114</span>
<span class=normal>115</span>
<span class=normal>116</span>
<span class=normal>117</span>
<span class=normal>118</span>
<span class=normal>119</span>
<span class=normal>120</span>
<span class=normal>121</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>average_diagonal</span><span class=p>(</span><span class=n>mat</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Average values over all offset diagonals of a 2D array.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    mat : np.ndarray</span>
<span class=sd>        2D array from which to compute the average values over diagonals.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    output : np.ndarray</span>
<span class=sd>        1D array containing the average values over all offset diagonals.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    The method used for computing averages is based on the concept of</span>
<span class=sd>    accumulating values along each diagonal offset and then dividing by</span>
<span class=sd>    the number of elements in each diagonal.</span>

<span class=sd>    Reference</span>
<span class=sd>    ---------</span>
<span class=sd>    https://stackoverflow.com/questions/71362928/average-values-over-all-offset-diagonals</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>n</span> <span class=o>=</span> <span class=n>mat</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>output</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=n>n</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
        <span class=n>output</span><span class=p>[</span><span class=n>i</span> <span class=p>:</span> <span class=n>i</span> <span class=o>+</span> <span class=n>n</span><span class=p>]</span> <span class=o>+=</span> <span class=n>mat</span><span class=p>[</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>i</span><span class=p>]</span>
    <span class=n>output</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=n>n</span><span class=p>]</span> <span class=o>/=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>
    <span class=n>output</span><span class=p>[</span><span class=n>n</span><span class=p>:]</span> <span class=o>/=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>output</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.circular_shift class="doc doc-heading"> <code class="highlight language-python"><span class=n>circular_shift</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Circularly shift matrix rows or columns by specified amounts.</p> <p>Each matrix row (or column) is circularly shifted by a different amount.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>m</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Matrix to rotate. Should be a 2D array.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>s</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Shift amounts for each row (horizontal vector) or column (vertical vector). Should be a 1D array.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>shifted</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Matrix <code>m</code> with rows (or columns) circularly shifted by the amounts in <code>s</code>.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Raises:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=ValueError>ValueError</span></code> </td> <td> <div class=doc-md-description> <p>If <code>s</code> is not a vector of integers or if <code>m</code> is not a 2D matrix. If the sizes of <code>m</code> and <code>s</code> are incompatible.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>This function is adapted from CircularShift.m, Copyright (C) 2012 by Michaël Zugaro.</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span>
<span class=normal>72</span>
<span class=normal>73</span>
<span class=normal>74</span>
<span class=normal>75</span>
<span class=normal>76</span>
<span class=normal>77</span>
<span class=normal>78</span>
<span class=normal>79</span>
<span class=normal>80</span>
<span class=normal>81</span>
<span class=normal>82</span>
<span class=normal>83</span>
<span class=normal>84</span>
<span class=normal>85</span>
<span class=normal>86</span>
<span class=normal>87</span>
<span class=normal>88</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>circular_shift</span><span class=p>(</span><span class=n>m</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>s</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Circularly shift matrix rows or columns by specified amounts.</span>

<span class=sd>    Each matrix row (or column) is circularly shifted by a different amount.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    m : np.ndarray</span>
<span class=sd>        Matrix to rotate. Should be a 2D array.</span>
<span class=sd>    s : np.ndarray</span>
<span class=sd>        Shift amounts for each row (horizontal vector) or column (vertical vector).</span>
<span class=sd>        Should be a 1D array.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    shifted : np.ndarray</span>
<span class=sd>        Matrix `m` with rows (or columns) circularly shifted by the amounts in `s`.</span>

<span class=sd>    Raises</span>
<span class=sd>    ------</span>
<span class=sd>    ValueError</span>
<span class=sd>        If `s` is not a vector of integers or if `m` is not a 2D matrix.</span>
<span class=sd>        If the sizes of `m` and `s` are incompatible.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    This function is adapted from CircularShift.m, Copyright (C) 2012 by Michaël Zugaro.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Check number of parameters</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;Second parameter is not a vector of integers.&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>m</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;First parameter is not a 2D matrix.&quot;</span><span class=p>)</span>

    <span class=n>mm</span><span class=p>,</span> <span class=n>nm</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>shape</span>
    <span class=c1># if s is 1d array, add dimension</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
        <span class=n>s</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>,</span> <span class=p>:]</span>
    <span class=n>ms</span><span class=p>,</span> <span class=n>ns</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=n>shape</span>

    <span class=c1># Check parameter sizes</span>
    <span class=k>if</span> <span class=n>mm</span> <span class=o>!=</span> <span class=n>ms</span> <span class=ow>and</span> <span class=n>nm</span> <span class=o>!=</span> <span class=n>ns</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;Incompatible parameter sizes.&quot;</span><span class=p>)</span>

    <span class=c1># The algorithm below works along columns; transpose if necessary</span>
    <span class=n>s</span> <span class=o>=</span> <span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>ravel</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>ns</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
        <span class=n>m</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>T</span>
        <span class=n>mm</span><span class=p>,</span> <span class=n>nm</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>shape</span>

    <span class=c1># Shift matrix S, where Sij is the vertical shift for element ij</span>
    <span class=n>shift</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=p>(</span><span class=n>mm</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>

    <span class=c1># Before we start, each element Mij has a linear index Aij.</span>
    <span class=c1># After circularly shifting the rows, it will have a linear index Bij.</span>
    <span class=c1># We now construct Bij.</span>

    <span class=c1># First, create matrix C where each item Cij = i (row number)</span>
    <span class=n>lines</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>mm</span><span class=p>)[:,</span> <span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>],</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>nm</span><span class=p>))</span>
    <span class=c1># Next, update C so that Cij becomes the target row number (after circular shift)</span>
    <span class=n>lines</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mod</span><span class=p>(</span><span class=n>lines</span> <span class=o>+</span> <span class=n>shift</span><span class=p>,</span> <span class=n>mm</span><span class=p>)</span>
    <span class=c1># lines[lines == 0] = mm</span>
    <span class=c1># Finally, transform Cij into a linear index, yielding Bij</span>
    <span class=n>indices</span> <span class=o>=</span> <span class=n>lines</span> <span class=o>+</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>nm</span><span class=p>)</span> <span class=o>*</span> <span class=n>mm</span><span class=p>,</span> <span class=p>(</span><span class=n>mm</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>

    <span class=c1># Circular shift (reshape so that it is not transformed into a vector)</span>
    <span class=n>shifted</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>ravel</span><span class=p>()[(</span><span class=n>indices</span><span class=o>.</span><span class=n>flatten</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)]</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=n>mm</span><span class=p>,</span> <span class=n>nm</span><span class=p>)</span>

    <span class=c1># flip matrix right to left</span>
    <span class=c1># shifted = np.fliplr(shifted)</span>

    <span class=n>shifted</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>flipud</span><span class=p>(</span><span class=n>shifted</span><span class=p>)</span>

    <span class=c1># Transpose back if necessary</span>
    <span class=k>if</span> <span class=n>ns</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
        <span class=n>shifted</span> <span class=o>=</span> <span class=n>shifted</span><span class=o>.</span><span class=n>T</span>

    <span class=k>return</span> <span class=n>shifted</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.compute_AutoCorrs class="doc doc-heading"> <code class="highlight language-python"><span class=n>compute_AutoCorrs</span><span class=p>(</span><span class=n>spks</span><span class=p>,</span> <span class=n>binsize</span><span class=o>=</span><span class=mf>0.001</span><span class=p>,</span> <span class=n>nbins</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute autocorrelations for spike trains.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>spks</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Nested ndarrays where each array contains the spike times for one neuron.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>binsize</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The size of each bin in seconds, by default 0.001 (1 ms).</p> </div> </td> <td> <code>0.001</code> </td> </tr> <tr class=doc-section-item> <td> <code>nbins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins for the autocorrelation, by default 100.</p> </div> </td> <td> <code>100</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>A DataFrame where each column represents the autocorrelation of the corresponding neuron. The index is the time lag, and the values are the autocorrelations.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/correlations.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>compute_AutoCorrs</span><span class=p>(</span>
    <span class=n>spks</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>binsize</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.001</span><span class=p>,</span> <span class=n>nbins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute autocorrelations for spike trains.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    spks : np.ndarray</span>
<span class=sd>        Nested ndarrays where each array contains the spike times for one neuron.</span>
<span class=sd>    binsize : float, optional</span>
<span class=sd>        The size of each bin in seconds, by default 0.001 (1 ms).</span>
<span class=sd>    nbins : int, optional</span>
<span class=sd>        The number of bins for the autocorrelation, by default 100.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame</span>
<span class=sd>        A DataFrame where each column represents the autocorrelation of the corresponding neuron.</span>
<span class=sd>        The index is the time lag, and the values are the autocorrelations.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># First let&#39;s prepare a pandas dataframe to receive the data</span>
    <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>binsize</span> <span class=o>*</span> <span class=p>(</span><span class=n>nbins</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=n>binsize</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=n>nbins</span> <span class=o>*</span> <span class=n>binsize</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
    <span class=n>autocorrs</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>spks</span><span class=p>)))</span>

    <span class=c1># Now we can iterate over the dictionnary of spikes</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>spks</span><span class=p>):</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
            <span class=k>continue</span>
        <span class=c1># Calling the crossCorr function</span>
        <span class=n>autocorrs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>binsize</span><span class=p>,</span> <span class=n>nbins</span><span class=p>)</span>

    <span class=c1># And don&#39;t forget to replace the 0 ms for 0</span>
    <span class=n>autocorrs</span><span class=o>.</span><span class=n>loc</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mf>0.0</span>
    <span class=k>return</span> <span class=n>autocorrs</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.compute_cross_correlogram class="doc doc-heading"> <code class="highlight language-python"><span class=n>compute_cross_correlogram</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>dt</span><span class=o>=</span><span class=mf>1.0</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=mf>0.5</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute pairwise cross-correlograms between signals in an array.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>X</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>N-dimensional array of shape (n_signals, n_timepoints) representing the signals.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>dt</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Time step between samples in seconds, default is 1.0.</p> </div> </td> <td> <code>1.0</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Window size in seconds for the cross-correlogram. The output will include values within +/- window from the center. If None, returns the full correlogram.</p> </div> </td> <td> <code>0.5</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>Pairwise cross-correlogram with time lags as the index and signal pairs as columns.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/correlations.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>222</span>
<span class=normal>223</span>
<span class=normal>224</span>
<span class=normal>225</span>
<span class=normal>226</span>
<span class=normal>227</span>
<span class=normal>228</span>
<span class=normal>229</span>
<span class=normal>230</span>
<span class=normal>231</span>
<span class=normal>232</span>
<span class=normal>233</span>
<span class=normal>234</span>
<span class=normal>235</span>
<span class=normal>236</span>
<span class=normal>237</span>
<span class=normal>238</span>
<span class=normal>239</span>
<span class=normal>240</span>
<span class=normal>241</span>
<span class=normal>242</span>
<span class=normal>243</span>
<span class=normal>244</span>
<span class=normal>245</span>
<span class=normal>246</span>
<span class=normal>247</span>
<span class=normal>248</span>
<span class=normal>249</span>
<span class=normal>250</span>
<span class=normal>251</span>
<span class=normal>252</span>
<span class=normal>253</span>
<span class=normal>254</span>
<span class=normal>255</span>
<span class=normal>256</span>
<span class=normal>257</span>
<span class=normal>258</span>
<span class=normal>259</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>compute_cross_correlogram</span><span class=p>(</span>
    <span class=n>X</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>dt</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>,</span> <span class=n>window</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.5</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute pairwise cross-correlograms between signals in an array.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    X : np.ndarray</span>
<span class=sd>        N-dimensional array of shape (n_signals, n_timepoints) representing the signals.</span>
<span class=sd>    dt : float, optional</span>
<span class=sd>        Time step between samples in seconds, default is 1.0.</span>
<span class=sd>    window : float, optional</span>
<span class=sd>        Window size in seconds for the cross-correlogram. The output will include values</span>
<span class=sd>        within +/- window from the center. If None, returns the full correlogram.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame</span>
<span class=sd>        Pairwise cross-correlogram with time lags as the index and signal pairs as columns.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>crosscorrs</span> <span class=o>=</span> <span class=p>{}</span>
    <span class=n>pairs</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>itertools</span><span class=o>.</span><span class=n>combinations</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>X</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span> <span class=mi>2</span><span class=p>))</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>pairs</span><span class=p>:</span>
        <span class=n>auc</span> <span class=o>=</span> <span class=n>signal</span><span class=o>.</span><span class=n>correlate</span><span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>X</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>signal</span><span class=o>.</span><span class=n>correlation_lags</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>i</span><span class=p>]),</span> <span class=nb>len</span><span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>j</span><span class=p>]))</span> <span class=o>*</span> <span class=n>dt</span>
        <span class=c1># normalize by coeff</span>
        <span class=n>normalizer</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>((</span><span class=n>X</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>**</span> <span class=mi>2</span><span class=p>)</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>**</span> <span class=mi>2</span><span class=p>)</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>))</span>
        <span class=n>auc</span> <span class=o>/=</span> <span class=n>normalizer</span>

        <span class=n>crosscorrs</span><span class=p>[(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)]</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>Series</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=n>auc</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=s2>&quot;float32&quot;</span><span class=p>)</span>
    <span class=n>crosscorrs</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=o>.</span><span class=n>from_dict</span><span class=p>(</span><span class=n>crosscorrs</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>crosscorrs</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>crosscorrs</span><span class=p>[(</span><span class=n>crosscorrs</span><span class=o>.</span><span class=n>index</span> <span class=o>&gt;=</span> <span class=o>-</span><span class=n>window</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>crosscorrs</span><span class=o>.</span><span class=n>index</span> <span class=o>&lt;=</span> <span class=n>window</span><span class=p>)]</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.compute_image_spread class="doc doc-heading"> <code class="highlight language-python"><span class=n>compute_image_spread</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>exponent</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>normalize</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the spread of an image using the square root of a weighted moment.</p> <p>The spread is calculated as the square root of a weighted moment of the image, where the weights are derived from the deviations of each pixel from the center of mass (COM) of the image.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>X</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D numpy array of shape (numBinsY, numBinsX). If <code>normalize</code> is True, the input is assumed to represent a probability distribution.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>exponent</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The exponent used in the moment calculation. Default is 2.</p> </div> </td> <td> <code>2</code> </td> </tr> <tr class=doc-section-item> <td> <code>normalize</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, normalize the input array so that its sum is 1. Default is True.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>spread</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The computed spread, defined as the square root of the weighted moment.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>image_moment</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The raw weighted moment of the image.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>X</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>],</span> <span class=p>[</span><span class=mf>0.4</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.6</span><span class=p>],</span> <span class=p>[</span><span class=mf>0.7</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>,</span> <span class=mf>0.9</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>spread</span><span class=p>,</span> <span class=n>image_moment</span> <span class=o>=</span> <span class=n>compute_image_spread</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>exponent</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>spread</span><span class=p>)</span>
<span class=go>0.5704157028642128</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>image_moment</span><span class=p>)</span>
<span class=go>0.325374074074074</span>
</code></pre></div> <details class=references open> <summary>References</summary> <p>Widloski &amp; Foster, 2022</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>387</span>
<span class=normal>388</span>
<span class=normal>389</span>
<span class=normal>390</span>
<span class=normal>391</span>
<span class=normal>392</span>
<span class=normal>393</span>
<span class=normal>394</span>
<span class=normal>395</span>
<span class=normal>396</span>
<span class=normal>397</span>
<span class=normal>398</span>
<span class=normal>399</span>
<span class=normal>400</span>
<span class=normal>401</span>
<span class=normal>402</span>
<span class=normal>403</span>
<span class=normal>404</span>
<span class=normal>405</span>
<span class=normal>406</span>
<span class=normal>407</span>
<span class=normal>408</span>
<span class=normal>409</span>
<span class=normal>410</span>
<span class=normal>411</span>
<span class=normal>412</span>
<span class=normal>413</span>
<span class=normal>414</span>
<span class=normal>415</span>
<span class=normal>416</span>
<span class=normal>417</span>
<span class=normal>418</span>
<span class=normal>419</span>
<span class=normal>420</span>
<span class=normal>421</span>
<span class=normal>422</span>
<span class=normal>423</span>
<span class=normal>424</span>
<span class=normal>425</span>
<span class=normal>426</span>
<span class=normal>427</span>
<span class=normal>428</span>
<span class=normal>429</span>
<span class=normal>430</span>
<span class=normal>431</span>
<span class=normal>432</span>
<span class=normal>433</span>
<span class=normal>434</span>
<span class=normal>435</span>
<span class=normal>436</span>
<span class=normal>437</span>
<span class=normal>438</span>
<span class=normal>439</span>
<span class=normal>440</span>
<span class=normal>441</span>
<span class=normal>442</span>
<span class=normal>443</span>
<span class=normal>444</span>
<span class=normal>445</span>
<span class=normal>446</span>
<span class=normal>447</span>
<span class=normal>448</span>
<span class=normal>449</span>
<span class=normal>450</span>
<span class=normal>451</span>
<span class=normal>452</span>
<span class=normal>453</span>
<span class=normal>454</span>
<span class=normal>455</span>
<span class=normal>456</span>
<span class=normal>457</span>
<span class=normal>458</span>
<span class=normal>459</span>
<span class=normal>460</span>
<span class=normal>461</span>
<span class=normal>462</span>
<span class=normal>463</span>
<span class=normal>464</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>compute_image_spread</span><span class=p>(</span>
    <span class=n>X</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>exponent</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span> <span class=n>normalize</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the spread of an image using the square root of a weighted moment.</span>

<span class=sd>    The spread is calculated as the square root of a weighted moment of the image,</span>
<span class=sd>    where the weights are derived from the deviations of each pixel from the</span>
<span class=sd>    center of mass (COM) of the image.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    X : np.ndarray</span>
<span class=sd>        A 2D numpy array of shape (numBinsY, numBinsX). If `normalize` is True,</span>
<span class=sd>        the input is assumed to represent a probability distribution.</span>
<span class=sd>    exponent : float, optional</span>
<span class=sd>        The exponent used in the moment calculation. Default is 2.</span>
<span class=sd>    normalize : bool, optional</span>
<span class=sd>        If True, normalize the input array so that its sum is 1. Default is True.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    spread : float</span>
<span class=sd>        The computed spread, defined as the square root of the weighted moment.</span>
<span class=sd>    image_moment : float</span>
<span class=sd>        The raw weighted moment of the image.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; X = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])</span>
<span class=sd>    &gt;&gt;&gt; spread, image_moment = compute_image_spread(X, exponent=2)</span>
<span class=sd>    &gt;&gt;&gt; print(spread)</span>
<span class=sd>    0.5704157028642128</span>
<span class=sd>    &gt;&gt;&gt; print(image_moment)</span>
<span class=sd>    0.325374074074074</span>

<span class=sd>    References</span>
<span class=sd>    ----------</span>
<span class=sd>    Widloski &amp; Foster, 2022</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>allclose</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=mi>0</span><span class=p>):</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>  <span class=c1># Return NaN if the input is all zero</span>

    <span class=k>if</span> <span class=n>normalize</span><span class=p>:</span>
        <span class=n>X</span> <span class=o>=</span> <span class=n>X</span> <span class=o>/</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span><span class=n>X</span><span class=p>)</span>  <span class=c1># Normalize the input</span>

    <span class=n>numBinsY</span><span class=p>,</span> <span class=n>numBinsX</span> <span class=o>=</span> <span class=n>X</span><span class=o>.</span><span class=n>shape</span>

    <span class=c1># Compute center of mass (COM) for the X (columns) direction.</span>
    <span class=n>cols</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>numBinsX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
    <span class=n>sumX</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># sum over rows, shape: (numBinsX,)</span>
    <span class=n>totalX</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span><span class=n>sumX</span><span class=p>)</span>
    <span class=c1># Add a small correction term</span>
    <span class=n>comX</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span><span class=n>sumX</span> <span class=o>*</span> <span class=n>cols</span><span class=p>)</span> <span class=o>/</span> <span class=n>totalX</span> <span class=o>+</span> <span class=mf>0.5</span> <span class=o>/</span> <span class=n>numBinsX</span>

    <span class=c1># Compute center of mass for the Y (rows) direction.</span>
    <span class=n>rows</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>numBinsY</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
    <span class=n>sumY</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># sum over columns, shape: (numBinsY,)</span>
    <span class=n>totalY</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span><span class=n>sumY</span><span class=p>)</span>
    <span class=n>comY</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span><span class=n>sumY</span> <span class=o>*</span> <span class=n>rows</span><span class=p>)</span> <span class=o>/</span> <span class=n>totalY</span> <span class=o>+</span> <span class=mf>0.5</span> <span class=o>/</span> <span class=n>numBinsY</span>

    <span class=c1># Create a meshgrid for the bin indices (using 1-indexing like MATLAB)</span>
    <span class=n>XX</span><span class=p>,</span> <span class=n>YY</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>meshgrid</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>numBinsX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>numBinsY</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span>

    <span class=c1># Compute the weighted moment using the product of the deviations raised to the given exponent.</span>
    <span class=c1># For each bin, we compute:</span>
    <span class=c1>#     |XX - comX|^exponent * |YY - comY|^exponent * X(i,j)</span>
    <span class=n>moment</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span>
        <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>XX</span> <span class=o>-</span> <span class=n>comX</span><span class=p>)</span> <span class=o>**</span> <span class=n>exponent</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>YY</span> <span class=o>-</span> <span class=n>comY</span><span class=p>)</span> <span class=o>**</span> <span class=n>exponent</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span>
    <span class=p>)</span>

    <span class=c1># Normalize by the total probability.</span>
    <span class=n>image_moment</span> <span class=o>=</span> <span class=n>moment</span> <span class=o>/</span> <span class=n>np</span><span class=o>.</span><span class=n>nansum</span><span class=p>(</span><span class=n>X</span><span class=p>)</span>

    <span class=c1># The spread is the square root of the image moment.</span>
    <span class=n>spread</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>image_moment</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>spread</span><span class=p>,</span> <span class=n>image_moment</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.compute_psth class="doc doc-heading"> <code class="highlight language-python"><span class=n>compute_psth</span><span class=p>(</span><span class=n>spikes</span><span class=p>,</span> <span class=n>event</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the Peri-Stimulus Time Histogram (PSTH) from spike trains.</p> <p>This function calculates the PSTH for a given set of spike times aligned to specific events. The PSTH provides a histogram of spike counts in response to the events over a defined time window.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>spikes</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of spike times for multiple trials, with each trial in a separate row.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>event</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of event times to which the spikes are aligned.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Width of each time bin in seconds (default is 0.002 seconds).</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of bins to create for the histogram (default is 100).</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>Time window around each event to consider for the PSTH. If None, a symmetric window is created based on <code>n_bins</code> and <code>bin_width</code>.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>A DataFrame containing the PSTH, indexed by time bins and columns representing each trial's PSTH.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>If the specified window is not symmetric around 0, it is adjusted to be symmetric.</p> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>spikes</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.15</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>],</span> <span class=p>[</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.12</span><span class=p>,</span> <span class=mf>0.13</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>event</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>psth</span> <span class=o>=</span> <span class=n>compute_psth</span><span class=p>(</span><span class=n>spikes</span><span class=p>,</span> <span class=n>event</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 99</span>
<span class=normal>100</span>
<span class=normal>101</span>
<span class=normal>102</span>
<span class=normal>103</span>
<span class=normal>104</span>
<span class=normal>105</span>
<span class=normal>106</span>
<span class=normal>107</span>
<span class=normal>108</span>
<span class=normal>109</span>
<span class=normal>110</span>
<span class=normal>111</span>
<span class=normal>112</span>
<span class=normal>113</span>
<span class=normal>114</span>
<span class=normal>115</span>
<span class=normal>116</span>
<span class=normal>117</span>
<span class=normal>118</span>
<span class=normal>119</span>
<span class=normal>120</span>
<span class=normal>121</span>
<span class=normal>122</span>
<span class=normal>123</span>
<span class=normal>124</span>
<span class=normal>125</span>
<span class=normal>126</span>
<span class=normal>127</span>
<span class=normal>128</span>
<span class=normal>129</span>
<span class=normal>130</span>
<span class=normal>131</span>
<span class=normal>132</span>
<span class=normal>133</span>
<span class=normal>134</span>
<span class=normal>135</span>
<span class=normal>136</span>
<span class=normal>137</span>
<span class=normal>138</span>
<span class=normal>139</span>
<span class=normal>140</span>
<span class=normal>141</span>
<span class=normal>142</span>
<span class=normal>143</span>
<span class=normal>144</span>
<span class=normal>145</span>
<span class=normal>146</span>
<span class=normal>147</span>
<span class=normal>148</span>
<span class=normal>149</span>
<span class=normal>150</span>
<span class=normal>151</span>
<span class=normal>152</span>
<span class=normal>153</span>
<span class=normal>154</span>
<span class=normal>155</span>
<span class=normal>156</span>
<span class=normal>157</span>
<span class=normal>158</span>
<span class=normal>159</span>
<span class=normal>160</span>
<span class=normal>161</span>
<span class=normal>162</span>
<span class=normal>163</span>
<span class=normal>164</span>
<span class=normal>165</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>compute_psth</span><span class=p>(</span>
    <span class=n>spikes</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>event</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=nb>list</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the Peri-Stimulus Time Histogram (PSTH) from spike trains.</span>

<span class=sd>    This function calculates the PSTH for a given set of spike times aligned to specific events.</span>
<span class=sd>    The PSTH provides a histogram of spike counts in response to the events over a defined time window.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    spikes : np.ndarray</span>
<span class=sd>        An array of spike times for multiple trials, with each trial in a separate row.</span>
<span class=sd>    event : np.ndarray</span>
<span class=sd>        An array of event times to which the spikes are aligned.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        Width of each time bin in seconds (default is 0.002 seconds).</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        Number of bins to create for the histogram (default is 100).</span>
<span class=sd>    window : list, optional</span>
<span class=sd>        Time window around each event to consider for the PSTH. If None, a symmetric window is created based on `n_bins` and `bin_width`.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame</span>
<span class=sd>        A DataFrame containing the PSTH, indexed by time bins and columns representing each trial&#39;s PSTH.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    If the specified window is not symmetric around 0, it is adjusted to be symmetric.</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; spikes = np.array([[0.1, 0.15, 0.2], [0.1, 0.12, 0.13]])</span>
<span class=sd>    &gt;&gt;&gt; event = np.array([0.1, 0.3])</span>
<span class=sd>    &gt;&gt;&gt; psth = compute_psth(spikes, event)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>window_original</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=c1># check if window is symmetric around 0, if not make it so</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>!=</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>|</span> <span class=p>(</span>
            <span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>/</span> <span class=o>-</span><span class=mi>2</span> <span class=o>!=</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=p>):</span>
            <span class=n>window_original</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>window</span><span class=p>)</span>
            <span class=n>window</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>window</span><span class=p>)),</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>window</span><span class=p>))]</span>

        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
        <span class=n>n_bins</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=p>)</span>

    <span class=n>ccg</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>spikes</span><span class=p>)))</span>
    <span class=c1># Now we can iterate over spikes</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>spikes</span><span class=p>):</span>
        <span class=n>ccg</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>event</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span><span class=p>)</span>

    <span class=c1># if window was not symmetric, remove the extra bins</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>window_original</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>ccg</span> <span class=o>=</span> <span class=n>ccg</span><span class=o>.</span><span class=n>loc</span><span class=p>[</span><span class=n>window_original</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>:</span> <span class=n>window_original</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=p>:]</span>
    <span class=k>return</span> <span class=n>ccg</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.corrcc class="doc doc-heading"> <code class="highlight language-python"><span class=n>corrcc</span><span class=p>(</span><span class=n>alpha1</span><span class=p>,</span> <span class=n>alpha2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Circular correlation coefficient for two circular random variables.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>alpha1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Sample of angles in radians.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>alpha2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Sample of angles in radians.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>axis</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=int>int</span>]</code> </td> <td> <div class=doc-md-description> <p>The axis along which to compute the correlation coefficient. If None, compute over the entire array (default is None).</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>rho</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Circular-circular correlation coefficient.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>pval</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>p-value for testing the significance of the correlation coefficient.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>alpha1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.4</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>alpha2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.6</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>rho</span><span class=p>,</span> <span class=n>pval</span> <span class=o>=</span> <span class=n>corrcc</span><span class=p>(</span><span class=n>alpha1</span><span class=p>,</span> <span class=n>alpha2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Circular correlation: </span><span class=si>{</span><span class=n>rho</span><span class=si>}</span><span class=s2>, p-value: </span><span class=si>{</span><span class=n>pval</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <details class=note open> <summary>Notes</summary> <p>The function computes the correlation between two sets of angles using a method that adjusts for circular data. The significance of the correlation coefficient is tested using the fact that the test statistic is approximately normally distributed.</p> </details> <details class=references open> <summary>References</summary> <p>Jammalamadaka et al (2001)</p> <p>Original code: https://github.com/circstat/pycircstat Modified by: Salman Qasim, 11/12/2018</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/precession_utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span>
<span class=normal>72</span>
<span class=normal>73</span>
<span class=normal>74</span>
<span class=normal>75</span>
<span class=normal>76</span>
<span class=normal>77</span>
<span class=normal>78</span>
<span class=normal>79</span>
<span class=normal>80</span>
<span class=normal>81</span>
<span class=normal>82</span>
<span class=normal>83</span>
<span class=normal>84</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>corrcc</span><span class=p>(</span>
    <span class=n>alpha1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>alpha2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>axis</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Circular correlation coefficient for two circular random variables.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    alpha1 : np.ndarray</span>
<span class=sd>        Sample of angles in radians.</span>
<span class=sd>    alpha2 : np.ndarray</span>
<span class=sd>        Sample of angles in radians.</span>
<span class=sd>    axis : Optional[int], optional</span>
<span class=sd>        The axis along which to compute the correlation coefficient.</span>
<span class=sd>        If None, compute over the entire array (default is None).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    rho : float</span>
<span class=sd>        Circular-circular correlation coefficient.</span>
<span class=sd>    pval : float</span>
<span class=sd>        p-value for testing the significance of the correlation coefficient.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; alpha1 = np.array([0.1, 0.2, 0.4, 0.5])</span>
<span class=sd>    &gt;&gt;&gt; alpha2 = np.array([0.3, 0.6, 0.2, 0.8])</span>
<span class=sd>    &gt;&gt;&gt; rho, pval = corrcc(alpha1, alpha2)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;Circular correlation: {rho}, p-value: {pval}&quot;)</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    The function computes the correlation between two sets of angles using a</span>
<span class=sd>    method that adjusts for circular data. The significance of the correlation</span>
<span class=sd>    coefficient is tested using the fact that the test statistic is approximately</span>
<span class=sd>    normally distributed.</span>

<span class=sd>    References</span>
<span class=sd>    ----------</span>
<span class=sd>    Jammalamadaka et al (2001)</span>

<span class=sd>    Original code: https://github.com/circstat/pycircstat</span>
<span class=sd>    Modified by: Salman Qasim, 11/12/2018</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>assert</span> <span class=n>alpha1</span><span class=o>.</span><span class=n>shape</span> <span class=o>==</span> <span class=n>alpha2</span><span class=o>.</span><span class=n>shape</span><span class=p>,</span> <span class=s2>&quot;Input dimensions do not match.&quot;</span>

    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>alpha1</span><span class=p>)</span>

    <span class=c1># center data on circular mean</span>
    <span class=n>alpha1_centered</span><span class=p>,</span> <span class=n>alpha2_centered</span> <span class=o>=</span> <span class=n>pcs</span><span class=o>.</span><span class=n>center</span><span class=p>(</span><span class=n>alpha1</span><span class=p>,</span> <span class=n>alpha2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span>

    <span class=n>num</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha1_centered</span><span class=p>)</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha2_centered</span><span class=p>),</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span>
    <span class=n>den</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha1_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span>
        <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha2_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span>
    <span class=p>)</span>
    <span class=c1># compute correlation coefficient from p. 176</span>
    <span class=n>rho</span> <span class=o>=</span> <span class=n>num</span> <span class=o>/</span> <span class=n>den</span>

    <span class=c1># Modification:</span>
    <span class=c1># significance of this correlation coefficient can be tested using the fact that Z is approx. normal</span>

    <span class=n>l20</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha1_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>l02</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha2_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>l22</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>((</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha1_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha2_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>))</span>
    <span class=n>z</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>((</span><span class=n>n</span> <span class=o>*</span> <span class=n>l20</span> <span class=o>*</span> <span class=n>l02</span><span class=p>)</span> <span class=o>/</span> <span class=n>l22</span><span class=p>)</span> <span class=o>*</span> <span class=n>rho</span>
    <span class=n>pval</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>sp</span><span class=o>.</span><span class=n>stats</span><span class=o>.</span><span class=n>norm</span><span class=o>.</span><span class=n>cdf</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>z</span><span class=p>)))</span>  <span class=c1># two-sided test</span>

    <span class=k>return</span> <span class=n>rho</span><span class=p>,</span> <span class=n>pval</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.corrcc_uniform class="doc doc-heading"> <code class="highlight language-python"><span class=n>corrcc_uniform</span><span class=p>(</span><span class=n>alpha1</span><span class=p>,</span> <span class=n>alpha2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Circular correlation coefficient for two circular random variables. Use this function if at least one of the variables may follow a uniform distribution.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>alpha1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Sample of angles in radians.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>alpha2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Sample of angles in radians.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>axis</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=int>int</span>]</code> </td> <td> <div class=doc-md-description> <p>The axis along which to compute the correlation coefficient. If None, compute over the entire array (default is None).</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>rho</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Circular-circular correlation coefficient.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>pval</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>p-value for testing the significance of the correlation coefficient.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>This method accounts for cases where one or both of the circular variables may follow a uniform distribution. The significance of the correlation coefficient is tested using a normal approximation of the Z statistic.</p> </details> <details class=references open> <summary>References</summary> <p>Jammalamadaka, et al (2001).</p> <p>Original code: https://github.com/circstat/pycircstat Modified by: Salman Qasim, 11/12/2018 https://github.com/HoniSanders/measure_phaseprec/blob/master/cl_corr.m</p> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>alpha1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.4</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>alpha2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.6</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>rho</span><span class=p>,</span> <span class=n>pval</span> <span class=o>=</span> <span class=n>corrcc_uniform</span><span class=p>(</span><span class=n>alpha1</span><span class=p>,</span> <span class=n>alpha2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Circular correlation: </span><span class=si>{</span><span class=n>rho</span><span class=si>}</span><span class=s2>, p-value: </span><span class=si>{</span><span class=n>pval</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/precession_utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 87</span>
<span class=normal> 88</span>
<span class=normal> 89</span>
<span class=normal> 90</span>
<span class=normal> 91</span>
<span class=normal> 92</span>
<span class=normal> 93</span>
<span class=normal> 94</span>
<span class=normal> 95</span>
<span class=normal> 96</span>
<span class=normal> 97</span>
<span class=normal> 98</span>
<span class=normal> 99</span>
<span class=normal>100</span>
<span class=normal>101</span>
<span class=normal>102</span>
<span class=normal>103</span>
<span class=normal>104</span>
<span class=normal>105</span>
<span class=normal>106</span>
<span class=normal>107</span>
<span class=normal>108</span>
<span class=normal>109</span>
<span class=normal>110</span>
<span class=normal>111</span>
<span class=normal>112</span>
<span class=normal>113</span>
<span class=normal>114</span>
<span class=normal>115</span>
<span class=normal>116</span>
<span class=normal>117</span>
<span class=normal>118</span>
<span class=normal>119</span>
<span class=normal>120</span>
<span class=normal>121</span>
<span class=normal>122</span>
<span class=normal>123</span>
<span class=normal>124</span>
<span class=normal>125</span>
<span class=normal>126</span>
<span class=normal>127</span>
<span class=normal>128</span>
<span class=normal>129</span>
<span class=normal>130</span>
<span class=normal>131</span>
<span class=normal>132</span>
<span class=normal>133</span>
<span class=normal>134</span>
<span class=normal>135</span>
<span class=normal>136</span>
<span class=normal>137</span>
<span class=normal>138</span>
<span class=normal>139</span>
<span class=normal>140</span>
<span class=normal>141</span>
<span class=normal>142</span>
<span class=normal>143</span>
<span class=normal>144</span>
<span class=normal>145</span>
<span class=normal>146</span>
<span class=normal>147</span>
<span class=normal>148</span>
<span class=normal>149</span>
<span class=normal>150</span>
<span class=normal>151</span>
<span class=normal>152</span>
<span class=normal>153</span>
<span class=normal>154</span>
<span class=normal>155</span>
<span class=normal>156</span>
<span class=normal>157</span>
<span class=normal>158</span>
<span class=normal>159</span>
<span class=normal>160</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>corrcc_uniform</span><span class=p>(</span>
    <span class=n>alpha1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>alpha2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>axis</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Circular correlation coefficient for two circular random variables.</span>
<span class=sd>    Use this function if at least one of the variables may follow a uniform distribution.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    alpha1 : np.ndarray</span>
<span class=sd>        Sample of angles in radians.</span>
<span class=sd>    alpha2 : np.ndarray</span>
<span class=sd>        Sample of angles in radians.</span>
<span class=sd>    axis : Optional[int], optional</span>
<span class=sd>        The axis along which to compute the correlation coefficient.</span>
<span class=sd>        If None, compute over the entire array (default is None).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    rho : float</span>
<span class=sd>        Circular-circular correlation coefficient.</span>
<span class=sd>    pval : float</span>
<span class=sd>        p-value for testing the significance of the correlation coefficient.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    This method accounts for cases where one or both of the circular variables</span>
<span class=sd>    may follow a uniform distribution. The significance of the correlation coefficient</span>
<span class=sd>    is tested using a normal approximation of the Z statistic.</span>

<span class=sd>    References</span>
<span class=sd>    ----------</span>
<span class=sd>    Jammalamadaka, et al (2001).</span>

<span class=sd>    Original code: https://github.com/circstat/pycircstat</span>
<span class=sd>    Modified by: Salman Qasim, 11/12/2018</span>
<span class=sd>    https://github.com/HoniSanders/measure_phaseprec/blob/master/cl_corr.m</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; alpha1 = np.array([0.1, 0.2, 0.4, 0.5])</span>
<span class=sd>    &gt;&gt;&gt; alpha2 = np.array([0.3, 0.6, 0.2, 0.8])</span>
<span class=sd>    &gt;&gt;&gt; rho, pval = corrcc_uniform(alpha1, alpha2)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;Circular correlation: {rho}, p-value: {pval}&quot;)</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>assert</span> <span class=n>alpha1</span><span class=o>.</span><span class=n>shape</span> <span class=o>==</span> <span class=n>alpha2</span><span class=o>.</span><span class=n>shape</span><span class=p>,</span> <span class=s2>&quot;Input dimensions do not match.&quot;</span>

    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>alpha1</span><span class=p>)</span>

    <span class=c1># center data on circular mean</span>
    <span class=n>alpha1_centered</span><span class=p>,</span> <span class=n>alpha2_centered</span> <span class=o>=</span> <span class=n>pcs</span><span class=o>.</span><span class=n>center</span><span class=p>(</span><span class=n>alpha1</span><span class=p>,</span> <span class=n>alpha2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span>

    <span class=c1># One of the sample means is not well defined due to uniform distribution of data</span>
    <span class=c1># so take the difference of the resultant vector length for the sum and difference</span>
    <span class=c1># of the alphas</span>
    <span class=n>num</span> <span class=o>=</span> <span class=n>pcs</span><span class=o>.</span><span class=n>resultant_vector_length</span><span class=p>(</span><span class=n>alpha1</span> <span class=o>-</span> <span class=n>alpha2</span><span class=p>)</span> <span class=o>-</span> <span class=n>pcs</span><span class=o>.</span><span class=n>resultant_vector_length</span><span class=p>(</span>
        <span class=n>alpha1</span> <span class=o>+</span> <span class=n>alpha2</span>
    <span class=p>)</span>
    <span class=n>den</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha1_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span>
        <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha2_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span>
    <span class=p>)</span>
    <span class=n>rho</span> <span class=o>=</span> <span class=n>n</span> <span class=o>*</span> <span class=n>num</span> <span class=o>/</span> <span class=n>den</span>
    <span class=c1># significance of this correlation coefficient can be tested using the fact that Z</span>
    <span class=c1># is approx. normal</span>

    <span class=n>l20</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha1_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>l02</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha2_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>l22</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>((</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha1_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>alpha2_centered</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span><span class=p>))</span>
    <span class=n>z</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>((</span><span class=n>n</span> <span class=o>*</span> <span class=n>l20</span> <span class=o>*</span> <span class=n>l02</span><span class=p>)</span> <span class=o>/</span> <span class=n>l22</span><span class=p>)</span> <span class=o>*</span> <span class=n>rho</span>
    <span class=n>pval</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>sp</span><span class=o>.</span><span class=n>stats</span><span class=o>.</span><span class=n>norm</span><span class=o>.</span><span class=n>cdf</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>z</span><span class=p>)))</span>  <span class=c1># two-sided test</span>

    <span class=k>return</span> <span class=n>rho</span><span class=p>,</span> <span class=n>pval</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.count_events class="doc doc-heading"> <code class="highlight language-python"><span class=n>count_events</span><span class=p>(</span><span class=n>events</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>,</span> <span class=n>time_range</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Count the number of events that occur within a given time range after each reference event.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of event times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_ref</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of reference times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_range</code> </td> <td> <code>tuple of (float, float)</code> </td> <td> <div class=doc-md-description> <p>A tuple containing the start and end times of the time range.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>counts</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of event counts, one for each reference time (same length as time_ref).</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1017</span>
<span class=normal>1018</span>
<span class=normal>1019</span>
<span class=normal>1020</span>
<span class=normal>1021</span>
<span class=normal>1022</span>
<span class=normal>1023</span>
<span class=normal>1024</span>
<span class=normal>1025</span>
<span class=normal>1026</span>
<span class=normal>1027</span>
<span class=normal>1028</span>
<span class=normal>1029</span>
<span class=normal>1030</span>
<span class=normal>1031</span>
<span class=normal>1032</span>
<span class=normal>1033</span>
<span class=normal>1034</span>
<span class=normal>1035</span>
<span class=normal>1036</span>
<span class=normal>1037</span>
<span class=normal>1038</span>
<span class=normal>1039</span>
<span class=normal>1040</span>
<span class=normal>1041</span>
<span class=normal>1042</span>
<span class=normal>1043</span>
<span class=normal>1044</span>
<span class=normal>1045</span>
<span class=normal>1046</span>
<span class=normal>1047</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>count_events</span><span class=p>(</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>time_range</span><span class=p>:</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Count the number of events that occur within a given time range after each reference event.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    events : np.ndarray</span>
<span class=sd>        A 1D array of event times.</span>
<span class=sd>    time_ref : np.ndarray</span>
<span class=sd>        A 1D array of reference times.</span>
<span class=sd>    time_range : tuple of (float, float)</span>
<span class=sd>        A tuple containing the start and end times of the time range.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    counts : np.ndarray</span>
<span class=sd>        A 1D array of event counts, one for each reference time (same length as time_ref).</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Initialize an array to store the event counts</span>
    <span class=n>counts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros_like</span><span class=p>(</span><span class=n>time_ref</span><span class=p>)</span>

    <span class=c1># Iterate over the reference times</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>time_ref</span><span class=p>):</span>
        <span class=c1># Check if any events occur within the time range</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=p>(</span><span class=n>events</span> <span class=o>&gt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>time_range</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>events</span> <span class=o>&lt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>time_range</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
        <span class=c1># Increment the event count if any events are found</span>
        <span class=n>counts</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span>

    <span class=k>return</span> <span class=n>counts</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.count_in_interval class="doc doc-heading"> <code class="highlight language-python"><span class=n>count_in_interval</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>event_starts</span><span class=p>,</span> <span class=n>event_stops</span><span class=p>,</span> <span class=n>par_type</span><span class=o>=</span><span class=s1>&#39;counts&#39;</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Count timestamps in specified intervals and return a matrix where each column represents the counts for each spike train over given event epochs.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>st</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array where each element is a spike train for a unit.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>event_starts</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array containing the start times of events.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>event_stops</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array containing the stop times of events.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>par_type</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>The type of count calculation to perform: - 'counts': returns raw counts of spikes in the intervals. - 'binary': returns a binary matrix indicating presence (1) or absence (0) of spikes. - 'firing_rate': returns the firing rate calculated as counts divided by the interval duration. Defaults to 'binary'.</p> </div> </td> <td> <code>&#39;counts&#39;</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array (n units x n epochs) where each column shows the counts (or binary values or firing rates) per unit for each epoch.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>765</span>
<span class=normal>766</span>
<span class=normal>767</span>
<span class=normal>768</span>
<span class=normal>769</span>
<span class=normal>770</span>
<span class=normal>771</span>
<span class=normal>772</span>
<span class=normal>773</span>
<span class=normal>774</span>
<span class=normal>775</span>
<span class=normal>776</span>
<span class=normal>777</span>
<span class=normal>778</span>
<span class=normal>779</span>
<span class=normal>780</span>
<span class=normal>781</span>
<span class=normal>782</span>
<span class=normal>783</span>
<span class=normal>784</span>
<span class=normal>785</span>
<span class=normal>786</span>
<span class=normal>787</span>
<span class=normal>788</span>
<span class=normal>789</span>
<span class=normal>790</span>
<span class=normal>791</span>
<span class=normal>792</span>
<span class=normal>793</span>
<span class=normal>794</span>
<span class=normal>795</span>
<span class=normal>796</span>
<span class=normal>797</span>
<span class=normal>798</span>
<span class=normal>799</span>
<span class=normal>800</span>
<span class=normal>801</span>
<span class=normal>802</span>
<span class=normal>803</span>
<span class=normal>804</span>
<span class=normal>805</span>
<span class=normal>806</span>
<span class=normal>807</span>
<span class=normal>808</span>
<span class=normal>809</span>
<span class=normal>810</span>
<span class=normal>811</span>
<span class=normal>812</span>
<span class=normal>813</span>
<span class=normal>814</span>
<span class=normal>815</span>
<span class=normal>816</span>
<span class=normal>817</span>
<span class=normal>818</span>
<span class=normal>819</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>count_in_interval</span><span class=p>(</span>
    <span class=n>st</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>event_starts</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>event_stops</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>par_type</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&quot;counts&quot;</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Count timestamps in specified intervals and return a matrix where each</span>
<span class=sd>    column represents the counts for each spike train over given event epochs.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    st : np.ndarray</span>
<span class=sd>        A 1D array where each element is a spike train for a unit.</span>

<span class=sd>    event_starts : np.ndarray</span>
<span class=sd>        A 1D array containing the start times of events.</span>

<span class=sd>    event_stops : np.ndarray</span>
<span class=sd>        A 1D array containing the stop times of events.</span>

<span class=sd>    par_type : str, optional</span>
<span class=sd>        The type of count calculation to perform:</span>
<span class=sd>        - &#39;counts&#39;: returns raw counts of spikes in the intervals.</span>
<span class=sd>        - &#39;binary&#39;: returns a binary matrix indicating presence (1) or absence (0) of spikes.</span>
<span class=sd>        - &#39;firing_rate&#39;: returns the firing rate calculated as counts divided by the interval duration.</span>
<span class=sd>        Defaults to &#39;binary&#39;.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        A 2D array (n units x n epochs) where each column shows the counts (or binary values or firing rates)</span>
<span class=sd>        per unit for each epoch.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># convert to numpy array</span>
    <span class=n>event_starts</span><span class=p>,</span> <span class=n>event_stops</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>event_starts</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>event_stops</span><span class=p>)</span>

    <span class=c1># initialize matrix</span>
    <span class=n>unit_mat</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=nb>len</span><span class=p>(</span><span class=n>st</span><span class=p>),</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>event_starts</span><span class=p>))))</span>

    <span class=c1># loop over units and bin spikes into epochs</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>st</span><span class=p>):</span>
        <span class=n>idx1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>event_starts</span><span class=p>,</span> <span class=s2>&quot;right&quot;</span><span class=p>)</span>
        <span class=n>idx2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>event_stops</span><span class=p>,</span> <span class=s2>&quot;left&quot;</span><span class=p>)</span>
        <span class=n>unit_mat</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=p>:]</span> <span class=o>=</span> <span class=n>idx2</span> <span class=o>-</span> <span class=n>idx1</span>

    <span class=n>par_type_funcs</span> <span class=o>=</span> <span class=p>{</span>
        <span class=s2>&quot;counts&quot;</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>,</span>
        <span class=s2>&quot;binary&quot;</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1</span><span class=p>,</span>
        <span class=s2>&quot;firing_rate&quot;</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>event_stops</span> <span class=o>-</span> <span class=n>event_starts</span><span class=p>),</span>
    <span class=p>}</span>
    <span class=n>calc_func</span> <span class=o>=</span> <span class=n>par_type_funcs</span><span class=p>[</span><span class=n>par_type</span><span class=p>]</span>
    <span class=n>unit_mat</span> <span class=o>=</span> <span class=n>calc_func</span><span class=p>(</span><span class=n>unit_mat</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>unit_mat</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.crossCorr class="doc doc-heading"> <code class="highlight language-python"><span class=n>crossCorr</span><span class=p>(</span><span class=n>t1</span><span class=p>,</span> <span class=n>t2</span><span class=p>,</span> <span class=n>binsize</span><span class=p>,</span> <span class=n>nbins</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Perform the discrete cross-correlogram of two time series.</p> <p>This function calculates the firing rate of the series 't2' relative to the timings of 't1'. The units should be in seconds for all arguments.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>t1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>First time series.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>t2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Second time series.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>binsize</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Size of the bin in seconds.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>nbins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of bins.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Cross-correlogram of the two time series.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>This implementation is based on the work of Guillaume Viejo. References: - https://github.com/PeyracheLab/StarterPack/blob/master/python/main6_autocorr.py - https://github.com/pynapple-org/pynapple/blob/main/pynapple/process/correlograms.py</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span>
<span class=normal>72</span>
<span class=normal>73</span>
<span class=normal>74</span>
<span class=normal>75</span>
<span class=normal>76</span>
<span class=normal>77</span>
<span class=normal>78</span>
<span class=normal>79</span>
<span class=normal>80</span>
<span class=normal>81</span>
<span class=normal>82</span>
<span class=normal>83</span>
<span class=normal>84</span>
<span class=normal>85</span>
<span class=normal>86</span>
<span class=normal>87</span>
<span class=normal>88</span>
<span class=normal>89</span>
<span class=normal>90</span>
<span class=normal>91</span>
<span class=normal>92</span>
<span class=normal>93</span>
<span class=normal>94</span>
<span class=normal>95</span>
<span class=normal>96</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>crossCorr</span><span class=p>(</span>
    <span class=n>t1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>t2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>binsize</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
    <span class=n>nbins</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Perform the discrete cross-correlogram of two time series.</span>

<span class=sd>    This function calculates the firing rate of the series &#39;t2&#39; relative to the timings of &#39;t1&#39;.</span>
<span class=sd>    The units should be in seconds for all arguments.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    t1 : np.ndarray</span>
<span class=sd>        First time series.</span>
<span class=sd>    t2 : np.ndarray</span>
<span class=sd>        Second time series.</span>
<span class=sd>    binsize : float</span>
<span class=sd>        Size of the bin in seconds.</span>
<span class=sd>    nbins : int</span>
<span class=sd>        Number of bins.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        Cross-correlogram of the two time series.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    This implementation is based on the work of Guillaume Viejo.</span>
<span class=sd>    References:</span>
<span class=sd>    - https://github.com/PeyracheLab/StarterPack/blob/master/python/main6_autocorr.py</span>
<span class=sd>    - https://github.com/pynapple-org/pynapple/blob/main/pynapple/process/correlograms.py</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Calculate the length of the input time series</span>
    <span class=n>nt1</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>t1</span><span class=p>)</span>
    <span class=n>nt2</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>t2</span><span class=p>)</span>

    <span class=c1># Ensure that &#39;nbins&#39; is an odd number</span>
    <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>floor</span><span class=p>(</span><span class=n>nbins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>==</span> <span class=n>nbins</span><span class=p>:</span>
        <span class=n>nbins</span> <span class=o>=</span> <span class=n>nbins</span> <span class=o>+</span> <span class=mi>1</span>

    <span class=c1># Calculate the half-width of the cross-correlogram window</span>
    <span class=n>w</span> <span class=o>=</span> <span class=p>(</span><span class=n>nbins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=n>binsize</span>
    <span class=n>C</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=n>nbins</span><span class=p>)</span>
    <span class=n>i2</span> <span class=o>=</span> <span class=mi>1</span>

    <span class=c1># Iterate through the first time series</span>
    <span class=k>for</span> <span class=n>i1</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>nt1</span><span class=p>):</span>
        <span class=n>lbound</span> <span class=o>=</span> <span class=n>t1</span><span class=p>[</span><span class=n>i1</span><span class=p>]</span> <span class=o>-</span> <span class=n>w</span>

        <span class=c1># Find the index of the first element in &#39;t2&#39; that is within &#39;lbound&#39;</span>
        <span class=k>while</span> <span class=n>i2</span> <span class=o>&lt;</span> <span class=n>nt2</span> <span class=ow>and</span> <span class=n>t2</span><span class=p>[</span><span class=n>i2</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>lbound</span><span class=p>:</span>
            <span class=n>i2</span> <span class=o>=</span> <span class=n>i2</span> <span class=o>+</span> <span class=mi>1</span>

        <span class=c1># Find the index of the last element in &#39;t2&#39; that is within &#39;lbound&#39;</span>
        <span class=k>while</span> <span class=n>i2</span> <span class=o>&gt;</span> <span class=mi>1</span> <span class=ow>and</span> <span class=n>t2</span><span class=p>[</span><span class=n>i2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>lbound</span><span class=p>:</span>
            <span class=n>i2</span> <span class=o>=</span> <span class=n>i2</span> <span class=o>-</span> <span class=mi>1</span>

        <span class=n>rbound</span> <span class=o>=</span> <span class=n>lbound</span>
        <span class=n>last_index</span> <span class=o>=</span> <span class=n>i2</span>

        <span class=c1># Calculate the cross-correlogram values for each bin</span>
        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>nbins</span><span class=p>):</span>
            <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span>
            <span class=n>rbound</span> <span class=o>=</span> <span class=n>rbound</span> <span class=o>+</span> <span class=n>binsize</span>

            <span class=c1># Count the number of elements in &#39;t2&#39; that fall within the bin</span>
            <span class=k>while</span> <span class=n>last_index</span> <span class=o>&lt;</span> <span class=n>nt2</span> <span class=ow>and</span> <span class=n>t2</span><span class=p>[</span><span class=n>last_index</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>rbound</span><span class=p>:</span>
                <span class=n>last_index</span> <span class=o>=</span> <span class=n>last_index</span> <span class=o>+</span> <span class=mi>1</span>
                <span class=n>k</span> <span class=o>=</span> <span class=n>k</span> <span class=o>+</span> <span class=mi>1</span>

            <span class=n>C</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>k</span>

    <span class=c1># Normalize the cross-correlogram by dividing by the total observation time and bin size</span>
    <span class=n>C</span> <span class=o>=</span> <span class=n>C</span> <span class=o>/</span> <span class=p>(</span><span class=n>nt1</span> <span class=o>*</span> <span class=n>binsize</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>C</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.decode_file_path class="doc doc-heading"> <code class="highlight language-python"><span class=n>decode_file_path</span><span class=p>(</span><span class=n>save_file</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Decode an encoded file path to retrieve the original session path.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>save_file</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Encoded file path that includes the original session path.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Original session path before encoding.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>save_file</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;Z:\home\ryanh\projects\ripple_heterogeneity\replay_02_17_23\Z---___Data___AYAold___AB3___AB3_38_41.pkl&quot;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>decode_file_path</span><span class=p>(</span><span class=n>save_file</span><span class=p>)</span>
<span class=go>&quot;Z:\Data\AYAold\AB3\AB3_38_41&quot;</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/batch_analysis.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span>
<span class=normal>72</span>
<span class=normal>73</span>
<span class=normal>74</span>
<span class=normal>75</span>
<span class=normal>76</span>
<span class=normal>77</span>
<span class=normal>78</span>
<span class=normal>79</span>
<span class=normal>80</span>
<span class=normal>81</span>
<span class=normal>82</span>
<span class=normal>83</span>
<span class=normal>84</span>
<span class=normal>85</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>decode_file_path</span><span class=p>(</span><span class=n>save_file</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Decode an encoded file path to retrieve the original session path.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    save_file : str</span>
<span class=sd>        Encoded file path that includes the original session path.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    str</span>
<span class=sd>        Original session path before encoding.</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; save_file = r&quot;Z:\\home\\ryanh\\projects\\ripple_heterogeneity\\replay_02_17_23\\Z---___Data___AYAold___AB3___AB3_38_41.pkl&quot;</span>
<span class=sd>    &gt;&gt;&gt; decode_file_path(save_file)</span>
<span class=sd>    &quot;Z:\\Data\\AYAold\\AB3\\AB3_38_41&quot;</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># get basepath from save_file</span>
    <span class=n>basepath</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>basename</span><span class=p>(</span><span class=n>save_file</span><span class=p>)</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&quot;___&quot;</span><span class=p>,</span> <span class=s2>&quot;/&quot;</span><span class=p>)</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&quot;---&quot;</span><span class=p>,</span> <span class=s2>&quot;:&quot;</span><span class=p>)</span>
    <span class=c1># also remove file extension</span>
    <span class=n>basepath</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>splitext</span><span class=p>(</span><span class=n>basepath</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>

    <span class=c1># Convert to OS-appropriate path separators</span>
    <span class=n>basepath</span> <span class=o>=</span> <span class=n>basepath</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&quot;/&quot;</span><span class=p>,</span> <span class=n>os</span><span class=o>.</span><span class=n>sep</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>basepath</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.deconvolve_peth class="doc doc-heading"> <code class="highlight language-python"><span class=n>deconvolve_peth</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Perform deconvolution of a peri-event time histogram (PETH) signal.</p> <p>This function calculates the deconvolved signal based on the input signal and events.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>signal</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array representing the discrete events.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array representing the discrete events.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of a time bin in seconds (default is 0.002 seconds).</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins to use in the PETH (default is 100 bins).</p> </div> </td> <td> <code>100</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>deconvolved</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array representing the deconvolved signal.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>times</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array representing the time points corresponding to the bins.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>Based on DeconvolvePETH.m from https://github.com/ayalab1/neurocode/blob/master/spikes/DeconvolvePETH.m</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>271</span>
<span class=normal>272</span>
<span class=normal>273</span>
<span class=normal>274</span>
<span class=normal>275</span>
<span class=normal>276</span>
<span class=normal>277</span>
<span class=normal>278</span>
<span class=normal>279</span>
<span class=normal>280</span>
<span class=normal>281</span>
<span class=normal>282</span>
<span class=normal>283</span>
<span class=normal>284</span>
<span class=normal>285</span>
<span class=normal>286</span>
<span class=normal>287</span>
<span class=normal>288</span>
<span class=normal>289</span>
<span class=normal>290</span>
<span class=normal>291</span>
<span class=normal>292</span>
<span class=normal>293</span>
<span class=normal>294</span>
<span class=normal>295</span>
<span class=normal>296</span>
<span class=normal>297</span>
<span class=normal>298</span>
<span class=normal>299</span>
<span class=normal>300</span>
<span class=normal>301</span>
<span class=normal>302</span>
<span class=normal>303</span>
<span class=normal>304</span>
<span class=normal>305</span>
<span class=normal>306</span>
<span class=normal>307</span>
<span class=normal>308</span>
<span class=normal>309</span>
<span class=normal>310</span>
<span class=normal>311</span>
<span class=normal>312</span>
<span class=normal>313</span>
<span class=normal>314</span>
<span class=normal>315</span>
<span class=normal>316</span>
<span class=normal>317</span>
<span class=normal>318</span>
<span class=normal>319</span>
<span class=normal>320</span>
<span class=normal>321</span>
<span class=normal>322</span>
<span class=normal>323</span>
<span class=normal>324</span>
<span class=normal>325</span>
<span class=normal>326</span>
<span class=normal>327</span>
<span class=normal>328</span>
<span class=normal>329</span>
<span class=normal>330</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>deconvolve_peth</span><span class=p>(</span>
    <span class=n>signal</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Perform deconvolution of a peri-event time histogram (PETH) signal.</span>

<span class=sd>    This function calculates the deconvolved signal based on the input signal and events.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    signal : np.ndarray</span>
<span class=sd>        An array representing the discrete events.</span>
<span class=sd>    events : np.ndarray</span>
<span class=sd>        An array representing the discrete events.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        The width of a time bin in seconds (default is 0.002 seconds).</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        The number of bins to use in the PETH (default is 100 bins).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    deconvolved : np.ndarray</span>
<span class=sd>        An array representing the deconvolved signal.</span>
<span class=sd>    times : np.ndarray</span>
<span class=sd>        An array representing the time points corresponding to the bins.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Based on DeconvolvePETH.m from https://github.com/ayalab1/neurocode/blob/master/spikes/DeconvolvePETH.m</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># calculate time lags for peth</span>
    <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>

    <span class=c1># Calculate the autocorrelogram of the signal and the PETH of the events and the signal</span>
    <span class=n>autocorrelogram</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>raw_peth</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>events</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>

    <span class=c1># If raw_peth all zeros, return zeros</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>raw_peth</span><span class=o>.</span><span class=n>any</span><span class=p>():</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)),</span> <span class=n>times</span>

    <span class=c1># Subtract the mean value from the raw_peth</span>
    <span class=n>const</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>raw_peth</span><span class=p>)</span>
    <span class=n>raw_peth</span> <span class=o>=</span> <span class=n>raw_peth</span> <span class=o>-</span> <span class=n>const</span>

    <span class=c1># Calculate the Toeplitz matrix using the autocorrelogram and</span>
    <span class=c1>#   the cross-correlation of the autocorrelogram</span>
    <span class=n>T0</span> <span class=o>=</span> <span class=n>toeplitz</span><span class=p>(</span>
        <span class=n>autocorrelogram</span><span class=p>,</span>
        <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>([</span><span class=n>autocorrelogram</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>autocorrelogram</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)]),</span>
    <span class=p>)</span>
    <span class=n>T</span> <span class=o>=</span> <span class=n>T0</span><span class=p>[</span><span class=n>n_bins</span><span class=p>:,</span> <span class=p>:</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span>

    <span class=c1># Calculate the deconvolved signal by solving a linear equation</span>
    <span class=n>deconvolved</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>solve</span><span class=p>(</span>
        <span class=n>T</span><span class=p>,</span> <span class=n>raw_peth</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=p>:</span> <span class=nb>int</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span><span class=o>.</span><span class=n>T</span> <span class=o>+</span> <span class=n>const</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>)</span>
    <span class=p>)</span>

    <span class=k>return</span> <span class=n>deconvolved</span><span class=p>,</span> <span class=n>times</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.dpsschk class="doc doc-heading"> <code class="highlight language-python"><span class=n>dpsschk</span><span class=p>(</span><span class=n>tapers</span><span class=p>,</span> <span class=n>N</span><span class=p>,</span> <span class=n>Fs</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Check and generate DPSS tapers.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>tapers</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, <span title=typing.Tuple>Tuple</span>[<span title=float>float</span>, <span title=int>int</span>]]</code> </td> <td> <div class=doc-md-description> <p>Input can be either an array representing [NW, K] or a tuple with the number of tapers and the maximum number of tapers.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>N</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of points for FFT.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>Fs</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>tapers</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Tapers matrix, shape [tapers, eigenvalues].</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>The function computes DPSS (Discrete Prolate Spheroidal Sequences) tapers and scales them by the square root of the sampling frequency.</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>dpsschk</span><span class=p>(</span>
    <span class=n>tapers</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>int</span><span class=p>]],</span> <span class=n>N</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>Fs</span><span class=p>:</span> <span class=nb>float</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Check and generate DPSS tapers.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    tapers : Union[np.ndarray, Tuple[float, int]]</span>
<span class=sd>        Input can be either an array representing [NW, K] or a tuple with</span>
<span class=sd>        the number of tapers and the maximum number of tapers.</span>
<span class=sd>    N : int</span>
<span class=sd>        Number of points for FFT.</span>
<span class=sd>    Fs : float</span>
<span class=sd>        Sampling frequency.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    tapers : np.ndarray</span>
<span class=sd>        Tapers matrix, shape [tapers, eigenvalues].</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    The function computes DPSS (Discrete Prolate Spheroidal Sequences) tapers</span>
<span class=sd>    and scales them by the square root of the sampling frequency.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>tapers</span><span class=p>,</span> <span class=n>eigs</span> <span class=o>=</span> <span class=n>dpss</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>NW</span><span class=o>=</span><span class=n>tapers</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>Kmax</span><span class=o>=</span><span class=n>tapers</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>sym</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>return_ratios</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
    <span class=n>tapers</span> <span class=o>=</span> <span class=n>tapers</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>Fs</span><span class=p>)</span>
    <span class=n>tapers</span> <span class=o>=</span> <span class=n>tapers</span><span class=o>.</span><span class=n>T</span>
    <span class=k>return</span> <span class=n>tapers</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.encode_file_path class="doc doc-heading"> <code class="highlight language-python"><span class=n>encode_file_path</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>save_path</span><span class=p>,</span> <span class=n>format_type</span><span class=o>=</span><span class=s1>&#39;pickle&#39;</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Encode file path to be used as a filename.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>basepath</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Path to the session to be encoded.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>save_path</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Directory where the encoded file will be saved.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>format_type</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>File format type ("pickle" or "hdf5"). Defaults to "pickle".</p> </div> </td> <td> <code>&#39;pickle&#39;</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Encoded file path suitable for use as a filename.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>basepath</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;Z:\Data\AYAold\AB3\AB3_38_41&quot;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>save_path</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;Z:\home\ryanh\projects\ripple_heterogeneity\replay_02_17_23&quot;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>encode_file_path</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>save_path</span><span class=p>)</span>
<span class=go>&quot;Z:\home\ryanh\projects\ripple_heterogeneity\replay_02_17_23\Z---___Data___AYAold___AB3___AB3_38_41.pkl&quot;</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/batch_analysis.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>encode_file_path</span><span class=p>(</span><span class=n>basepath</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>save_path</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>format_type</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&quot;pickle&quot;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Encode file path to be used as a filename.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    basepath : str</span>
<span class=sd>        Path to the session to be encoded.</span>
<span class=sd>    save_path : str</span>
<span class=sd>        Directory where the encoded file will be saved.</span>
<span class=sd>    format_type : str, optional</span>
<span class=sd>        File format type (&quot;pickle&quot; or &quot;hdf5&quot;). Defaults to &quot;pickle&quot;.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    str</span>
<span class=sd>        Encoded file path suitable for use as a filename.</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; basepath = r&quot;Z:\\Data\\AYAold\\AB3\\AB3_38_41&quot;</span>
<span class=sd>    &gt;&gt;&gt; save_path = r&quot;Z:\\home\\ryanh\\projects\\ripple_heterogeneity\\replay_02_17_23&quot;</span>
<span class=sd>    &gt;&gt;&gt; encode_file_path(basepath, save_path)</span>
<span class=sd>    &quot;Z:\\home\\ryanh\\projects\\ripple_heterogeneity\\replay_02_17_23\\Z---___Data___AYAold___AB3___AB3_38_41.pkl&quot;</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Normalize path separators to forward slashes for consistent encoding</span>
    <span class=n>basepath</span> <span class=o>=</span> <span class=n>basepath</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&quot;</span><span class=se>\\</span><span class=s2>&quot;</span><span class=p>,</span> <span class=s2>&quot;/&quot;</span><span class=p>)</span>
    <span class=n>save_path</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>normpath</span><span class=p>(</span><span class=n>save_path</span><span class=p>)</span>

    <span class=c1># Encode with consistent separators</span>
    <span class=n>encoded_name</span> <span class=o>=</span> <span class=n>basepath</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&quot;/&quot;</span><span class=p>,</span> <span class=s2>&quot;___&quot;</span><span class=p>)</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&quot;:&quot;</span><span class=p>,</span> <span class=s2>&quot;---&quot;</span><span class=p>)</span>

    <span class=c1># Add extension</span>
    <span class=n>extension</span> <span class=o>=</span> <span class=s2>&quot;.h5&quot;</span> <span class=k>if</span> <span class=n>format_type</span> <span class=o>==</span> <span class=s2>&quot;hdf5&quot;</span> <span class=k>else</span> <span class=s2>&quot;.pkl&quot;</span>
    <span class=n>encoded_name</span> <span class=o>+=</span> <span class=n>extension</span>

    <span class=c1># Join using os.path.join for proper OS-specific path joining</span>
    <span class=k>return</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>save_path</span><span class=p>,</span> <span class=n>encoded_name</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.event_spiking_threshold class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_spiking_threshold</span><span class=p>(</span><span class=n>spikes</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>event_size</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>spiking_thres</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>binsize</span><span class=o>=</span><span class=mf>0.01</span><span class=p>,</span> <span class=n>sigma</span><span class=o>=</span><span class=mf>0.02</span><span class=p>,</span> <span class=n>min_units</span><span class=o>=</span><span class=mi>6</span><span class=p>,</span> <span class=n>show_fig</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>event_spiking_threshold: filter events based on spiking threshold</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>spikes</code> </td> <td> <code><span title=nel.SpikeTrainArray>SpikeTrainArray</span></code> </td> <td> <div class=doc-md-description> <p>Spike train array of neurons.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Event times in seconds.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code>list of float</code> </td> <td> <div class=doc-md-description> <p>Time window (in seconds) to compute event-triggered average, by default [-0.5, 0.5].</p> </div> </td> <td> <code>[-0.5, 0.5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>event_size</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Time window (in seconds) around event to measure firing response, by default 0.1.</p> </div> </td> <td> <code>0.1</code> </td> </tr> <tr class=doc-section-item> <td> <code>spiking_thres</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Spiking threshold in z-score units, by default 0.</p> </div> </td> <td> <code>0</code> </td> </tr> <tr class=doc-section-item> <td> <code>binsize</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Bin size (in seconds) for time-binning the spike trains, by default 0.01.</p> </div> </td> <td> <code>0.01</code> </td> </tr> <tr class=doc-section-item> <td> <code>sigma</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Standard deviation (in seconds) for Gaussian smoothing of spike counts, by default 0.02.</p> </div> </td> <td> <code>0.02</code> </td> </tr> <tr class=doc-section-item> <td> <code>min_units</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Minimum number of units required to compute event-triggered average, by default 6.</p> </div> </td> <td> <code>6</code> </td> </tr> <tr class=doc-section-item> <td> <code>show_fig</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, plots the figure of event-triggered spiking activity, by default False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Boolean array indicating valid events that meet the spiking threshold.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>basepath</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;U:\data\hpc_ctx_project\HP04\day_32_20240430&quot;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>ripples</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_ripples_events</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span>
<span class=go>        basepath,</span>
<span class=go>        brainRegion=&quot;CA1&quot;,</span>
<span class=go>        support=nel.EpochArray([0, loading.load_epoch(basepath).iloc[-1].stopTime])</span>
<span class=go>    )</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>idx</span> <span class=o>=</span> <span class=n>event_spiking_threshold</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>ripples</span><span class=o>.</span><span class=n>peaks</span><span class=o>.</span><span class=n>values</span><span class=p>,</span> <span class=n>show_fig</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Number of valid ripples: </span><span class=si>{</span><span class=n>idx</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span><span class=si>}</span><span class=s2> out of </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>ripples</span><span class=p>)</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=go>Number of valid ripples: 9244 out of 12655</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1194</span>
<span class=normal>1195</span>
<span class=normal>1196</span>
<span class=normal>1197</span>
<span class=normal>1198</span>
<span class=normal>1199</span>
<span class=normal>1200</span>
<span class=normal>1201</span>
<span class=normal>1202</span>
<span class=normal>1203</span>
<span class=normal>1204</span>
<span class=normal>1205</span>
<span class=normal>1206</span>
<span class=normal>1207</span>
<span class=normal>1208</span>
<span class=normal>1209</span>
<span class=normal>1210</span>
<span class=normal>1211</span>
<span class=normal>1212</span>
<span class=normal>1213</span>
<span class=normal>1214</span>
<span class=normal>1215</span>
<span class=normal>1216</span>
<span class=normal>1217</span>
<span class=normal>1218</span>
<span class=normal>1219</span>
<span class=normal>1220</span>
<span class=normal>1221</span>
<span class=normal>1222</span>
<span class=normal>1223</span>
<span class=normal>1224</span>
<span class=normal>1225</span>
<span class=normal>1226</span>
<span class=normal>1227</span>
<span class=normal>1228</span>
<span class=normal>1229</span>
<span class=normal>1230</span>
<span class=normal>1231</span>
<span class=normal>1232</span>
<span class=normal>1233</span>
<span class=normal>1234</span>
<span class=normal>1235</span>
<span class=normal>1236</span>
<span class=normal>1237</span>
<span class=normal>1238</span>
<span class=normal>1239</span>
<span class=normal>1240</span>
<span class=normal>1241</span>
<span class=normal>1242</span>
<span class=normal>1243</span>
<span class=normal>1244</span>
<span class=normal>1245</span>
<span class=normal>1246</span>
<span class=normal>1247</span>
<span class=normal>1248</span>
<span class=normal>1249</span>
<span class=normal>1250</span>
<span class=normal>1251</span>
<span class=normal>1252</span>
<span class=normal>1253</span>
<span class=normal>1254</span>
<span class=normal>1255</span>
<span class=normal>1256</span>
<span class=normal>1257</span>
<span class=normal>1258</span>
<span class=normal>1259</span>
<span class=normal>1260</span>
<span class=normal>1261</span>
<span class=normal>1262</span>
<span class=normal>1263</span>
<span class=normal>1264</span>
<span class=normal>1265</span>
<span class=normal>1266</span>
<span class=normal>1267</span>
<span class=normal>1268</span>
<span class=normal>1269</span>
<span class=normal>1270</span>
<span class=normal>1271</span>
<span class=normal>1272</span>
<span class=normal>1273</span>
<span class=normal>1274</span>
<span class=normal>1275</span>
<span class=normal>1276</span>
<span class=normal>1277</span>
<span class=normal>1278</span>
<span class=normal>1279</span>
<span class=normal>1280</span>
<span class=normal>1281</span>
<span class=normal>1282</span>
<span class=normal>1283</span>
<span class=normal>1284</span>
<span class=normal>1285</span>
<span class=normal>1286</span>
<span class=normal>1287</span>
<span class=normal>1288</span>
<span class=normal>1289</span>
<span class=normal>1290</span>
<span class=normal>1291</span>
<span class=normal>1292</span>
<span class=normal>1293</span>
<span class=normal>1294</span>
<span class=normal>1295</span>
<span class=normal>1296</span>
<span class=normal>1297</span>
<span class=normal>1298</span>
<span class=normal>1299</span>
<span class=normal>1300</span>
<span class=normal>1301</span>
<span class=normal>1302</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_spiking_threshold</span><span class=p>(</span>
    <span class=n>spikes</span><span class=p>:</span> <span class=n>SpikeTrainArray</span><span class=p>,</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=nb>list</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
    <span class=n>event_size</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.1</span><span class=p>,</span>
    <span class=n>spiking_thres</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
    <span class=n>binsize</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.01</span><span class=p>,</span>
    <span class=n>sigma</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.02</span><span class=p>,</span>
    <span class=n>min_units</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>6</span><span class=p>,</span>
    <span class=n>show_fig</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    event_spiking_threshold: filter events based on spiking threshold</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    spikes : nel.SpikeTrainArray</span>
<span class=sd>        Spike train array of neurons.</span>
<span class=sd>    events : np.ndarray</span>
<span class=sd>        Event times in seconds.</span>
<span class=sd>    window : list of float, optional</span>
<span class=sd>        Time window (in seconds) to compute event-triggered average, by default [-0.5, 0.5].</span>
<span class=sd>    event_size : float, optional</span>
<span class=sd>        Time window (in seconds) around event to measure firing response, by default 0.1.</span>
<span class=sd>    spiking_thres : float, optional</span>
<span class=sd>        Spiking threshold in z-score units, by default 0.</span>
<span class=sd>    binsize : float, optional</span>
<span class=sd>        Bin size (in seconds) for time-binning the spike trains, by default 0.01.</span>
<span class=sd>    sigma : float, optional</span>
<span class=sd>        Standard deviation (in seconds) for Gaussian smoothing of spike counts, by default 0.02.</span>
<span class=sd>    min_units : int, optional</span>
<span class=sd>        Minimum number of units required to compute event-triggered average, by default 6.</span>
<span class=sd>    show_fig : bool, optional</span>
<span class=sd>        If True, plots the figure of event-triggered spiking activity, by default False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        Boolean array indicating valid events that meet the spiking threshold.</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; basepath = r&quot;U:\\data\\hpc_ctx_project\\HP04\\day_32_20240430&quot;</span>
<span class=sd>    &gt;&gt;&gt; ripples = loading.load_ripples_events(basepath, return_epoch_array=False)</span>
<span class=sd>    &gt;&gt;&gt; st, cell_metrics = loading.load_spikes(</span>
<span class=sd>            basepath,</span>
<span class=sd>            brainRegion=&quot;CA1&quot;,</span>
<span class=sd>            support=nel.EpochArray([0, loading.load_epoch(basepath).iloc[-1].stopTime])</span>
<span class=sd>        )</span>
<span class=sd>    &gt;&gt;&gt; idx = event_spiking_threshold(st, ripples.peaks.values, show_fig=True)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;Number of valid ripples: {idx.sum()} out of {len(ripples)}&quot;)</span>
<span class=sd>    Number of valid ripples: 9244 out of 12655</span>

<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># check if there are enough units to compute a confident event triggered average</span>
    <span class=k>if</span> <span class=n>spikes</span><span class=o>.</span><span class=n>n_active</span> <span class=o>&lt;</span> <span class=n>min_units</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>bool</span><span class=p>)</span>

    <span class=c1># bin spikes</span>
    <span class=n>bst</span> <span class=o>=</span> <span class=n>spikes</span><span class=o>.</span><span class=n>bin</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=n>binsize</span><span class=p>)</span><span class=o>.</span><span class=n>smooth</span><span class=p>(</span><span class=n>sigma</span><span class=o>=</span><span class=n>sigma</span><span class=p>)</span>
    <span class=c1># sum over all neurons and zscore</span>
    <span class=n>bst</span> <span class=o>=</span> <span class=n>bst</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
    <span class=n>bst</span> <span class=o>=</span> <span class=p>(</span><span class=n>bst</span> <span class=o>-</span> <span class=n>bst</span><span class=o>.</span><span class=n>mean</span><span class=p>())</span> <span class=o>/</span> <span class=n>bst</span><span class=o>.</span><span class=n>std</span><span class=p>()</span>
    <span class=c1># get event triggered average</span>
    <span class=n>avg_signal</span><span class=p>,</span> <span class=n>time_lags</span> <span class=o>=</span> <span class=n>event_triggered_average_fast</span><span class=p>(</span>
        <span class=n>bst</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>,</span> <span class=p>:],</span>
        <span class=n>events</span><span class=p>,</span>
        <span class=n>sampling_rate</span><span class=o>=</span><span class=nb>int</span><span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=n>binsize</span><span class=p>),</span>
        <span class=n>window</span><span class=o>=</span><span class=n>window</span><span class=p>,</span>
        <span class=n>return_average</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
    <span class=p>)</span>
    <span class=c1># get the event response within the event size</span>
    <span class=n>idx</span> <span class=o>=</span> <span class=p>(</span><span class=n>time_lags</span> <span class=o>&gt;=</span> <span class=o>-</span><span class=n>event_size</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>time_lags</span> <span class=o>&lt;=</span> <span class=n>event_size</span><span class=p>)</span>
    <span class=n>event_response</span> <span class=o>=</span> <span class=n>avg_signal</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=n>idx</span><span class=p>,</span> <span class=p>:]</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

    <span class=c1># get events that are above threshold</span>
    <span class=n>valid_events</span> <span class=o>=</span> <span class=n>event_response</span> <span class=o>&gt;</span> <span class=n>spiking_thres</span>

    <span class=k>if</span> <span class=n>show_fig</span><span class=p>:</span>
        <span class=kn>import</span><span class=w> </span><span class=nn>matplotlib.pyplot</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>plt</span>
        <span class=kn>import</span><span class=w> </span><span class=nn>seaborn</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>sns</span>

        <span class=n>sorted_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>event_response</span><span class=p>)</span>

        <span class=n>fig</span><span class=p>,</span> <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>5</span><span class=p>),</span> <span class=n>sharey</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span>
            <span class=n>avg_signal</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=p>:,</span> <span class=n>sorted_idx</span><span class=p>],</span>
            <span class=n>aspect</span><span class=o>=</span><span class=s2>&quot;auto&quot;</span><span class=p>,</span>
            <span class=n>extent</span><span class=o>=</span><span class=p>[</span><span class=n>time_lags</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>time_lags</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>event_response</span><span class=p>)],</span>
            <span class=n>vmin</span><span class=o>=-</span><span class=mi>2</span><span class=p>,</span>
            <span class=n>vmax</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span>
            <span class=n>origin</span><span class=o>=</span><span class=s2>&quot;lower&quot;</span><span class=p>,</span>
            <span class=n>interpolation</span><span class=o>=</span><span class=s2>&quot;nearest&quot;</span><span class=p>,</span>
        <span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>axhline</span><span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span><span class=n>event_response</span><span class=p>[</span><span class=n>sorted_idx</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>spiking_thres</span><span class=p>)[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span>
            <span class=n>color</span><span class=o>=</span><span class=s2>&quot;r&quot;</span><span class=p>,</span>
            <span class=n>linestyle</span><span class=o>=</span><span class=s2>&quot;--&quot;</span><span class=p>,</span>
        <span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>event_response</span><span class=p>[</span><span class=n>sorted_idx</span><span class=p>],</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>event_response</span><span class=p>)))</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>axvline</span><span class=p>(</span><span class=n>spiking_thres</span><span class=p>,</span> <span class=n>color</span><span class=o>=</span><span class=s2>&quot;r&quot;</span><span class=p>,</span> <span class=n>linestyle</span><span class=o>=</span><span class=s2>&quot;--&quot;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=s2>&quot;Time from event (s)&quot;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=s2>&quot;Event index&quot;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=s2>&quot;Average response&quot;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=s2>&quot;Event index&quot;</span><span class=p>)</span>
        <span class=n>sns</span><span class=o>.</span><span class=n>despine</span><span class=p>()</span>

    <span class=k>return</span> <span class=n>valid_events</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.event_triggered_average class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_triggered_average</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>sampling_rate</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>return_average</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>return_pandas</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Calculates the event-triggered averages of signals in a time window relative to the event times of corresponding events for multiple signals.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>timestamps</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of timestamps corresponding to the signal samples.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>signal</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array of shape (n_samples, n_signals) containing the signal values.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, <span title=typing.List>List</span>[<span title=numpy.ndarray>ndarray</span>]]</code> </td> <td> <div class=doc-md-description> <p>One or more 1D arrays of event times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>sampling_rate</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=float>float</span>, None]</code> </td> <td> <div class=doc-md-description> <p>The sampling rate of the signal. If not provided, it will be calculated based on the timestamps.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=typing.List>List</span>[<span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>A list containing two elements: the start and stop times relative to an event for the time interval of signal averaging. Default is [-0.5, 0.5].</p> </div> </td> <td> <code>[-0.5, 0.5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_average</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to return the average of the event-triggered average. Defaults to True. If False, returns the full event-triggered average matrix (n_samples x n_signals x n_events).</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_pandas</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, return the result as a Pandas DataFrame. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, <span title=pandas.DataFrame>DataFrame</span>]</code> </td> <td> <div class=doc-md-description> <p>If <code>return_average</code> is True, returns the event-triggered averages of the signals (n_samples, n_signals) or a Pandas DataFrame if <code>return_pandas</code> is True. If <code>return_average</code> is False, returns the full event-triggered average matrix (n_samples, n_signals, n_events).</p> </div> </td> </tr> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time lags corresponding to the event-triggered averages.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <ul> <li>The function filters out events that do not fit within the valid range of the signal considering the specified window size.</li> <li>If the <code>sampling_rate</code> is not provided, it is calculated based on the timestamps.</li> <li>The function handles both regular and irregular sampling of the signal.</li> </ul> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>peth_avg</span><span class=p>,</span> <span class=n>time_lags</span> <span class=o>=</span> <span class=n>event_triggered_average</span><span class=p>(</span>
<span class=gp>... </span>   <span class=n>timestamps</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>]</span>
<span class=gp>... </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># Get individual event responses</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_matrix</span><span class=p>,</span> <span class=n>time_lags</span> <span class=o>=</span> <span class=n>event_triggered_average</span><span class=p>(</span>
<span class=gp>... </span>   <span class=n>timestamps</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>return_average</span><span class=o>=</span><span class=kc>False</span>
<span class=gp>... </span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>509</span>
<span class=normal>510</span>
<span class=normal>511</span>
<span class=normal>512</span>
<span class=normal>513</span>
<span class=normal>514</span>
<span class=normal>515</span>
<span class=normal>516</span>
<span class=normal>517</span>
<span class=normal>518</span>
<span class=normal>519</span>
<span class=normal>520</span>
<span class=normal>521</span>
<span class=normal>522</span>
<span class=normal>523</span>
<span class=normal>524</span>
<span class=normal>525</span>
<span class=normal>526</span>
<span class=normal>527</span>
<span class=normal>528</span>
<span class=normal>529</span>
<span class=normal>530</span>
<span class=normal>531</span>
<span class=normal>532</span>
<span class=normal>533</span>
<span class=normal>534</span>
<span class=normal>535</span>
<span class=normal>536</span>
<span class=normal>537</span>
<span class=normal>538</span>
<span class=normal>539</span>
<span class=normal>540</span>
<span class=normal>541</span>
<span class=normal>542</span>
<span class=normal>543</span>
<span class=normal>544</span>
<span class=normal>545</span>
<span class=normal>546</span>
<span class=normal>547</span>
<span class=normal>548</span>
<span class=normal>549</span>
<span class=normal>550</span>
<span class=normal>551</span>
<span class=normal>552</span>
<span class=normal>553</span>
<span class=normal>554</span>
<span class=normal>555</span>
<span class=normal>556</span>
<span class=normal>557</span>
<span class=normal>558</span>
<span class=normal>559</span>
<span class=normal>560</span>
<span class=normal>561</span>
<span class=normal>562</span>
<span class=normal>563</span>
<span class=normal>564</span>
<span class=normal>565</span>
<span class=normal>566</span>
<span class=normal>567</span>
<span class=normal>568</span>
<span class=normal>569</span>
<span class=normal>570</span>
<span class=normal>571</span>
<span class=normal>572</span>
<span class=normal>573</span>
<span class=normal>574</span>
<span class=normal>575</span>
<span class=normal>576</span>
<span class=normal>577</span>
<span class=normal>578</span>
<span class=normal>579</span>
<span class=normal>580</span>
<span class=normal>581</span>
<span class=normal>582</span>
<span class=normal>583</span>
<span class=normal>584</span>
<span class=normal>585</span>
<span class=normal>586</span>
<span class=normal>587</span>
<span class=normal>588</span>
<span class=normal>589</span>
<span class=normal>590</span>
<span class=normal>591</span>
<span class=normal>592</span>
<span class=normal>593</span>
<span class=normal>594</span>
<span class=normal>595</span>
<span class=normal>596</span>
<span class=normal>597</span>
<span class=normal>598</span>
<span class=normal>599</span>
<span class=normal>600</span>
<span class=normal>601</span>
<span class=normal>602</span>
<span class=normal>603</span>
<span class=normal>604</span>
<span class=normal>605</span>
<span class=normal>606</span>
<span class=normal>607</span>
<span class=normal>608</span>
<span class=normal>609</span>
<span class=normal>610</span>
<span class=normal>611</span>
<span class=normal>612</span>
<span class=normal>613</span>
<span class=normal>614</span>
<span class=normal>615</span>
<span class=normal>616</span>
<span class=normal>617</span>
<span class=normal>618</span>
<span class=normal>619</span>
<span class=normal>620</span>
<span class=normal>621</span>
<span class=normal>622</span>
<span class=normal>623</span>
<span class=normal>624</span>
<span class=normal>625</span>
<span class=normal>626</span>
<span class=normal>627</span>
<span class=normal>628</span>
<span class=normal>629</span>
<span class=normal>630</span>
<span class=normal>631</span>
<span class=normal>632</span>
<span class=normal>633</span>
<span class=normal>634</span>
<span class=normal>635</span>
<span class=normal>636</span>
<span class=normal>637</span>
<span class=normal>638</span>
<span class=normal>639</span>
<span class=normal>640</span>
<span class=normal>641</span>
<span class=normal>642</span>
<span class=normal>643</span>
<span class=normal>644</span>
<span class=normal>645</span>
<span class=normal>646</span>
<span class=normal>647</span>
<span class=normal>648</span>
<span class=normal>649</span>
<span class=normal>650</span>
<span class=normal>651</span>
<span class=normal>652</span>
<span class=normal>653</span>
<span class=normal>654</span>
<span class=normal>655</span>
<span class=normal>656</span>
<span class=normal>657</span>
<span class=normal>658</span>
<span class=normal>659</span>
<span class=normal>660</span>
<span class=normal>661</span>
<span class=normal>662</span>
<span class=normal>663</span>
<span class=normal>664</span>
<span class=normal>665</span>
<span class=normal>666</span>
<span class=normal>667</span>
<span class=normal>668</span>
<span class=normal>669</span>
<span class=normal>670</span>
<span class=normal>671</span>
<span class=normal>672</span>
<span class=normal>673</span>
<span class=normal>674</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_triggered_average</span><span class=p>(</span>
    <span class=n>timestamps</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>signal</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>List</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]],</span>
    <span class=n>sampling_rate</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
    <span class=n>return_average</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
    <span class=n>return_pandas</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>],</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Calculates the event-triggered averages of signals in a time window</span>
<span class=sd>    relative to the event times of corresponding events for multiple signals.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    timestamps : np.ndarray</span>
<span class=sd>        A 1D array of timestamps corresponding to the signal samples.</span>
<span class=sd>    signal : np.ndarray</span>
<span class=sd>        A 2D array of shape (n_samples, n_signals) containing the signal values.</span>
<span class=sd>    events : Union[np.ndarray, List[np.ndarray]]</span>
<span class=sd>        One or more 1D arrays of event times.</span>
<span class=sd>    sampling_rate : Union[float, None], optional</span>
<span class=sd>        The sampling rate of the signal. If not provided, it will be calculated</span>
<span class=sd>        based on the timestamps.</span>
<span class=sd>    window : List[float], optional</span>
<span class=sd>        A list containing two elements: the start and stop times relative to an event</span>
<span class=sd>        for the time interval of signal averaging. Default is [-0.5, 0.5].</span>
<span class=sd>    return_average : bool, optional</span>
<span class=sd>        Whether to return the average of the event-triggered average. Defaults to True.</span>
<span class=sd>        If False, returns the full event-triggered average matrix (n_samples x n_signals x n_events).</span>
<span class=sd>    return_pandas : bool, optional</span>
<span class=sd>        If True, return the result as a Pandas DataFrame. Default is False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Union[np.ndarray, pd.DataFrame]</span>
<span class=sd>        If `return_average` is True, returns the event-triggered averages of the signals</span>
<span class=sd>        (n_samples, n_signals) or a Pandas DataFrame if `return_pandas` is True.</span>
<span class=sd>        If `return_average` is False, returns the full event-triggered average matrix</span>
<span class=sd>        (n_samples, n_signals, n_events).</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        An array of time lags corresponding to the event-triggered averages.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    - The function filters out events that do not fit within the valid range of the signal</span>
<span class=sd>    considering the specified window size.</span>
<span class=sd>    - If the `sampling_rate` is not provided, it is calculated based on the timestamps.</span>
<span class=sd>    - The function handles both regular and irregular sampling of the signal.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; peth_avg, time_lags = event_triggered_average(</span>
<span class=sd>    ...    timestamps, signal, events, window=[-0.5, 0.5]</span>
<span class=sd>    ... )</span>
<span class=sd>    &gt;&gt;&gt; # Get individual event responses</span>
<span class=sd>    &gt;&gt;&gt; peth_matrix, time_lags = event_triggered_average(</span>
<span class=sd>    ...    timestamps, signal, events, window=[-0.5, 0.5], return_average=False</span>
<span class=sd>    ... )</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Basic input validation</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>window</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>2</span> <span class=ow>or</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;&#39;window&#39; must be [start, stop] with start &lt; stop&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
        <span class=n>signal</span> <span class=o>=</span> <span class=n>signal</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>sampling_rate</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>sampling_rate</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>stats</span><span class=o>.</span><span class=n>mode</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>timestamps</span><span class=p>),</span> <span class=n>keepdims</span><span class=o>=</span><span class=kc>True</span><span class=p>)[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>

    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>events</span><span class=p>,</span> <span class=nb>list</span><span class=p>):</span>
        <span class=n>events</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>events</span><span class=p>)</span>

    <span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span> <span class=o>=</span> <span class=n>window</span>
    <span class=n>window_bins</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(((</span><span class=n>window_stoptime</span> <span class=o>-</span> <span class=n>window_starttime</span><span class=p>)</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)))</span>
    <span class=n>time_lags</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span><span class=p>,</span> <span class=n>window_bins</span><span class=p>)</span>

    <span class=c1># Filter events that fit within the signal range</span>
    <span class=n>min_timestamp</span><span class=p>,</span> <span class=n>max_timestamp</span> <span class=o>=</span> <span class=n>timestamps</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>timestamps</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
    <span class=n>valid_mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>events</span> <span class=o>+</span> <span class=n>window_starttime</span> <span class=o>&gt;=</span> <span class=n>min_timestamp</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span>
        <span class=n>events</span> <span class=o>+</span> <span class=n>window_stoptime</span> <span class=o>&lt;=</span> <span class=n>max_timestamp</span>
    <span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>valid_mask</span><span class=p>):</span>
        <span class=n>warnings</span><span class=o>.</span><span class=n>warn</span><span class=p>(</span><span class=s2>&quot;No events found within the valid signal range&quot;</span><span class=p>)</span>
        <span class=n>empty_shape</span> <span class=o>=</span> <span class=p>(</span><span class=n>window_bins</span><span class=p>,</span> <span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
        <span class=k>if</span> <span class=n>return_average</span><span class=p>:</span>
            <span class=n>result</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=n>empty_shape</span><span class=p>)</span>
            <span class=k>return</span> <span class=p>(</span>
                <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>index</span><span class=o>=</span><span class=n>time_lags</span><span class=p>)</span> <span class=k>if</span> <span class=n>return_pandas</span> <span class=k>else</span> <span class=n>result</span>
            <span class=p>),</span> <span class=n>time_lags</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>full</span><span class=p>(</span><span class=n>empty_shape</span> <span class=o>+</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>),),</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>),</span> <span class=n>time_lags</span>

    <span class=c1># Initialize result matrix: (window_bins, n_signals, n_events) - keep all events</span>
    <span class=n>result_matrix</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>full</span><span class=p>((</span><span class=n>window_bins</span><span class=p>,</span> <span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>)),</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>)</span>

    <span class=c1># For regular sampling, use fast indexing approach similar to event_triggered_average_fast</span>
    <span class=n>dt</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>median</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>timestamps</span><span class=p>))</span>
    <span class=n>is_regular_sampling</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>allclose</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>timestamps</span><span class=p>),</span> <span class=n>dt</span><span class=p>,</span> <span class=n>rtol</span><span class=o>=</span><span class=mf>1e-3</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>is_regular_sampling</span><span class=p>:</span>
        <span class=c1># Fast path: regular sampling - use direct indexing like event_triggered_average_fast</span>
        <span class=c1># Match the exact indexing logic from event_triggered_average_fast</span>
        <span class=n>start_time</span> <span class=o>=</span> <span class=n>timestamps</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># Cache start time for efficiency</span>
        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>event</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>events</span><span class=p>):</span>
            <span class=k>if</span> <span class=ow>not</span> <span class=n>valid_mask</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>  <span class=c1># Skip invalid events (already filled with NaN)</span>
                <span class=k>continue</span>

            <span class=c1># Convert event time to sample indices, accounting for timestamp start time</span>
            <span class=n>event_sample</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>round</span><span class=p>((</span><span class=n>event</span> <span class=o>-</span> <span class=n>start_time</span><span class=p>)</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)</span>
            <span class=n>ts_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span>
                <span class=n>event_sample</span> <span class=o>-</span> <span class=n>window_bins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span>
                <span class=n>event_sample</span> <span class=o>+</span> <span class=n>window_bins</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span>
            <span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>

            <span class=c1># Check bounds</span>
            <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>ts_idx</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>ts_idx</span><span class=p>)</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>signal</span><span class=p>):</span>
                <span class=n>result_matrix</span><span class=p>[:,</span> <span class=p>:,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>signal</span><span class=p>[</span><span class=n>ts_idx</span><span class=p>,</span> <span class=p>:]</span>
            <span class=c1># If bounds check fails, keep as NaN (already initialized)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=c1># Slow path: irregular sampling - use interpolation but vectorized</span>
        <span class=n>target_times_template</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span><span class=p>,</span> <span class=n>window_bins</span>
        <span class=p>)</span>

        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>event</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>events</span><span class=p>):</span>
            <span class=k>if</span> <span class=ow>not</span> <span class=n>valid_mask</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>  <span class=c1># Skip invalid events (already filled with NaN)</span>
                <span class=k>continue</span>

            <span class=n>target_times</span> <span class=o>=</span> <span class=n>target_times_template</span> <span class=o>+</span> <span class=n>event</span>

            <span class=c1># Find the range of timestamps that covers our target times</span>
            <span class=n>start_search</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span>
                <span class=n>timestamps</span><span class=p>,</span> <span class=n>target_times</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>dt</span><span class=p>,</span> <span class=n>side</span><span class=o>=</span><span class=s2>&quot;left&quot;</span>
            <span class=p>)</span>
            <span class=n>stop_search</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span>
                <span class=n>timestamps</span><span class=p>,</span> <span class=n>target_times</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dt</span><span class=p>,</span> <span class=n>side</span><span class=o>=</span><span class=s2>&quot;right&quot;</span>
            <span class=p>)</span>

            <span class=k>if</span> <span class=n>start_search</span> <span class=o>&gt;=</span> <span class=n>stop_search</span><span class=p>:</span>
                <span class=c1># Keep as NaN (already initialized)</span>
                <span class=k>continue</span>

            <span class=c1># Extract relevant data for this event</span>
            <span class=n>event_timestamps</span> <span class=o>=</span> <span class=n>timestamps</span><span class=p>[</span><span class=n>start_search</span><span class=p>:</span><span class=n>stop_search</span><span class=p>]</span>
            <span class=n>event_signal</span> <span class=o>=</span> <span class=n>signal</span><span class=p>[</span><span class=n>start_search</span><span class=p>:</span><span class=n>stop_search</span><span class=p>,</span> <span class=p>:]</span>

            <span class=c1># Vectorized interpolation for all channels at once</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>event_timestamps</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]):</span>
                    <span class=n>result_matrix</span><span class=p>[:,</span> <span class=n>j</span><span class=p>,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span>
                        <span class=n>target_times</span><span class=p>,</span> <span class=n>event_timestamps</span><span class=p>,</span> <span class=n>event_signal</span><span class=p>[:,</span> <span class=n>j</span><span class=p>]</span>
                    <span class=p>)</span>
            <span class=c1># If interpolation fails, keep as NaN (already initialized)</span>

    <span class=c1># Return results</span>
    <span class=k>if</span> <span class=n>return_average</span><span class=p>:</span>
        <span class=n>result_avg</span> <span class=o>=</span> <span class=n>bn</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>result_matrix</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>return_pandas</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span>
                <span class=n>result_avg</span><span class=p>,</span> <span class=n>index</span><span class=o>=</span><span class=n>time_lags</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
            <span class=p>)</span>
        <span class=k>return</span> <span class=n>result_avg</span><span class=p>,</span> <span class=n>time_lags</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>result_matrix</span><span class=p>,</span> <span class=n>time_lags</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.event_triggered_average_fast class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_triggered_average_fast</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>sampling_rate</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>return_average</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>return_pandas</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Calculate the event-triggered average of a signal.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>signal</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array of signal data with shape (channels, timepoints).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>events</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of event times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>sampling_rate</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The sampling rate of the signal in Hz.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=list>list</span>, <span title=typing.Tuple>Tuple</span>[<span title=float>float</span>, <span title=float>float</span>]]</code> </td> <td> <div class=doc-md-description> <p>A list or tuple specifying the time window (in seconds) to average the signal around each event. Defaults to [-0.5, 0.5].</p> </div> </td> <td> <code>[-0.5, 0.5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_average</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to return the average of the event-triggered average. Defaults to True. If False, returns the full event-triggered average matrix (channels x timepoints x events).</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_pandas</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, returns the average as a Pandas DataFrame. Defaults to False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, <span title=pandas.DataFrame>DataFrame</span>]</code> </td> <td> <div class=doc-md-description> <p>If <code>return_average</code> is True, returns the event-triggered average of the signal (channels x timepoints) or a Pandas DataFrame if <code>return_pandas</code> is True. If <code>return_average</code> is False, returns the full event-triggered average matrix (channels x timebins x events).</p> </div> </td> </tr> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time lags corresponding to the event-triggered averages.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <ul> <li>The function filters out events that do not fit within the valid range of the signal considering the specified window size.</li> <li>Assumes the signal starts at time 0.</li> </ul> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>677</span>
<span class=normal>678</span>
<span class=normal>679</span>
<span class=normal>680</span>
<span class=normal>681</span>
<span class=normal>682</span>
<span class=normal>683</span>
<span class=normal>684</span>
<span class=normal>685</span>
<span class=normal>686</span>
<span class=normal>687</span>
<span class=normal>688</span>
<span class=normal>689</span>
<span class=normal>690</span>
<span class=normal>691</span>
<span class=normal>692</span>
<span class=normal>693</span>
<span class=normal>694</span>
<span class=normal>695</span>
<span class=normal>696</span>
<span class=normal>697</span>
<span class=normal>698</span>
<span class=normal>699</span>
<span class=normal>700</span>
<span class=normal>701</span>
<span class=normal>702</span>
<span class=normal>703</span>
<span class=normal>704</span>
<span class=normal>705</span>
<span class=normal>706</span>
<span class=normal>707</span>
<span class=normal>708</span>
<span class=normal>709</span>
<span class=normal>710</span>
<span class=normal>711</span>
<span class=normal>712</span>
<span class=normal>713</span>
<span class=normal>714</span>
<span class=normal>715</span>
<span class=normal>716</span>
<span class=normal>717</span>
<span class=normal>718</span>
<span class=normal>719</span>
<span class=normal>720</span>
<span class=normal>721</span>
<span class=normal>722</span>
<span class=normal>723</span>
<span class=normal>724</span>
<span class=normal>725</span>
<span class=normal>726</span>
<span class=normal>727</span>
<span class=normal>728</span>
<span class=normal>729</span>
<span class=normal>730</span>
<span class=normal>731</span>
<span class=normal>732</span>
<span class=normal>733</span>
<span class=normal>734</span>
<span class=normal>735</span>
<span class=normal>736</span>
<span class=normal>737</span>
<span class=normal>738</span>
<span class=normal>739</span>
<span class=normal>740</span>
<span class=normal>741</span>
<span class=normal>742</span>
<span class=normal>743</span>
<span class=normal>744</span>
<span class=normal>745</span>
<span class=normal>746</span>
<span class=normal>747</span>
<span class=normal>748</span>
<span class=normal>749</span>
<span class=normal>750</span>
<span class=normal>751</span>
<span class=normal>752</span>
<span class=normal>753</span>
<span class=normal>754</span>
<span class=normal>755</span>
<span class=normal>756</span>
<span class=normal>757</span>
<span class=normal>758</span>
<span class=normal>759</span>
<span class=normal>760</span>
<span class=normal>761</span>
<span class=normal>762</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_triggered_average_fast</span><span class=p>(</span>
    <span class=n>signal</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>events</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>sampling_rate</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>list</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]]</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
    <span class=n>return_average</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
    <span class=n>return_pandas</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>],</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Calculate the event-triggered average of a signal.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    signal : np.ndarray</span>
<span class=sd>        A 2D array of signal data with shape (channels, timepoints).</span>

<span class=sd>    events : np.ndarray</span>
<span class=sd>        A 1D array of event times.</span>

<span class=sd>    sampling_rate : int</span>
<span class=sd>        The sampling rate of the signal in Hz.</span>

<span class=sd>    window : Union[list, Tuple[float, float]], optional</span>
<span class=sd>        A list or tuple specifying the time window (in seconds) to average the signal</span>
<span class=sd>        around each event. Defaults to [-0.5, 0.5].</span>

<span class=sd>    return_average : bool, optional</span>
<span class=sd>        Whether to return the average of the event-triggered average. Defaults to True.</span>
<span class=sd>        If False, returns the full event-triggered average matrix (channels x timepoints x events).</span>

<span class=sd>    return_pandas : bool, optional</span>
<span class=sd>        If True, returns the average as a Pandas DataFrame. Defaults to False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Union[np.ndarray, pd.DataFrame]</span>
<span class=sd>        If `return_average` is True, returns the event-triggered average of the signal</span>
<span class=sd>        (channels x timepoints) or a Pandas DataFrame if `return_pandas` is True.</span>
<span class=sd>        If `return_average` is False, returns the full event-triggered average matrix (channels x timebins x events).</span>

<span class=sd>    np.ndarray</span>
<span class=sd>        An array of time lags corresponding to the event-triggered averages.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    - The function filters out events that do not fit within the valid range of the signal</span>
<span class=sd>    considering the specified window size.</span>
<span class=sd>    - Assumes the signal starts at time 0.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span> <span class=o>=</span> <span class=n>window</span>
    <span class=n>window_bins</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(((</span><span class=n>window_stoptime</span> <span class=o>-</span> <span class=n>window_starttime</span><span class=p>)</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)))</span>
    <span class=n>time_lags</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=n>window_starttime</span><span class=p>,</span> <span class=n>window_stoptime</span><span class=p>,</span> <span class=n>window_bins</span><span class=p>)</span>

    <span class=c1># Create valid mask instead of filtering events</span>
    <span class=n>valid_mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>events</span> <span class=o>*</span> <span class=n>sampling_rate</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span>
        <span class=n>events</span> <span class=o>*</span> <span class=n>sampling_rate</span> <span class=o>&lt;</span> <span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span>
    <span class=p>)</span>

    <span class=c1># Initialize result matrix with all events, filled with NaN</span>
    <span class=n>avg_signal</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>full</span><span class=p>(</span>
        <span class=p>[</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>events</span><span class=p>)],</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>signal</span><span class=o>.</span><span class=n>dtype</span>
    <span class=p>)</span>

    <span class=c1># Process only valid events</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>event</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>events</span><span class=p>):</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=n>valid_mask</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>  <span class=c1># Skip invalid events (already filled with NaN)</span>
            <span class=k>continue</span>

        <span class=n>ts_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>round</span><span class=p>(</span><span class=n>event</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span>
            <span class=n>np</span><span class=o>.</span><span class=n>round</span><span class=p>(</span><span class=n>event</span> <span class=o>*</span> <span class=n>sampling_rate</span><span class=p>)</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span>
        <span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>
        <span class=n>avg_signal</span><span class=p>[:,</span> <span class=p>:,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>signal</span><span class=p>[:,</span> <span class=n>ts_idx</span><span class=p>]</span>

    <span class=k>if</span> <span class=n>return_pandas</span> <span class=ow>and</span> <span class=n>return_average</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span>
            <span class=n>index</span><span class=o>=</span><span class=n>time_lags</span><span class=p>,</span>
            <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>signal</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span>
            <span class=n>data</span><span class=o>=</span><span class=n>bn</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>avg_signal</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span><span class=o>.</span><span class=n>T</span><span class=p>,</span>
        <span class=p>)</span>

    <span class=k>if</span> <span class=n>return_average</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>bn</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>avg_signal</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>2</span><span class=p>),</span> <span class=n>time_lags</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>avg_signal</span><span class=p>,</span> <span class=n>time_lags</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.event_triggered_average_irregular_sample class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_triggered_average_irregular_sample</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the average and standard deviation of data values within a window around each reference time, specifically for irregularly sampled data.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>timestamps</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of times associated with data.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of data values.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_ref</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of reference times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of each bin in the window, in seconds. Default is 0.002 seconds.</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins in the window. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=tuple>tuple</span>, None]</code> </td> <td> <div class=doc-md-description> <p>A tuple containing the start and end times of the window to be plotted around each reference time. If not provided, the window will be centered around each reference time and have a width of <code>n_bins * bin_width</code> seconds.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Tuple>Tuple</span>[<span title=pandas.DataFrame>DataFrame</span>, <span title=pandas.DataFrame>DataFrame</span>]</code> </td> <td> <div class=doc-md-description> <p>Two DataFrames: the first containing the average values, the second the standard deviation of data values within the window around each reference time.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>436</span>
<span class=normal>437</span>
<span class=normal>438</span>
<span class=normal>439</span>
<span class=normal>440</span>
<span class=normal>441</span>
<span class=normal>442</span>
<span class=normal>443</span>
<span class=normal>444</span>
<span class=normal>445</span>
<span class=normal>446</span>
<span class=normal>447</span>
<span class=normal>448</span>
<span class=normal>449</span>
<span class=normal>450</span>
<span class=normal>451</span>
<span class=normal>452</span>
<span class=normal>453</span>
<span class=normal>454</span>
<span class=normal>455</span>
<span class=normal>456</span>
<span class=normal>457</span>
<span class=normal>458</span>
<span class=normal>459</span>
<span class=normal>460</span>
<span class=normal>461</span>
<span class=normal>462</span>
<span class=normal>463</span>
<span class=normal>464</span>
<span class=normal>465</span>
<span class=normal>466</span>
<span class=normal>467</span>
<span class=normal>468</span>
<span class=normal>469</span>
<span class=normal>470</span>
<span class=normal>471</span>
<span class=normal>472</span>
<span class=normal>473</span>
<span class=normal>474</span>
<span class=normal>475</span>
<span class=normal>476</span>
<span class=normal>477</span>
<span class=normal>478</span>
<span class=normal>479</span>
<span class=normal>480</span>
<span class=normal>481</span>
<span class=normal>482</span>
<span class=normal>483</span>
<span class=normal>484</span>
<span class=normal>485</span>
<span class=normal>486</span>
<span class=normal>487</span>
<span class=normal>488</span>
<span class=normal>489</span>
<span class=normal>490</span>
<span class=normal>491</span>
<span class=normal>492</span>
<span class=normal>493</span>
<span class=normal>494</span>
<span class=normal>495</span>
<span class=normal>496</span>
<span class=normal>497</span>
<span class=normal>498</span>
<span class=normal>499</span>
<span class=normal>500</span>
<span class=normal>501</span>
<span class=normal>502</span>
<span class=normal>503</span>
<span class=normal>504</span>
<span class=normal>505</span>
<span class=normal>506</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_triggered_average_irregular_sample</span><span class=p>(</span>
    <span class=n>timestamps</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>time_ref</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>tuple</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>,</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the average and standard deviation of data values within a window around</span>
<span class=sd>    each reference time, specifically for irregularly sampled data.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    timestamps : np.ndarray</span>
<span class=sd>        A 1D array of times associated with data.</span>
<span class=sd>    data : np.ndarray</span>
<span class=sd>        A 1D array of data values.</span>
<span class=sd>    time_ref : np.ndarray</span>
<span class=sd>        A 1D array of reference times.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        The width of each bin in the window, in seconds. Default is 0.002 seconds.</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        The number of bins in the window. Default is 100.</span>
<span class=sd>    window : Union[tuple, None], optional</span>
<span class=sd>        A tuple containing the start and end times of the window to be plotted around each reference time.</span>
<span class=sd>        If not provided, the window will be centered around each reference time and have a</span>
<span class=sd>        width of `n_bins * bin_width` seconds.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Tuple[pd.DataFrame, pd.DataFrame]</span>
<span class=sd>        Two DataFrames: the first containing the average values, the second the</span>
<span class=sd>        standard deviation of data values within the window around each reference time.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=p>)</span>
    <span class=n>x</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>y</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>time_ref</span><span class=p>):</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=p>(</span><span class=n>timestamps</span> <span class=o>&gt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>times</span><span class=o>.</span><span class=n>min</span><span class=p>())</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>timestamps</span> <span class=o>&lt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>times</span><span class=o>.</span><span class=n>max</span><span class=p>())</span>
        <span class=n>x</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>timestamps</span> <span class=o>-</span> <span class=n>r</span><span class=p>)[</span><span class=n>idx</span><span class=p>])</span>
        <span class=n>y</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span>

    <span class=n>temp_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>()</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>temp_df</span><span class=p>,</span> <span class=n>temp_df</span>
    <span class=n>temp_df</span><span class=p>[</span><span class=s2>&quot;time&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
    <span class=n>temp_df</span><span class=p>[</span><span class=s2>&quot;data&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
    <span class=n>temp_df</span> <span class=o>=</span> <span class=n>temp_df</span><span class=o>.</span><span class=n>sort_values</span><span class=p>(</span><span class=n>by</span><span class=o>=</span><span class=s2>&quot;time&quot;</span><span class=p>,</span> <span class=n>ascending</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

    <span class=n>average_val</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
    <span class=n>std_val</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
        <span class=n>average_val</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp_df</span><span class=p>[</span>
            <span class=n>temp_df</span><span class=o>.</span><span class=n>time</span><span class=o>.</span><span class=n>between</span><span class=p>(</span><span class=n>times</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>times</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span>
        <span class=p>]</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>mean</span><span class=p>()</span>
        <span class=n>std_val</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp_df</span><span class=p>[</span><span class=n>temp_df</span><span class=o>.</span><span class=n>time</span><span class=o>.</span><span class=n>between</span><span class=p>(</span><span class=n>times</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>times</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])]</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>std</span><span class=p>()</span>

    <span class=n>avg</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>avg</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>average_val</span>

    <span class=n>std</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>std</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>std_val</span>

    <span class=k>return</span> <span class=n>avg</span><span class=p>,</span> <span class=n>std</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.event_triggered_cross_correlation class="doc doc-heading"> <code class="highlight language-python"><span class=n>event_triggered_cross_correlation</span><span class=p>(</span><span class=n>event_times</span><span class=p>,</span> <span class=n>signal1_data</span><span class=p>,</span> <span class=n>signal1_ts</span><span class=p>,</span> <span class=n>signal2_data</span><span class=p>,</span> <span class=n>signal2_ts</span><span class=p>,</span> <span class=n>time_lags</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.005</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Computes the cross-correlation between two signals at specific event times</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>event_times</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>array of event times</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>signal1_data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>data of signal 1</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>signal1_ts</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>timestamps of signal 1</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>signal2_data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>data of signal 2</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>signal2_ts</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>timestamps of signal 2</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_lags</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, None]</code> </td> <td> <div class=doc-md-description> <p>array of time lags to compute correlation. If None, it will be computed automatically.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>window to compute correlation. Default is [-0.5, 0.5]</p> </div> </td> <td> <code>[-0.5, 0.5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>bin width to compute correlation. Ideally this should be the same as the sampling rate. Default is 0.005</p> </div> </td> <td> <code>0.005</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>correlation_lags</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>array of time lags in ascending order (negative to positive)</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>avg_correlation</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>array of correlation values corresponding to each lag</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>The function computes cross-correlation between signal1 and signal2 around event times. The interpretation of lags is as follows:</p> <ul> <li><strong>Negative lags</strong>: signal2 leads signal1 (signal2 peaks occur before signal1 peaks)</li> <li><strong>Zero lag</strong>: signals are synchronized</li> <li><strong>Positive lags</strong>: signal2 lags behind signal1 (signal2 peaks occur after signal1 peaks)</li> </ul> <p>Peak correlation at positive lag indicates signal2 is a delayed version of signal1. Peak correlation at negative lag indicates signal2 precedes or predicts signal1.</p> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>lags</span><span class=p>,</span> <span class=n>corr</span> <span class=o>=</span> <span class=n>event_triggered_cross_correlation</span><span class=p>(</span><span class=n>event_times</span><span class=p>,</span> <span class=n>signal1_data</span><span class=p>,</span> <span class=n>signal1_ts</span><span class=p>,</span> <span class=n>signal2_data</span><span class=p>,</span> <span class=n>signal2_ts</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peak_lag</span> <span class=o>=</span> <span class=n>lags</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>corr</span><span class=p>))]</span>  <span class=c1># Find lag with maximum correlation</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/correlations.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>262</span>
<span class=normal>263</span>
<span class=normal>264</span>
<span class=normal>265</span>
<span class=normal>266</span>
<span class=normal>267</span>
<span class=normal>268</span>
<span class=normal>269</span>
<span class=normal>270</span>
<span class=normal>271</span>
<span class=normal>272</span>
<span class=normal>273</span>
<span class=normal>274</span>
<span class=normal>275</span>
<span class=normal>276</span>
<span class=normal>277</span>
<span class=normal>278</span>
<span class=normal>279</span>
<span class=normal>280</span>
<span class=normal>281</span>
<span class=normal>282</span>
<span class=normal>283</span>
<span class=normal>284</span>
<span class=normal>285</span>
<span class=normal>286</span>
<span class=normal>287</span>
<span class=normal>288</span>
<span class=normal>289</span>
<span class=normal>290</span>
<span class=normal>291</span>
<span class=normal>292</span>
<span class=normal>293</span>
<span class=normal>294</span>
<span class=normal>295</span>
<span class=normal>296</span>
<span class=normal>297</span>
<span class=normal>298</span>
<span class=normal>299</span>
<span class=normal>300</span>
<span class=normal>301</span>
<span class=normal>302</span>
<span class=normal>303</span>
<span class=normal>304</span>
<span class=normal>305</span>
<span class=normal>306</span>
<span class=normal>307</span>
<span class=normal>308</span>
<span class=normal>309</span>
<span class=normal>310</span>
<span class=normal>311</span>
<span class=normal>312</span>
<span class=normal>313</span>
<span class=normal>314</span>
<span class=normal>315</span>
<span class=normal>316</span>
<span class=normal>317</span>
<span class=normal>318</span>
<span class=normal>319</span>
<span class=normal>320</span>
<span class=normal>321</span>
<span class=normal>322</span>
<span class=normal>323</span>
<span class=normal>324</span>
<span class=normal>325</span>
<span class=normal>326</span>
<span class=normal>327</span>
<span class=normal>328</span>
<span class=normal>329</span>
<span class=normal>330</span>
<span class=normal>331</span>
<span class=normal>332</span>
<span class=normal>333</span>
<span class=normal>334</span>
<span class=normal>335</span>
<span class=normal>336</span>
<span class=normal>337</span>
<span class=normal>338</span>
<span class=normal>339</span>
<span class=normal>340</span>
<span class=normal>341</span>
<span class=normal>342</span>
<span class=normal>343</span>
<span class=normal>344</span>
<span class=normal>345</span>
<span class=normal>346</span>
<span class=normal>347</span>
<span class=normal>348</span>
<span class=normal>349</span>
<span class=normal>350</span>
<span class=normal>351</span>
<span class=normal>352</span>
<span class=normal>353</span>
<span class=normal>354</span>
<span class=normal>355</span>
<span class=normal>356</span>
<span class=normal>357</span>
<span class=normal>358</span>
<span class=normal>359</span>
<span class=normal>360</span>
<span class=normal>361</span>
<span class=normal>362</span>
<span class=normal>363</span>
<span class=normal>364</span>
<span class=normal>365</span>
<span class=normal>366</span>
<span class=normal>367</span>
<span class=normal>368</span>
<span class=normal>369</span>
<span class=normal>370</span>
<span class=normal>371</span>
<span class=normal>372</span>
<span class=normal>373</span>
<span class=normal>374</span>
<span class=normal>375</span>
<span class=normal>376</span>
<span class=normal>377</span>
<span class=normal>378</span>
<span class=normal>379</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>event_triggered_cross_correlation</span><span class=p>(</span>
    <span class=n>event_times</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>signal1_data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>signal1_ts</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>signal2_data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>signal2_ts</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>time_lags</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=nb>list</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.005</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Computes the cross-correlation between two signals at specific event times</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    event_times : np.ndarray</span>
<span class=sd>        array of event times</span>
<span class=sd>    signal1_data : np.ndarray</span>
<span class=sd>        data of signal 1</span>
<span class=sd>    signal1_ts : np.ndarray</span>
<span class=sd>        timestamps of signal 1</span>
<span class=sd>    signal2_data : np.ndarray</span>
<span class=sd>        data of signal 2</span>
<span class=sd>    signal2_ts : np.ndarray</span>
<span class=sd>        timestamps of signal 2</span>
<span class=sd>    time_lags : Union[np.ndarray, None], optional</span>
<span class=sd>        array of time lags to compute correlation. If None, it will be computed automatically.</span>
<span class=sd>    window : list, optional</span>
<span class=sd>        window to compute correlation. Default is [-0.5, 0.5]</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        bin width to compute correlation. Ideally this should be the same as the sampling rate.</span>
<span class=sd>        Default is 0.005</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    correlation_lags : np.ndarray</span>
<span class=sd>        array of time lags in ascending order (negative to positive)</span>
<span class=sd>    avg_correlation : np.ndarray</span>
<span class=sd>        array of correlation values corresponding to each lag</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    The function computes cross-correlation between signal1 and signal2 around event times.</span>
<span class=sd>    The interpretation of lags is as follows:</span>

<span class=sd>    - **Negative lags**: signal2 leads signal1 (signal2 peaks occur before signal1 peaks)</span>
<span class=sd>    - **Zero lag**: signals are synchronized</span>
<span class=sd>    - **Positive lags**: signal2 lags behind signal1 (signal2 peaks occur after signal1 peaks)</span>

<span class=sd>    Peak correlation at positive lag indicates signal2 is a delayed version of signal1.</span>
<span class=sd>    Peak correlation at negative lag indicates signal2 precedes or predicts signal1.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; lags, corr = event_triggered_cross_correlation(event_times, signal1_data, signal1_ts, signal2_data, signal2_ts)</span>
<span class=sd>    &gt;&gt;&gt; peak_lag = lags[np.argmax(np.abs(corr))]  # Find lag with maximum correlation</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=n>time_lags</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>time_lags</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>bin_width</span><span class=p>)</span>

    <span class=c1># Interpolate both signals at event times + all possible lags</span>
    <span class=n>n_events</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>event_times</span><span class=p>)</span>
    <span class=n>n_lags</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags</span><span class=p>)</span>

    <span class=c1># Handle empty event times case</span>
    <span class=k>if</span> <span class=n>n_events</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=n>max_lag_samples</span> <span class=o>=</span> <span class=n>n_lags</span> <span class=o>-</span> <span class=mi>1</span>
        <span class=n>correlation_lags</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=o>-</span><span class=n>max_lag_samples</span><span class=p>,</span> <span class=n>max_lag_samples</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span>
            <span class=n>time_lags</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>time_lags</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=p>)</span>
        <span class=c1># Create zero correlation array</span>
        <span class=n>avg_correlation</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>n_lags</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

        <span class=c1># restrict to window</span>
        <span class=n>avg_correlation</span> <span class=o>=</span> <span class=n>avg_correlation</span><span class=p>[</span>
            <span class=p>(</span><span class=n>correlation_lags</span> <span class=o>&gt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>correlation_lags</span> <span class=o>&lt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
        <span class=p>]</span>
        <span class=n>correlation_lags</span> <span class=o>=</span> <span class=n>correlation_lags</span><span class=p>[</span>
            <span class=p>(</span><span class=n>correlation_lags</span> <span class=o>&gt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>correlation_lags</span> <span class=o>&lt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
        <span class=p>]</span>

        <span class=k>return</span> <span class=n>correlation_lags</span><span class=p>,</span> <span class=n>avg_correlation</span>

    <span class=c1># Create time matrix: events x lags</span>
    <span class=n>event_times_matrix</span> <span class=o>=</span> <span class=n>event_times</span><span class=p>[:,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>+</span> <span class=n>time_lags</span><span class=p>[</span><span class=kc>None</span><span class=p>,</span> <span class=p>:]</span>

    <span class=c1># Interpolate both signals</span>
    <span class=n>signal1_matrix</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span>
        <span class=n>event_times_matrix</span><span class=o>.</span><span class=n>flatten</span><span class=p>(),</span> <span class=n>signal1_ts</span><span class=p>,</span> <span class=n>signal1_data</span>
    <span class=p>)</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=n>n_events</span><span class=p>,</span> <span class=n>n_lags</span><span class=p>)</span>
    <span class=n>signal2_matrix</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span>
        <span class=n>event_times_matrix</span><span class=o>.</span><span class=n>flatten</span><span class=p>(),</span> <span class=n>signal2_ts</span><span class=p>,</span> <span class=n>signal2_data</span>
    <span class=p>)</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=n>n_events</span><span class=p>,</span> <span class=n>n_lags</span><span class=p>)</span>

    <span class=c1># Compute cross-correlation for each event</span>
    <span class=n>correlations</span> <span class=o>=</span> <span class=n>_jit_event_corr</span><span class=p>(</span><span class=n>signal1_matrix</span><span class=p>,</span> <span class=n>signal2_matrix</span><span class=p>)</span>

    <span class=c1># Average across events</span>
    <span class=n>avg_correlation</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>correlations</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

    <span class=c1># Create lag axis for the correlation result in ascending order</span>
    <span class=n>max_lag_samples</span> <span class=o>=</span> <span class=n>n_lags</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=n>correlation_lags</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=o>-</span><span class=n>max_lag_samples</span><span class=p>,</span> <span class=n>max_lag_samples</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span>
        <span class=n>time_lags</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>time_lags</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=p>)</span>
    <span class=c1># Reverse the correlation array to match the ascending lag order</span>
    <span class=n>avg_correlation</span> <span class=o>=</span> <span class=n>avg_correlation</span><span class=p>[::</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>

    <span class=c1># restrict to window</span>
    <span class=n>avg_correlation</span> <span class=o>=</span> <span class=n>avg_correlation</span><span class=p>[</span>
        <span class=p>(</span><span class=n>correlation_lags</span> <span class=o>&gt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>correlation_lags</span> <span class=o>&lt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=p>]</span>
    <span class=n>correlation_lags</span> <span class=o>=</span> <span class=n>correlation_lags</span><span class=p>[</span>
        <span class=p>(</span><span class=n>correlation_lags</span> <span class=o>&gt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>correlation_lags</span> <span class=o>&lt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=p>]</span>

    <span class=k>return</span> <span class=n>correlation_lags</span><span class=p>,</span> <span class=n>avg_correlation</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.fast_acf class="doc doc-heading"> <code class="highlight language-python"><span class=n>fast_acf</span><span class=p>(</span><span class=n>counts</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>cut_peak</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the Auto-Correlation Function (ACF) in a fast manner using Numba.</p> <p>This function calculates the ACF of a given variable of interest, such as spike times or spike phases, leveraging the <code>pcorrelate</code> function for efficiency.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>counts</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of the variable of interest (e.g., spike times or spike phases).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Time window for the ACF computation.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Width of the bins for the ACF.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>cut_peak</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, the largest central peak will be replaced for subsequent fitting. Default is True.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>acf</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of counts for the ACF.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>bins</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of lag bins for the ACF.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <ul> <li>The ACF is calculated over a specified time window and returns the counts of the ACF along with the corresponding bins.</li> <li>The <code>cut_peak</code> parameter allows for the adjustment of the ACF peak, which can be useful for fitting processes.</li> </ul> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/precession_utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>334</span>
<span class=normal>335</span>
<span class=normal>336</span>
<span class=normal>337</span>
<span class=normal>338</span>
<span class=normal>339</span>
<span class=normal>340</span>
<span class=normal>341</span>
<span class=normal>342</span>
<span class=normal>343</span>
<span class=normal>344</span>
<span class=normal>345</span>
<span class=normal>346</span>
<span class=normal>347</span>
<span class=normal>348</span>
<span class=normal>349</span>
<span class=normal>350</span>
<span class=normal>351</span>
<span class=normal>352</span>
<span class=normal>353</span>
<span class=normal>354</span>
<span class=normal>355</span>
<span class=normal>356</span>
<span class=normal>357</span>
<span class=normal>358</span>
<span class=normal>359</span>
<span class=normal>360</span>
<span class=normal>361</span>
<span class=normal>362</span>
<span class=normal>363</span>
<span class=normal>364</span>
<span class=normal>365</span>
<span class=normal>366</span>
<span class=normal>367</span>
<span class=normal>368</span>
<span class=normal>369</span>
<span class=normal>370</span>
<span class=normal>371</span>
<span class=normal>372</span>
<span class=normal>373</span>
<span class=normal>374</span>
<span class=normal>375</span>
<span class=normal>376</span>
<span class=normal>377</span>
<span class=normal>378</span>
<span class=normal>379</span>
<span class=normal>380</span>
<span class=normal>381</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>fast_acf</span><span class=p>(</span>
    <span class=n>counts</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>width</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>cut_peak</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the Auto-Correlation Function (ACF) in a fast manner using Numba.</span>

<span class=sd>    This function calculates the ACF of a given variable of interest, such as</span>
<span class=sd>    spike times or spike phases, leveraging the `pcorrelate` function for efficiency.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    counts : np.ndarray</span>
<span class=sd>        1D array of the variable of interest (e.g., spike times or spike phases).</span>
<span class=sd>    width : float</span>
<span class=sd>        Time window for the ACF computation.</span>
<span class=sd>    bin_width : float</span>
<span class=sd>        Width of the bins for the ACF.</span>
<span class=sd>    cut_peak : bool, optional</span>
<span class=sd>        If True, the largest central peak will be replaced for subsequent fitting. Default is True.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    acf : np.ndarray</span>
<span class=sd>        1D array of counts for the ACF.</span>
<span class=sd>    bins : np.ndarray</span>
<span class=sd>        1D array of lag bins for the ACF.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    - The ACF is calculated over a specified time window and returns the</span>
<span class=sd>      counts of the ACF along with the corresponding bins.</span>
<span class=sd>    - The `cut_peak` parameter allows for the adjustment of the ACF peak, which</span>
<span class=sd>      can be useful for fitting processes.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>n_b</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=n>width</span> <span class=o>/</span> <span class=n>bin_width</span><span class=p>))</span>  <span class=c1># Num. edges per side</span>
    <span class=c1># Define the edges of the bins (including rightmost bin)</span>
    <span class=n>bins</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=o>-</span><span class=n>width</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>n_b</span><span class=p>,</span> <span class=n>endpoint</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
    <span class=n>temp</span> <span class=o>=</span> <span class=n>pcorrelate</span><span class=p>(</span><span class=n>counts</span><span class=p>,</span> <span class=n>counts</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=n>bins</span><span class=p>,</span> <span class=mi>2</span><span class=p>)[</span><span class=mi>1</span><span class=p>])</span>
    <span class=n>acf</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=n>bins</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
    <span class=n>acf</span><span class=p>[</span><span class=mi>0</span> <span class=p>:</span> <span class=n>temp</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>flip</span><span class=p>(</span><span class=n>temp</span><span class=p>)</span>
    <span class=n>acf</span><span class=p>[</span><span class=n>temp</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>acf</span><span class=p>[</span><span class=n>temp</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>:]</span> <span class=o>=</span> <span class=n>temp</span>

    <span class=k>if</span> <span class=n>cut_peak</span><span class=p>:</span>
        <span class=n>acf</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>nanargmax</span><span class=p>(</span><span class=n>acf</span><span class=p>)]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>acf</span><span class=p>)[</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>

    <span class=k>return</span> <span class=n>acf</span><span class=p>,</span> <span class=n>bins</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.find_intersecting_intervals class="doc doc-heading"> <code class="highlight language-python"><span class=n>find_intersecting_intervals</span><span class=p>(</span><span class=n>set1</span><span class=p>,</span> <span class=n>set2</span><span class=p>,</span> <span class=n>return_indices</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Find the amount of time two sets of intervals are intersecting each other for each intersection.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>set1</code> </td> <td> <code>nelpy EpochArray</code> </td> <td> <div class=doc-md-description> <p>The first set of intervals to check for intersections.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>set2</code> </td> <td> <code>nelpy EpochArray</code> </td> <td> <div class=doc-md-description> <p>The second set of intervals to check for intersections.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>return_indices</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, return the indices of the intervals in set2 that intersect with each interval in set1. If False, return the amount of time each interval in set1 intersects with any interval in set2.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, <span title=typing.List>List</span>[<span title=bool>bool</span>]]</code> </td> <td> <div class=doc-md-description> <p>If return_indices is True, returns a boolean array indicating whether each interval in set1 intersects with any interval in set2. If return_indices is False, returns a NumPy array with the amount of time each interval in set1 intersects with any interval in set2.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>set1</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>([(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>),</span> <span class=p>(</span><span class=mi>9</span><span class=p>,</span> <span class=mi>10</span><span class=p>)])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>set2</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>([(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>),</span> <span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>)])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>find_intersecting_intervals</span><span class=p>(</span><span class=n>set1</span><span class=p>,</span> <span class=n>set2</span><span class=p>)</span>
<span class=go>[True, True, False]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>find_intersecting_intervals</span><span class=p>(</span><span class=n>set1</span><span class=p>,</span> <span class=n>set2</span><span class=p>,</span> <span class=n>return_indices</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=go>[1, 2, 0]</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>221</span>
<span class=normal>222</span>
<span class=normal>223</span>
<span class=normal>224</span>
<span class=normal>225</span>
<span class=normal>226</span>
<span class=normal>227</span>
<span class=normal>228</span>
<span class=normal>229</span>
<span class=normal>230</span>
<span class=normal>231</span>
<span class=normal>232</span>
<span class=normal>233</span>
<span class=normal>234</span>
<span class=normal>235</span>
<span class=normal>236</span>
<span class=normal>237</span>
<span class=normal>238</span>
<span class=normal>239</span>
<span class=normal>240</span>
<span class=normal>241</span>
<span class=normal>242</span>
<span class=normal>243</span>
<span class=normal>244</span>
<span class=normal>245</span>
<span class=normal>246</span>
<span class=normal>247</span>
<span class=normal>248</span>
<span class=normal>249</span>
<span class=normal>250</span>
<span class=normal>251</span>
<span class=normal>252</span>
<span class=normal>253</span>
<span class=normal>254</span>
<span class=normal>255</span>
<span class=normal>256</span>
<span class=normal>257</span>
<span class=normal>258</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>find_intersecting_intervals</span><span class=p>(</span>
    <span class=n>set1</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span> <span class=n>set2</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span> <span class=n>return_indices</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>List</span><span class=p>[</span><span class=nb>bool</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Find the amount of time two sets of intervals are intersecting each other for each intersection.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    set1 : nelpy EpochArray</span>
<span class=sd>        The first set of intervals to check for intersections.</span>
<span class=sd>    set2 : nelpy EpochArray</span>
<span class=sd>        The second set of intervals to check for intersections.</span>
<span class=sd>    return_indices : bool, optional</span>
<span class=sd>        If True, return the indices of the intervals in set2 that intersect with each interval in set1.</span>
<span class=sd>        If False, return the amount of time each interval in set1 intersects with any interval in set2.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Union[np.ndarray, List[bool]]</span>
<span class=sd>        If return_indices is True, returns a boolean array indicating whether each interval in set1 intersects with any interval in set2.</span>
<span class=sd>        If return_indices is False, returns a NumPy array with the amount of time each interval in set1 intersects with any interval in set2.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; set1 = nel.EpochArray([(1, 3), (5, 7), (9, 10)])</span>
<span class=sd>    &gt;&gt;&gt; set2 = nel.EpochArray([(2, 4), (6, 8)])</span>
<span class=sd>    &gt;&gt;&gt; find_intersecting_intervals(set1, set2)</span>
<span class=sd>    [True, True, False]</span>
<span class=sd>    &gt;&gt;&gt; find_intersecting_intervals(set1, set2, return_indices=False)</span>
<span class=sd>    [1, 2, 0]</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>set1</span><span class=p>,</span> <span class=n>core</span><span class=o>.</span><span class=n>IntervalArray</span><span class=p>)</span> <span class=o>&amp;</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>set2</span><span class=p>,</span> <span class=n>core</span><span class=o>.</span><span class=n>IntervalArray</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;only EpochArrays are supported&quot;</span><span class=p>)</span>

    <span class=n>intersection</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>_find_intersecting_intervals</span><span class=p>(</span><span class=n>set1</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>set2</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
    <span class=k>if</span> <span class=n>return_indices</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>intersection</span> <span class=o>&gt;</span> <span class=mi>0</span>
    <span class=k>return</span> <span class=n>intersection</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.find_interval class="doc doc-heading"> <code class="highlight language-python"><span class=n>find_interval</span><span class=p>(</span><span class=n>logical</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Find consecutive intervals of True values in a list of boolean values.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>logical</code> </td> <td> <code><span title=typing.List>List</span>[<span title=bool>bool</span>]</code> </td> <td> <div class=doc-md-description> <p>The list of boolean values.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.List>List</span>[<span title=typing.Tuple>Tuple</span>[<span title=int>int</span>, <span title=int>int</span>]]</code> </td> <td> <div class=doc-md-description> <p>A list of tuples representing the start and end indices of each consecutive interval of True values in the logical list.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>find_interval</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>
<span class=go>[(2, 4), (6, 7), (10, 11)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>find_interval</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>
<span class=go>[(0, 2), (4, 5), (9, 10)]</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>261</span>
<span class=normal>262</span>
<span class=normal>263</span>
<span class=normal>264</span>
<span class=normal>265</span>
<span class=normal>266</span>
<span class=normal>267</span>
<span class=normal>268</span>
<span class=normal>269</span>
<span class=normal>270</span>
<span class=normal>271</span>
<span class=normal>272</span>
<span class=normal>273</span>
<span class=normal>274</span>
<span class=normal>275</span>
<span class=normal>276</span>
<span class=normal>277</span>
<span class=normal>278</span>
<span class=normal>279</span>
<span class=normal>280</span>
<span class=normal>281</span>
<span class=normal>282</span>
<span class=normal>283</span>
<span class=normal>284</span>
<span class=normal>285</span>
<span class=normal>286</span>
<span class=normal>287</span>
<span class=normal>288</span>
<span class=normal>289</span>
<span class=normal>290</span>
<span class=normal>291</span>
<span class=normal>292</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>find_interval</span><span class=p>(</span><span class=n>logical</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>bool</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=n>Tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Find consecutive intervals of True values in a list of boolean values.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    logical : List[bool]</span>
<span class=sd>        The list of boolean values.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    List[Tuple[int, int]]</span>
<span class=sd>        A list of tuples representing the start and end indices of each consecutive interval of True values in the logical list.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; find_interval([0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1])</span>
<span class=sd>    [(2, 4), (6, 7), (10, 11)]</span>
<span class=sd>    &gt;&gt;&gt; find_interval([1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1])</span>
<span class=sd>    [(0, 2), (4, 5), (9, 10)]</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>intervals</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>start</span> <span class=o>=</span> <span class=kc>None</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>value</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>logical</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>value</span> <span class=ow>and</span> <span class=n>start</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>start</span> <span class=o>=</span> <span class=n>i</span>
        <span class=k>elif</span> <span class=ow>not</span> <span class=n>value</span> <span class=ow>and</span> <span class=n>start</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>intervals</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>start</span><span class=p>,</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
            <span class=n>start</span> <span class=o>=</span> <span class=kc>None</span>
    <span class=k>if</span> <span class=n>start</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>intervals</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>start</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>logical</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>intervals</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.get_rank_order class="doc doc-heading"> <code class="highlight language-python"><span class=n>get_rank_order</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>method</span><span class=o>=</span><span class=s1>&#39;peak_fr&#39;</span><span class=p>,</span> <span class=n>ref</span><span class=o>=</span><span class=s1>&#39;cells&#39;</span><span class=p>,</span> <span class=n>padding</span><span class=o>=</span><span class=mf>0.05</span><span class=p>,</span> <span class=n>dt</span><span class=o>=</span><span class=mf>0.001</span><span class=p>,</span> <span class=n>sigma</span><span class=o>=</span><span class=mf>0.01</span><span class=p>,</span> <span class=n>min_units</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Calculate the rank order of spike trains within specified epochs.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>st</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span> or <span title=nelpy.array>array</span></code> </td> <td> <div class=doc-md-description> <p>Spike train data. Can be a nelpy array containing spike times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>epochs</code> </td> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>An object containing the epochs (windows) in which to calculate the rank order.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>method</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Method to calculate rank order. Choices are 'first_spike' or 'peak_fr'. Defaults to 'peak_fr'.</p> </div> </td> <td> <code>&#39;peak_fr&#39;</code> </td> </tr> <tr class=doc-section-item> <td> <code>ref</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Reference frame for rank order. Choices are 'cells' or 'epoch'. Defaults to 'cells'.</p> </div> </td> <td> <code>&#39;cells&#39;</code> </td> </tr> <tr class=doc-section-item> <td> <code>padding</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Padding (in seconds) to apply to the epochs. Defaults to 0.05 seconds.</p> </div> </td> <td> <code>0.05</code> </td> </tr> <tr class=doc-section-item> <td> <code>dt</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Bin width (in seconds) for finding relative time in the epoch reference. Defaults to 0.001 seconds.</p> </div> </td> <td> <code>0.001</code> </td> </tr> <tr class=doc-section-item> <td> <code>sigma</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Smoothing sigma (in seconds) for the 'peak_fr' method. Defaults to 0.01 seconds.</p> </div> </td> <td> <code>0.01</code> </td> </tr> <tr class=doc-section-item> <td> <code>min_units</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Minimum number of active units required to compute the rank order. Defaults to 5.</p> </div> </td> <td> <code>5</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>median_rank</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The median rank order across all epochs, normalized between 0 and 1.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>rank_order</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array of rank orders, where each column corresponds to an epoch, and each row corresponds to a cell, normalized between 0 and 1.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>putativeCellType</span><span class=o>=</span><span class=s1>&#39;Pyr&#39;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>forward_replay</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>starts</span><span class=p>,</span> <span class=n>stops</span><span class=p>])</span><span class=o>.</span><span class=n>T</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>median_rank</span><span class=p>,</span> <span class=n>rank_order</span> <span class=o>=</span> <span class=n>get_rank_order</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>forward_replay</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 826</span>
<span class=normal> 827</span>
<span class=normal> 828</span>
<span class=normal> 829</span>
<span class=normal> 830</span>
<span class=normal> 831</span>
<span class=normal> 832</span>
<span class=normal> 833</span>
<span class=normal> 834</span>
<span class=normal> 835</span>
<span class=normal> 836</span>
<span class=normal> 837</span>
<span class=normal> 838</span>
<span class=normal> 839</span>
<span class=normal> 840</span>
<span class=normal> 841</span>
<span class=normal> 842</span>
<span class=normal> 843</span>
<span class=normal> 844</span>
<span class=normal> 845</span>
<span class=normal> 846</span>
<span class=normal> 847</span>
<span class=normal> 848</span>
<span class=normal> 849</span>
<span class=normal> 850</span>
<span class=normal> 851</span>
<span class=normal> 852</span>
<span class=normal> 853</span>
<span class=normal> 854</span>
<span class=normal> 855</span>
<span class=normal> 856</span>
<span class=normal> 857</span>
<span class=normal> 858</span>
<span class=normal> 859</span>
<span class=normal> 860</span>
<span class=normal> 861</span>
<span class=normal> 862</span>
<span class=normal> 863</span>
<span class=normal> 864</span>
<span class=normal> 865</span>
<span class=normal> 866</span>
<span class=normal> 867</span>
<span class=normal> 868</span>
<span class=normal> 869</span>
<span class=normal> 870</span>
<span class=normal> 871</span>
<span class=normal> 872</span>
<span class=normal> 873</span>
<span class=normal> 874</span>
<span class=normal> 875</span>
<span class=normal> 876</span>
<span class=normal> 877</span>
<span class=normal> 878</span>
<span class=normal> 879</span>
<span class=normal> 880</span>
<span class=normal> 881</span>
<span class=normal> 882</span>
<span class=normal> 883</span>
<span class=normal> 884</span>
<span class=normal> 885</span>
<span class=normal> 886</span>
<span class=normal> 887</span>
<span class=normal> 888</span>
<span class=normal> 889</span>
<span class=normal> 890</span>
<span class=normal> 891</span>
<span class=normal> 892</span>
<span class=normal> 893</span>
<span class=normal> 894</span>
<span class=normal> 895</span>
<span class=normal> 896</span>
<span class=normal> 897</span>
<span class=normal> 898</span>
<span class=normal> 899</span>
<span class=normal> 900</span>
<span class=normal> 901</span>
<span class=normal> 902</span>
<span class=normal> 903</span>
<span class=normal> 904</span>
<span class=normal> 905</span>
<span class=normal> 906</span>
<span class=normal> 907</span>
<span class=normal> 908</span>
<span class=normal> 909</span>
<span class=normal> 910</span>
<span class=normal> 911</span>
<span class=normal> 912</span>
<span class=normal> 913</span>
<span class=normal> 914</span>
<span class=normal> 915</span>
<span class=normal> 916</span>
<span class=normal> 917</span>
<span class=normal> 918</span>
<span class=normal> 919</span>
<span class=normal> 920</span>
<span class=normal> 921</span>
<span class=normal> 922</span>
<span class=normal> 923</span>
<span class=normal> 924</span>
<span class=normal> 925</span>
<span class=normal> 926</span>
<span class=normal> 927</span>
<span class=normal> 928</span>
<span class=normal> 929</span>
<span class=normal> 930</span>
<span class=normal> 931</span>
<span class=normal> 932</span>
<span class=normal> 933</span>
<span class=normal> 934</span>
<span class=normal> 935</span>
<span class=normal> 936</span>
<span class=normal> 937</span>
<span class=normal> 938</span>
<span class=normal> 939</span>
<span class=normal> 940</span>
<span class=normal> 941</span>
<span class=normal> 942</span>
<span class=normal> 943</span>
<span class=normal> 944</span>
<span class=normal> 945</span>
<span class=normal> 946</span>
<span class=normal> 947</span>
<span class=normal> 948</span>
<span class=normal> 949</span>
<span class=normal> 950</span>
<span class=normal> 951</span>
<span class=normal> 952</span>
<span class=normal> 953</span>
<span class=normal> 954</span>
<span class=normal> 955</span>
<span class=normal> 956</span>
<span class=normal> 957</span>
<span class=normal> 958</span>
<span class=normal> 959</span>
<span class=normal> 960</span>
<span class=normal> 961</span>
<span class=normal> 962</span>
<span class=normal> 963</span>
<span class=normal> 964</span>
<span class=normal> 965</span>
<span class=normal> 966</span>
<span class=normal> 967</span>
<span class=normal> 968</span>
<span class=normal> 969</span>
<span class=normal> 970</span>
<span class=normal> 971</span>
<span class=normal> 972</span>
<span class=normal> 973</span>
<span class=normal> 974</span>
<span class=normal> 975</span>
<span class=normal> 976</span>
<span class=normal> 977</span>
<span class=normal> 978</span>
<span class=normal> 979</span>
<span class=normal> 980</span>
<span class=normal> 981</span>
<span class=normal> 982</span>
<span class=normal> 983</span>
<span class=normal> 984</span>
<span class=normal> 985</span>
<span class=normal> 986</span>
<span class=normal> 987</span>
<span class=normal> 988</span>
<span class=normal> 989</span>
<span class=normal> 990</span>
<span class=normal> 991</span>
<span class=normal> 992</span>
<span class=normal> 993</span>
<span class=normal> 994</span>
<span class=normal> 995</span>
<span class=normal> 996</span>
<span class=normal> 997</span>
<span class=normal> 998</span>
<span class=normal> 999</span>
<span class=normal>1000</span>
<span class=normal>1001</span>
<span class=normal>1002</span>
<span class=normal>1003</span>
<span class=normal>1004</span>
<span class=normal>1005</span>
<span class=normal>1006</span>
<span class=normal>1007</span>
<span class=normal>1008</span>
<span class=normal>1009</span>
<span class=normal>1010</span>
<span class=normal>1011</span>
<span class=normal>1012</span>
<span class=normal>1013</span>
<span class=normal>1014</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>get_rank_order</span><span class=p>(</span>
    <span class=n>st</span><span class=p>:</span> <span class=n>SpikeTrainArray</span><span class=p>,</span>  <span class=c1># Assuming &#39;nelpy.array&#39; is a custom type</span>
    <span class=n>epochs</span><span class=p>:</span> <span class=n>EpochArray</span><span class=p>,</span>
    <span class=n>method</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&quot;peak_fr&quot;</span><span class=p>,</span>  <span class=c1># &#39;first_spike&#39; or &#39;peak_fr&#39;</span>
    <span class=n>ref</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&quot;cells&quot;</span><span class=p>,</span>  <span class=c1># &#39;cells&#39; or &#39;epoch&#39;</span>
    <span class=n>padding</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.05</span><span class=p>,</span>
    <span class=n>dt</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.001</span><span class=p>,</span>
    <span class=n>sigma</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.01</span><span class=p>,</span>
    <span class=n>min_units</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Calculate the rank order of spike trains within specified epochs.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    st : np.ndarray or nelpy.array</span>
<span class=sd>        Spike train data. Can be a nelpy array containing spike times.</span>

<span class=sd>    epochs : nelpy.EpochArray</span>
<span class=sd>        An object containing the epochs (windows) in which to calculate the rank order.</span>

<span class=sd>    method : str, optional</span>
<span class=sd>        Method to calculate rank order. Choices are &#39;first_spike&#39; or &#39;peak_fr&#39;.</span>
<span class=sd>        Defaults to &#39;peak_fr&#39;.</span>

<span class=sd>    ref : str, optional</span>
<span class=sd>        Reference frame for rank order. Choices are &#39;cells&#39; or &#39;epoch&#39;.</span>
<span class=sd>        Defaults to &#39;cells&#39;.</span>

<span class=sd>    padding : float, optional</span>
<span class=sd>        Padding (in seconds) to apply to the epochs. Defaults to 0.05 seconds.</span>

<span class=sd>    dt : float, optional</span>
<span class=sd>        Bin width (in seconds) for finding relative time in the epoch reference.</span>
<span class=sd>        Defaults to 0.001 seconds.</span>

<span class=sd>    sigma : float, optional</span>
<span class=sd>        Smoothing sigma (in seconds) for the &#39;peak_fr&#39; method. Defaults to 0.01 seconds.</span>

<span class=sd>    min_units : int, optional</span>
<span class=sd>        Minimum number of active units required to compute the rank order. Defaults to 5.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    median_rank : np.ndarray</span>
<span class=sd>        The median rank order across all epochs, normalized between 0 and 1.</span>

<span class=sd>    rank_order : np.ndarray</span>
<span class=sd>        A 2D array of rank orders, where each column corresponds to an epoch,</span>
<span class=sd>        and each row corresponds to a cell, normalized between 0 and 1.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; st, _ = loading.load_spikes(basepath, putativeCellType=&#39;Pyr&#39;)</span>
<span class=sd>    &gt;&gt;&gt; forward_replay = nel.EpochArray(np.array([starts, stops]).T)</span>
<span class=sd>    &gt;&gt;&gt; median_rank, rank_order = get_rank_order(st, forward_replay)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># filter out specific warnings</span>
    <span class=n>warnings</span><span class=o>.</span><span class=n>filterwarnings</span><span class=p>(</span>
        <span class=s2>&quot;ignore&quot;</span><span class=p>,</span> <span class=n>message</span><span class=o>=</span><span class=s2>&quot;ignoring events outside of eventarray support&quot;</span>
    <span class=p>)</span>
    <span class=n>warnings</span><span class=o>.</span><span class=n>filterwarnings</span><span class=p>(</span><span class=s2>&quot;ignore&quot;</span><span class=p>,</span> <span class=n>message</span><span class=o>=</span><span class=s2>&quot;Mean of empty slice&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>method</span> <span class=ow>not</span> <span class=ow>in</span> <span class=p>[</span><span class=s2>&quot;first_spike&quot;</span><span class=p>,</span> <span class=s2>&quot;peak_fr&quot;</span><span class=p>]:</span>
        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&quot;method &quot;</span> <span class=o>+</span> <span class=n>method</span> <span class=o>+</span> <span class=s2>&quot; not implemented&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>ref</span> <span class=ow>not</span> <span class=ow>in</span> <span class=p>[</span><span class=s2>&quot;cells&quot;</span><span class=p>,</span> <span class=s2>&quot;epoch&quot;</span><span class=p>]:</span>
        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&quot;ref &quot;</span> <span class=o>+</span> <span class=n>ref</span> <span class=o>+</span> <span class=s2>&quot; not implemented&quot;</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>get_min_ts</span><span class=p>(</span><span class=n>st_temp</span><span class=p>):</span>
        <span class=n>min_ts</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>ts</span> <span class=ow>in</span> <span class=n>st_temp</span><span class=o>.</span><span class=n>data</span><span class=p>:</span>
            <span class=c1># nan if no spikes</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>ts</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
                <span class=n>min_ts</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>min_ts</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nanmin</span><span class=p>(</span><span class=n>ts</span><span class=p>))</span>
        <span class=k>return</span> <span class=n>min_ts</span>

    <span class=k>def</span><span class=w> </span><span class=nf>rank_order_first_spike</span><span class=p>(</span><span class=n>st_epoch</span><span class=p>,</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>dt</span><span class=p>,</span> <span class=n>min_units</span><span class=p>,</span> <span class=n>ref</span><span class=p>):</span>
        <span class=c1># set up empty matrix for rank order</span>
        <span class=n>rank_order</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>ones</span><span class=p>([</span><span class=n>st_epoch</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>])</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>

        <span class=n>unit_id</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>st_epoch</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=n>st_epoch</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>epochs</span>

        <span class=c1># iter over every event</span>
        <span class=k>for</span> <span class=n>event_i</span><span class=p>,</span> <span class=n>st_temp</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>st_epoch</span><span class=p>):</span>
            <span class=k>if</span> <span class=n>ref</span> <span class=o>==</span> <span class=s2>&quot;cells&quot;</span><span class=p>:</span>
                <span class=c1># get firing order</span>
                <span class=n>idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>st_temp</span><span class=o>.</span><span class=n>get_event_firing_order</span><span class=p>())</span> <span class=o>-</span> <span class=mi>1</span>
                <span class=c1># reorder unit ids by order and remove non-active</span>
                <span class=n>units</span> <span class=o>=</span> <span class=n>unit_id</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=n>st_temp</span><span class=o>.</span><span class=n>n_events</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>]</span>
                <span class=c1># how many are left?</span>
                <span class=n>nUnits</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>units</span><span class=p>)</span>

                <span class=k>if</span> <span class=n>nUnits</span> <span class=o>&lt;</span> <span class=n>min_units</span><span class=p>:</span>
                    <span class=n>rank_order</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=c1># arange 1 to n units in order of units</span>
                    <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>nUnits</span><span class=p>)</span>
                    <span class=c1># normalize by n units</span>
                    <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>/</span> <span class=n>nUnits</span>
            <span class=k>elif</span> <span class=n>ref</span> <span class=o>==</span> <span class=s2>&quot;epoch&quot;</span><span class=p>:</span>
                <span class=c1># find first spike time for each cell</span>
                <span class=n>min_ts</span> <span class=o>=</span> <span class=n>get_min_ts</span><span class=p>(</span><span class=n>st_temp</span><span class=p>)</span>
                <span class=c1># make time stamps for interpolation</span>
                <span class=n>epoch_ts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>epochs</span><span class=p>[</span><span class=n>event_i</span><span class=p>]</span><span class=o>.</span><span class=n>start</span><span class=p>,</span> <span class=n>epochs</span><span class=p>[</span><span class=n>event_i</span><span class=p>]</span><span class=o>.</span><span class=n>stop</span><span class=p>,</span> <span class=n>dt</span><span class=p>)</span>
                <span class=c1># make normalized range 0-1</span>
                <span class=n>norm_range</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>epoch_ts</span><span class=p>))</span>
                <span class=c1># get spike order relative to normalized range</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>min_ts</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>min_units</span><span class=p>:</span>
                    <span class=n>rank_order</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>rank_order</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span><span class=n>min_ts</span><span class=p>,</span> <span class=n>epoch_ts</span><span class=p>,</span> <span class=n>norm_range</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>rank_order</span>

    <span class=k>def</span><span class=w> </span><span class=nf>rank_order_fr</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>dt</span><span class=p>,</span> <span class=n>sigma</span><span class=p>,</span> <span class=n>min_units</span><span class=p>,</span> <span class=n>ref</span><span class=p>):</span>
        <span class=c1># set up empty matrix for rank order</span>
        <span class=n>rank_order</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>([</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>])</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>

        <span class=n>unit_id</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>

        <span class=n>edges</span> <span class=o>=</span> <span class=n>split_epoch_by_width</span><span class=p>(</span><span class=n>epochs</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>dt</span><span class=p>)</span>

        <span class=n>z_t</span> <span class=o>=</span> <span class=n>count_in_interval</span><span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>edges</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>edges</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>],</span> <span class=n>par_type</span><span class=o>=</span><span class=s2>&quot;counts&quot;</span><span class=p>)</span>
        <span class=n>_</span><span class=p>,</span> <span class=n>interval_id</span> <span class=o>=</span> <span class=n>in_intervals</span><span class=p>(</span><span class=n>edges</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>return_interval</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

        <span class=c1># iter over epochs</span>
        <span class=k>for</span> <span class=n>event_i</span><span class=p>,</span> <span class=n>epochs_temp</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>epochs</span><span class=p>):</span>
            <span class=c1># smooth spike train in order to estimate peak</span>
            <span class=c1># z_t_temp.smooth(sigma=sigma, inplace=True)</span>
            <span class=n>z_t_temp</span> <span class=o>=</span> <span class=n>z_t</span><span class=p>[:,</span> <span class=n>interval_id</span> <span class=o>==</span> <span class=n>event_i</span><span class=p>]</span>
            <span class=c1># smooth spike train in order to estimate peak</span>
            <span class=n>z_t_temp</span> <span class=o>=</span> <span class=n>gaussian_filter1d</span><span class=p>(</span><span class=n>z_t_temp</span><span class=p>,</span> <span class=n>sigma</span> <span class=o>/</span> <span class=n>dt</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>ref</span> <span class=o>==</span> <span class=s2>&quot;cells&quot;</span><span class=p>:</span>
                <span class=c1># find loc of each peak and get sorted idx of active units</span>
                <span class=n>idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>z_t_temp</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>))</span>
                <span class=c1># reorder unit ids by order and remove non-active</span>
                <span class=n>units</span> <span class=o>=</span> <span class=n>unit_id</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>z_t_temp</span><span class=p>[</span><span class=n>idx</span><span class=p>,</span> <span class=p>:]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>]</span>

                <span class=n>nUnits</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>units</span><span class=p>)</span>

                <span class=k>if</span> <span class=n>nUnits</span> <span class=o>&lt;</span> <span class=n>min_units</span><span class=p>:</span>
                    <span class=n>rank_order</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=c1># arange 1 to n units in order of units</span>
                    <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>nUnits</span><span class=p>)</span>
                    <span class=c1># normalize by n units</span>
                    <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rank_order</span><span class=p>[</span><span class=n>units</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>/</span> <span class=n>nUnits</span>
            <span class=k>elif</span> <span class=n>ref</span> <span class=o>==</span> <span class=s2>&quot;epoch&quot;</span><span class=p>:</span>
                <span class=c1># iterate over each cell</span>
                <span class=k>for</span> <span class=n>cell_i</span><span class=p>,</span> <span class=n>unit</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>z_t_temp</span><span class=p>):</span>
                    <span class=c1># if the cell is not active apply nan</span>
                    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>unit</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>):</span>
                        <span class=n>rank_order</span><span class=p>[</span><span class=n>cell_i</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                    <span class=k>else</span><span class=p>:</span>
                        <span class=c1># calculate normalized rank order (0-1)</span>
                        <span class=n>rank_order</span><span class=p>[</span><span class=n>cell_i</span><span class=p>,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>unit</span><span class=p>)</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>unit</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>rank_order</span>

    <span class=c1># expand epochs by padding amount</span>
    <span class=n>epochs</span> <span class=o>=</span> <span class=n>epochs</span><span class=o>.</span><span class=n>expand</span><span class=p>(</span><span class=n>padding</span><span class=p>)</span>

    <span class=c1># check if no active cells</span>
    <span class=k>if</span> <span class=n>st</span><span class=o>.</span><span class=n>n_active</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>)</span>
        <span class=p>)</span>

    <span class=c1># check if there are any spikes in the epoch</span>
    <span class=n>st_epoch</span> <span class=o>=</span> <span class=n>count_in_interval</span><span class=p>(</span>
        <span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>epochs</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>epochs</span><span class=o>.</span><span class=n>stops</span><span class=p>,</span> <span class=n>par_type</span><span class=o>=</span><span class=s2>&quot;counts&quot;</span>
    <span class=p>)</span>

    <span class=c1># if no spikes in epoch, break out</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>st_epoch</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>all</span><span class=p>():</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>epochs</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>)</span>
        <span class=p>)</span>

    <span class=c1># set up empty matrix for rank order</span>
    <span class=k>if</span> <span class=n>method</span> <span class=o>==</span> <span class=s2>&quot;peak_fr&quot;</span><span class=p>:</span>
        <span class=n>rank_order</span> <span class=o>=</span> <span class=n>rank_order_fr</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>dt</span><span class=p>,</span> <span class=n>sigma</span><span class=p>,</span> <span class=n>min_units</span><span class=p>,</span> <span class=n>ref</span><span class=p>)</span>
    <span class=k>elif</span> <span class=n>method</span> <span class=o>==</span> <span class=s2>&quot;first_spike&quot;</span><span class=p>:</span>
        <span class=n>rank_order</span> <span class=o>=</span> <span class=n>rank_order_first_spike</span><span class=p>(</span><span class=n>st</span><span class=p>[</span><span class=n>epochs</span><span class=p>],</span> <span class=n>epochs</span><span class=p>,</span> <span class=n>dt</span><span class=p>,</span> <span class=n>min_units</span><span class=p>,</span> <span class=n>ref</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&quot;method &quot;</span> <span class=o>+</span> <span class=n>method</span> <span class=o>+</span> <span class=s2>&quot; not implemented&quot;</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>nanmedian</span><span class=p>(</span><span class=n>rank_order</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span> <span class=n>rank_order</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.get_raster_points class="doc doc-heading"> <code class="highlight language-python"><span class=n>get_raster_points</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Generate points for a raster plot centered around each reference time in the <code>time_ref</code> array.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of time values.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_ref</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of reference times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of each bin in the raster plot, in seconds. Default is 0.002 seconds.</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins in the raster plot. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=tuple>tuple</span></code> </td> <td> <div class=doc-md-description> <p>A tuple containing the start and end times of the window to be plotted around each reference time. If not provided, the window will be centered around each reference time and have a width of <code>n_bins * bin_width</code> seconds.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>x</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of x values representing the time offsets of each data point relative to the corresponding reference time.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>y</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of y values representing the reference times.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>times</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of time values corresponding to the bins in the raster plot.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>333</span>
<span class=normal>334</span>
<span class=normal>335</span>
<span class=normal>336</span>
<span class=normal>337</span>
<span class=normal>338</span>
<span class=normal>339</span>
<span class=normal>340</span>
<span class=normal>341</span>
<span class=normal>342</span>
<span class=normal>343</span>
<span class=normal>344</span>
<span class=normal>345</span>
<span class=normal>346</span>
<span class=normal>347</span>
<span class=normal>348</span>
<span class=normal>349</span>
<span class=normal>350</span>
<span class=normal>351</span>
<span class=normal>352</span>
<span class=normal>353</span>
<span class=normal>354</span>
<span class=normal>355</span>
<span class=normal>356</span>
<span class=normal>357</span>
<span class=normal>358</span>
<span class=normal>359</span>
<span class=normal>360</span>
<span class=normal>361</span>
<span class=normal>362</span>
<span class=normal>363</span>
<span class=normal>364</span>
<span class=normal>365</span>
<span class=normal>366</span>
<span class=normal>367</span>
<span class=normal>368</span>
<span class=normal>369</span>
<span class=normal>370</span>
<span class=normal>371</span>
<span class=normal>372</span>
<span class=normal>373</span>
<span class=normal>374</span>
<span class=normal>375</span>
<span class=normal>376</span>
<span class=normal>377</span>
<span class=normal>378</span>
<span class=normal>379</span>
<span class=normal>380</span>
<span class=normal>381</span>
<span class=normal>382</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>get_raster_points</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>time_ref</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Generate points for a raster plot centered around each reference time in the `time_ref` array.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : ndarray</span>
<span class=sd>        A 1D array of time values.</span>
<span class=sd>    time_ref : ndarray</span>
<span class=sd>        A 1D array of reference times.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        The width of each bin in the raster plot, in seconds. Default is 0.002 seconds.</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        The number of bins in the raster plot. Default is 100.</span>
<span class=sd>    window : tuple, optional</span>
<span class=sd>        A tuple containing the start and end times of the window to be plotted around each reference time.</span>
<span class=sd>        If not provided, the window will be centered around each reference time and have a width of `n_bins * bin_width` seconds.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    x : ndarray</span>
<span class=sd>        A 1D array of x values representing the time offsets of each data point relative to the corresponding reference time.</span>
<span class=sd>    y : ndarray</span>
<span class=sd>        A 1D array of y values representing the reference times.</span>
<span class=sd>    times : ndarray</span>
<span class=sd>        A 1D array of time values corresponding to the bins in the raster plot.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span>
            <span class=o>-</span><span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>n_bins</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>n_bins</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=p>)</span>

    <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=n>y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>time_ref</span><span class=p>):</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=p>(</span><span class=n>data</span> <span class=o>&gt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>times</span><span class=o>.</span><span class=n>min</span><span class=p>())</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>data</span> <span class=o>&lt;</span> <span class=n>r</span> <span class=o>+</span> <span class=n>times</span><span class=o>.</span><span class=n>max</span><span class=p>())</span>
        <span class=n>cur_data</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>
        <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>concatenate</span><span class=p>((</span><span class=n>x</span><span class=p>,</span> <span class=n>cur_data</span> <span class=o>-</span> <span class=n>r</span><span class=p>))</span>
        <span class=n>y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>concatenate</span><span class=p>((</span><span class=n>y</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ones_like</span><span class=p>(</span><span class=n>cur_data</span><span class=p>)</span> <span class=o>*</span> <span class=n>i</span><span class=p>))</span>

    <span class=k>return</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>times</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.get_tapers class="doc doc-heading"> <code class="highlight language-python"><span class=n>get_tapers</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>bandwidth</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>fs</span><span class=o>=</span><span class=mf>1.0</span><span class=p>,</span> <span class=n>min_lambda</span><span class=o>=</span><span class=mf>0.95</span><span class=p>,</span> <span class=n>n_tapers</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute tapers and associated energy concentrations for the Thomson multitaper method.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>N</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Length of taper.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bandwidth</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Bandwidth of taper, in Hz.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fs</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Sampling rate, in Hz. Default is 1 Hz.</p> </div> </td> <td> <code>1.0</code> </td> </tr> <tr class=doc-section-item> <td> <code>min_lambda</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Minimum energy concentration that each taper must satisfy. Default is 0.95.</p> </div> </td> <td> <code>0.95</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_tapers</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=int>int</span>]</code> </td> <td> <div class=doc-md-description> <p>Number of tapers to compute. Default is to use all tapers that satisfy 'min_lambda'.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>tapers</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of tapers with shape (n_tapers, N).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>lambdas</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Energy concentrations for each taper with shape (n_tapers,).</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Raises:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=ValueError>ValueError</span></code> </td> <td> <div class=doc-md-description> <p>If not enough tapers are available or if none of the tapers satisfy the minimum energy concentration criteria.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 74</span>
<span class=normal> 75</span>
<span class=normal> 76</span>
<span class=normal> 77</span>
<span class=normal> 78</span>
<span class=normal> 79</span>
<span class=normal> 80</span>
<span class=normal> 81</span>
<span class=normal> 82</span>
<span class=normal> 83</span>
<span class=normal> 84</span>
<span class=normal> 85</span>
<span class=normal> 86</span>
<span class=normal> 87</span>
<span class=normal> 88</span>
<span class=normal> 89</span>
<span class=normal> 90</span>
<span class=normal> 91</span>
<span class=normal> 92</span>
<span class=normal> 93</span>
<span class=normal> 94</span>
<span class=normal> 95</span>
<span class=normal> 96</span>
<span class=normal> 97</span>
<span class=normal> 98</span>
<span class=normal> 99</span>
<span class=normal>100</span>
<span class=normal>101</span>
<span class=normal>102</span>
<span class=normal>103</span>
<span class=normal>104</span>
<span class=normal>105</span>
<span class=normal>106</span>
<span class=normal>107</span>
<span class=normal>108</span>
<span class=normal>109</span>
<span class=normal>110</span>
<span class=normal>111</span>
<span class=normal>112</span>
<span class=normal>113</span>
<span class=normal>114</span>
<span class=normal>115</span>
<span class=normal>116</span>
<span class=normal>117</span>
<span class=normal>118</span>
<span class=normal>119</span>
<span class=normal>120</span>
<span class=normal>121</span>
<span class=normal>122</span>
<span class=normal>123</span>
<span class=normal>124</span>
<span class=normal>125</span>
<span class=normal>126</span>
<span class=normal>127</span>
<span class=normal>128</span>
<span class=normal>129</span>
<span class=normal>130</span>
<span class=normal>131</span>
<span class=normal>132</span>
<span class=normal>133</span>
<span class=normal>134</span>
<span class=normal>135</span>
<span class=normal>136</span>
<span class=normal>137</span>
<span class=normal>138</span>
<span class=normal>139</span>
<span class=normal>140</span>
<span class=normal>141</span>
<span class=normal>142</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>get_tapers</span><span class=p>(</span>
    <span class=n>N</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
    <span class=n>bandwidth</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
    <span class=o>*</span><span class=p>,</span>
    <span class=n>fs</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>,</span>
    <span class=n>min_lambda</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.95</span><span class=p>,</span>
    <span class=n>n_tapers</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute tapers and associated energy concentrations for the Thomson</span>
<span class=sd>    multitaper method.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    N : int</span>
<span class=sd>        Length of taper.</span>
<span class=sd>    bandwidth : float</span>
<span class=sd>        Bandwidth of taper, in Hz.</span>
<span class=sd>    fs : float, optional</span>
<span class=sd>        Sampling rate, in Hz. Default is 1 Hz.</span>
<span class=sd>    min_lambda : float, optional</span>
<span class=sd>        Minimum energy concentration that each taper must satisfy. Default is 0.95.</span>
<span class=sd>    n_tapers : Optional[int], optional</span>
<span class=sd>        Number of tapers to compute. Default is to use all tapers that satisfy &#39;min_lambda&#39;.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    tapers : np.ndarray</span>
<span class=sd>        Array of tapers with shape (n_tapers, N).</span>
<span class=sd>    lambdas : np.ndarray</span>
<span class=sd>        Energy concentrations for each taper with shape (n_tapers,).</span>

<span class=sd>    Raises</span>
<span class=sd>    ------</span>
<span class=sd>    ValueError</span>
<span class=sd>        If not enough tapers are available or if none of the tapers satisfy the</span>
<span class=sd>        minimum energy concentration criteria.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>NW</span> <span class=o>=</span> <span class=n>bandwidth</span> <span class=o>*</span> <span class=n>N</span> <span class=o>/</span> <span class=n>fs</span>
    <span class=n>K</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>NW</span><span class=p>))</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=k>if</span> <span class=n>n_tapers</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>K</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>K</span><span class=p>,</span> <span class=n>n_tapers</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>K</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=sa>f</span><span class=s2>&quot;Not enough tapers, with &#39;NW&#39; of </span><span class=si>{</span><span class=n>NW</span><span class=si>}</span><span class=s2>. Increase the bandwidth or &quot;</span>
            <span class=s2>&quot;use more data points&quot;</span>
        <span class=p>)</span>

    <span class=n>tapers</span><span class=p>,</span> <span class=n>lambdas</span> <span class=o>=</span> <span class=n>dpss</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>NW</span><span class=o>=</span><span class=n>NW</span><span class=p>,</span> <span class=n>Kmax</span><span class=o>=</span><span class=n>K</span><span class=p>,</span> <span class=n>sym</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>norm</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>return_ratios</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
    <span class=n>mask</span> <span class=o>=</span> <span class=n>lambdas</span> <span class=o>&gt;</span> <span class=n>min_lambda</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>mask</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;None of the tapers satisfied the minimum energy concentration&quot;</span>
            <span class=sa>f</span><span class=s2>&quot; criteria of </span><span class=si>{</span><span class=n>min_lambda</span><span class=si>}</span><span class=s2>&quot;</span>
        <span class=p>)</span>
    <span class=n>tapers</span> <span class=o>=</span> <span class=n>tapers</span><span class=p>[</span><span class=n>mask</span><span class=p>]</span>
    <span class=n>lambdas</span> <span class=o>=</span> <span class=n>lambdas</span><span class=p>[</span><span class=n>mask</span><span class=p>]</span>

    <span class=k>if</span> <span class=n>n_tapers</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>n_tapers</span> <span class=o>&gt;</span> <span class=n>tapers</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                <span class=sa>f</span><span class=s2>&quot;&#39;n_tapers&#39; of </span><span class=si>{</span><span class=n>n_tapers</span><span class=si>}</span><span class=s2> is greater than the </span><span class=si>{</span><span class=n>tapers</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=si>}</span><span class=s2>&quot;</span>
                <span class=sa>f</span><span class=s2>&quot; that satisfied the minimum energy concentration criteria of </span><span class=si>{</span><span class=n>min_lambda</span><span class=si>}</span><span class=s2>&quot;</span>
            <span class=p>)</span>
        <span class=n>tapers</span> <span class=o>=</span> <span class=n>tapers</span><span class=p>[:</span><span class=n>n_tapers</span><span class=p>]</span>
        <span class=n>lambdas</span> <span class=o>=</span> <span class=n>lambdas</span><span class=p>[:</span><span class=n>n_tapers</span><span class=p>]</span>

    <span class=k>return</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>lambdas</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.getfgrid class="doc doc-heading"> <code class="highlight language-python"><span class=n>getfgrid</span><span class=p>(</span><span class=n>Fs</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>fpass</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Get frequency grid for evaluation.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>Fs</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>nfft</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of points for FFT.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fpass</code> </td> <td> <code><span title=typing.List>List</span>[<span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>Frequency range to evaluate (as [fmin, fmax]).</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>f</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Frequency vector within the specified range.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>findx</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Boolean array indicating the indices of the frequency vector that fall within the specified range.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>The frequency vector is computed based on the sampling frequency and the number of FFT points. Only frequencies within the range defined by <code>fpass</code> are returned.</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>getfgrid</span><span class=p>(</span><span class=n>Fs</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>nfft</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>fpass</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Get frequency grid for evaluation.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    Fs : int</span>
<span class=sd>        Sampling frequency.</span>
<span class=sd>    nfft : int</span>
<span class=sd>        Number of points for FFT.</span>
<span class=sd>    fpass : List[float]</span>
<span class=sd>        Frequency range to evaluate (as [fmin, fmax]).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    f : np.ndarray</span>
<span class=sd>        Frequency vector within the specified range.</span>
<span class=sd>    findx : np.ndarray</span>
<span class=sd>        Boolean array indicating the indices of the frequency vector that fall within the specified range.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    The frequency vector is computed based on the sampling frequency and the number of FFT points.</span>
<span class=sd>    Only frequencies within the range defined by `fpass` are returned.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>df</span> <span class=o>=</span> <span class=n>Fs</span> <span class=o>/</span> <span class=n>nfft</span>
    <span class=n>f</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>Fs</span> <span class=o>+</span> <span class=n>df</span><span class=p>,</span> <span class=n>df</span><span class=p>)</span>
    <span class=n>f</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=n>nfft</span><span class=p>]</span>
    <span class=n>findx</span> <span class=o>=</span> <span class=p>(</span><span class=n>f</span> <span class=o>&gt;=</span> <span class=n>fpass</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>f</span> <span class=o>&lt;=</span> <span class=n>fpass</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
    <span class=n>f</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=n>findx</span><span class=p>]</span>
    <span class=k>return</span> <span class=n>f</span><span class=p>,</span> <span class=n>findx</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.in_intervals class="doc doc-heading"> <code class="highlight language-python"><span class=n>in_intervals</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>intervals</span><span class=p>,</span> <span class=n>return_interval</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>shift</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Find which timestamps fall within the given intervals.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>timestamps</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of timestamp values. Assumes sorted.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>intervals</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time intervals, represented as pairs of start and end times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>return_interval</code> </td> <td> <code>(<span title=bool>bool</span>, <span title=optional>optional</span>(default=False))</code> </td> <td> <div class=doc-md-description> <p>If True, return the index of the interval to which each timestamp belongs.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>shift</code> </td> <td> <code>(<span title=bool>bool</span>, <span title=optional>optional</span>(default=False))</code> </td> <td> <div class=doc-md-description> <p>If True, return the shifted timestamps</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>in_interval</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A logical index indicating which timestamps fall within the intervals.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>interval</code></td> <td> <code>(<span title=ndarray>ndarray</span>, <span title=optional>optional</span>)</code> </td> <td> <div class=doc-md-description> <p>A ndarray indicating for each timestamps which interval it was within.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>shifted_timestamps</code></td> <td> <code>(<span title=ndarray>ndarray</span>, <span title=optional>optional</span>)</code> </td> <td> <div class=doc-md-description> <p>The shifted timestamps</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>timestamps</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>],</span> <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>in_intervals</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>intervals</span><span class=p>)</span>
<span class=go>array([False,  True,  True,  True,  True,  True,  True, False])</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>in_intervals</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>intervals</span><span class=p>,</span> <span class=n>return_interval</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=go>(array([False,  True,  True,  True,  True,  True,  True, False]),</span>
<span class=go>array([nan,  0.,  0.,  0.,  1.,  1.,  1., nan]))</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>in_intervals</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>intervals</span><span class=p>,</span> <span class=n>shift</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=go>(array([False,  True,  True,  True,  True,  True,  True, False]),</span>
<span class=go>array([0, 1, 2, 2, 3, 4]))</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>in_intervals</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>intervals</span><span class=p>,</span> <span class=n>return_interval</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>shift</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=go>(array([False,  True,  True,  True,  True,  True,  True, False]),</span>
<span class=go>array([0, 0, 0, 1, 1, 1]),</span>
<span class=go>array([0, 1, 2, 2, 3, 4]))</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>296</span>
<span class=normal>297</span>
<span class=normal>298</span>
<span class=normal>299</span>
<span class=normal>300</span>
<span class=normal>301</span>
<span class=normal>302</span>
<span class=normal>303</span>
<span class=normal>304</span>
<span class=normal>305</span>
<span class=normal>306</span>
<span class=normal>307</span>
<span class=normal>308</span>
<span class=normal>309</span>
<span class=normal>310</span>
<span class=normal>311</span>
<span class=normal>312</span>
<span class=normal>313</span>
<span class=normal>314</span>
<span class=normal>315</span>
<span class=normal>316</span>
<span class=normal>317</span>
<span class=normal>318</span>
<span class=normal>319</span>
<span class=normal>320</span>
<span class=normal>321</span>
<span class=normal>322</span>
<span class=normal>323</span>
<span class=normal>324</span>
<span class=normal>325</span>
<span class=normal>326</span>
<span class=normal>327</span>
<span class=normal>328</span>
<span class=normal>329</span>
<span class=normal>330</span>
<span class=normal>331</span>
<span class=normal>332</span>
<span class=normal>333</span>
<span class=normal>334</span>
<span class=normal>335</span>
<span class=normal>336</span>
<span class=normal>337</span>
<span class=normal>338</span>
<span class=normal>339</span>
<span class=normal>340</span>
<span class=normal>341</span>
<span class=normal>342</span>
<span class=normal>343</span>
<span class=normal>344</span>
<span class=normal>345</span>
<span class=normal>346</span>
<span class=normal>347</span>
<span class=normal>348</span>
<span class=normal>349</span>
<span class=normal>350</span>
<span class=normal>351</span>
<span class=normal>352</span>
<span class=normal>353</span>
<span class=normal>354</span>
<span class=normal>355</span>
<span class=normal>356</span>
<span class=normal>357</span>
<span class=normal>358</span>
<span class=normal>359</span>
<span class=normal>360</span>
<span class=normal>361</span>
<span class=normal>362</span>
<span class=normal>363</span>
<span class=normal>364</span>
<span class=normal>365</span>
<span class=normal>366</span>
<span class=normal>367</span>
<span class=normal>368</span>
<span class=normal>369</span>
<span class=normal>370</span>
<span class=normal>371</span>
<span class=normal>372</span>
<span class=normal>373</span>
<span class=normal>374</span>
<span class=normal>375</span>
<span class=normal>376</span>
<span class=normal>377</span>
<span class=normal>378</span>
<span class=normal>379</span>
<span class=normal>380</span>
<span class=normal>381</span>
<span class=normal>382</span>
<span class=normal>383</span>
<span class=normal>384</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>in_intervals</span><span class=p>(</span>
    <span class=n>timestamps</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>intervals</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>return_interval</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
    <span class=n>shift</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>Optional</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Find which timestamps fall within the given intervals.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    timestamps : ndarray</span>
<span class=sd>        An array of timestamp values. Assumes sorted.</span>
<span class=sd>    intervals : ndarray</span>
<span class=sd>        An array of time intervals, represented as pairs of start and end times.</span>
<span class=sd>    return_interval : bool, optional (default=False)</span>
<span class=sd>        If True, return the index of the interval to which each timestamp belongs.</span>
<span class=sd>    shift : bool, optional (default=False)</span>
<span class=sd>        If True, return the shifted timestamps</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    in_interval : ndarray</span>
<span class=sd>        A logical index indicating which timestamps fall within the intervals.</span>
<span class=sd>    interval : ndarray, optional</span>
<span class=sd>        A ndarray indicating for each timestamps which interval it was within.</span>
<span class=sd>    shifted_timestamps : ndarray, optional</span>
<span class=sd>        The shifted timestamps</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; timestamps = np.array([1, 2, 3, 4, 5, 6, 7, 8])</span>
<span class=sd>    &gt;&gt;&gt; intervals = np.array([[2, 4], [5, 7]])</span>
<span class=sd>    &gt;&gt;&gt; in_intervals(timestamps, intervals)</span>
<span class=sd>    array([False,  True,  True,  True,  True,  True,  True, False])</span>

<span class=sd>    &gt;&gt;&gt; in_intervals(timestamps, intervals, return_interval=True)</span>
<span class=sd>    (array([False,  True,  True,  True,  True,  True,  True, False]),</span>
<span class=sd>    array([nan,  0.,  0.,  0.,  1.,  1.,  1., nan]))</span>

<span class=sd>    &gt;&gt;&gt; in_intervals(timestamps, intervals, shift=True)</span>
<span class=sd>    (array([False,  True,  True,  True,  True,  True,  True, False]),</span>
<span class=sd>    array([0, 1, 2, 2, 3, 4]))</span>

<span class=sd>    &gt;&gt;&gt; in_intervals(timestamps, intervals, return_interval=True, shift=True)</span>
<span class=sd>    (array([False,  True,  True,  True,  True,  True,  True, False]),</span>
<span class=sd>    array([0, 0, 0, 1, 1, 1]),</span>
<span class=sd>    array([0, 1, 2, 2, 3, 4]))</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>in_interval</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=n>timestamps</span><span class=o>.</span><span class=n>shape</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>bool_</span><span class=p>)</span>
    <span class=n>interval</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>full</span><span class=p>(</span><span class=n>timestamps</span><span class=o>.</span><span class=n>shape</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>)</span>

    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>intervals</span><span class=p>):</span>
        <span class=c1># Find the leftmost index of a timestamp that is &gt;= start</span>
        <span class=n>left</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>side</span><span class=o>=</span><span class=s2>&quot;left&quot;</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>left</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>timestamps</span><span class=p>):</span>
            <span class=c1># If start is greater than all timestamps, skip this interval</span>
            <span class=k>continue</span>
        <span class=c1># Find the rightmost index of a timestamp that is &lt;= end</span>
        <span class=n>right</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>side</span><span class=o>=</span><span class=s2>&quot;right&quot;</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>right</span> <span class=o>==</span> <span class=n>left</span><span class=p>:</span>
            <span class=c1># If there are no timestamps in the interval, skip it</span>
            <span class=k>continue</span>
        <span class=c1># Mark the timestamps in the interval</span>
        <span class=n>in_interval</span><span class=p>[</span><span class=n>left</span><span class=p>:</span><span class=n>right</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
        <span class=n>interval</span><span class=p>[</span><span class=n>left</span><span class=p>:</span><span class=n>right</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>

    <span class=k>if</span> <span class=n>shift</span><span class=p>:</span>
        <span class=c1># Restrict to the timestamps that fall within the intervals</span>
        <span class=n>interval</span> <span class=o>=</span> <span class=n>interval</span><span class=p>[</span><span class=n>in_interval</span><span class=p>]</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>

        <span class=c1># Calculate shifts based on intervals</span>
        <span class=n>shifts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>cumsum</span><span class=p>(</span><span class=n>intervals</span><span class=p>[</span><span class=mi>1</span><span class=p>:,</span> <span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>intervals</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)[</span>
            <span class=n>interval</span>
        <span class=p>]</span>

        <span class=c1># Apply shifts to timestamps</span>
        <span class=n>shifted_timestamps</span> <span class=o>=</span> <span class=n>timestamps</span><span class=p>[</span><span class=n>in_interval</span><span class=p>]</span> <span class=o>-</span> <span class=n>shifts</span> <span class=o>-</span> <span class=n>intervals</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span>

    <span class=k>if</span> <span class=n>return_interval</span> <span class=ow>and</span> <span class=n>shift</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>in_interval</span><span class=p>,</span> <span class=n>interval</span><span class=p>,</span> <span class=n>shifted_timestamps</span>

    <span class=k>if</span> <span class=n>return_interval</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>in_interval</span><span class=p>,</span> <span class=n>interval</span>

    <span class=k>if</span> <span class=n>shift</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>in_interval</span><span class=p>,</span> <span class=n>shifted_timestamps</span>

    <span class=k>return</span> <span class=n>in_interval</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.in_intervals_interval class="doc doc-heading"> <code class="highlight language-python"><span class=n>in_intervals_interval</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>intervals</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>for each timestamps value, the index of the interval to which it belongs (nan = none)</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>timestamps</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of timestamp values. assumes sorted</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>intervals</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time intervals, represented as pairs of start and end times.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A ndarray indicating for each timestamps which interval it was within.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>Note</code></td> <td> <code>produces same result as in_intervals with return_interval=True</code> </td> <td> <div class=doc-md-description> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>timestamps</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>],</span> <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>in_intervals_interval</span><span class=p>(</span><span class=n>timestamps</span><span class=p>,</span> <span class=n>intervals</span><span class=p>)</span>
<span class=go>array([nan,  0,  0,  0,  1,  1,  1, nan])</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>387</span>
<span class=normal>388</span>
<span class=normal>389</span>
<span class=normal>390</span>
<span class=normal>391</span>
<span class=normal>392</span>
<span class=normal>393</span>
<span class=normal>394</span>
<span class=normal>395</span>
<span class=normal>396</span>
<span class=normal>397</span>
<span class=normal>398</span>
<span class=normal>399</span>
<span class=normal>400</span>
<span class=normal>401</span>
<span class=normal>402</span>
<span class=normal>403</span>
<span class=normal>404</span>
<span class=normal>405</span>
<span class=normal>406</span>
<span class=normal>407</span>
<span class=normal>408</span>
<span class=normal>409</span>
<span class=normal>410</span>
<span class=normal>411</span>
<span class=normal>412</span>
<span class=normal>413</span>
<span class=normal>414</span>
<span class=normal>415</span>
<span class=normal>416</span>
<span class=normal>417</span>
<span class=normal>418</span>
<span class=normal>419</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>parallel</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>in_intervals_interval</span><span class=p>(</span><span class=n>timestamps</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>intervals</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    for each timestamps value, the index of the interval to which it belongs (nan = none)</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    timestamps : ndarray</span>
<span class=sd>        An array of timestamp values. assumes sorted</span>
<span class=sd>    intervals : ndarray</span>
<span class=sd>        An array of time intervals, represented as pairs of start and end times.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    ndarray</span>
<span class=sd>        A ndarray indicating for each timestamps which interval it was within.</span>

<span class=sd>    Note: produces same result as in_intervals with return_interval=True</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; timestamps = np.array([1, 2, 3, 4, 5, 6, 7, 8])</span>
<span class=sd>    &gt;&gt;&gt; intervals = np.array([[2, 4], [5, 7]])</span>
<span class=sd>    &gt;&gt;&gt; in_intervals_interval(timestamps, intervals)</span>
<span class=sd>    array([nan,  0,  0,  0,  1,  1,  1, nan])</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>in_interval</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>full</span><span class=p>(</span><span class=n>timestamps</span><span class=o>.</span><span class=n>shape</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>numba</span><span class=o>.</span><span class=n>prange</span><span class=p>(</span><span class=n>intervals</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span>
        <span class=n>start</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=n>intervals</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
        <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>timestamps</span> <span class=o>&gt;=</span> <span class=n>start</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>timestamps</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=p>)</span>
        <span class=n>in_interval</span><span class=p>[</span><span class=n>mask</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>

    <span class=k>return</span> <span class=n>in_interval</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.joint_peth class="doc doc-heading"> <code class="highlight language-python"><span class=n>joint_peth</span><span class=p>(</span><span class=n>peth_1</span><span class=p>,</span> <span class=n>peth_2</span><span class=p>,</span> <span class=n>smooth_std</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>joint_peth - produce a joint histogram for the co-occurrence of two sets of signals around events.</p> <p>This analysis tests for interactions. For example, the interaction of ripples and spindles around the occurrence of delta waves. It is a good way to control whether the relationships between two variables is entirely explained by a third variable (the events serving as basis for the PETHs).</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>peth_1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The first peri-event time histogram (PETH) signal, shape (n_events, n_time).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>peth_2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The second peri-event time histogram (PETH) signal, shape (n_events, n_time).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>smooth_std</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The standard deviation of the Gaussian smoothing kernel (default is 2).</p> </div> </td> <td> <code>2</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>joint</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The joint histogram of the two PETH signals (n_time, n_time).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>expected</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The expected histogram of the two PETH signals (n_time, n_time).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>difference</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>The difference between the joint and expected histograms of the two PETH signals (n_time, n_time).</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.process.peri_event</span><span class=w> </span><span class=kn>import</span> <span class=n>joint_peth</span><span class=p>,</span> <span class=n>peth_matrix</span><span class=p>,</span> <span class=n>joint_peth</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.spikes.spike_tools</span><span class=w> </span><span class=kn>import</span> <span class=n>get_spindices</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.io</span><span class=w> </span><span class=kn>import</span> <span class=n>loading</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load ripples, delta waves, and PFC pyramidal cell spikes from basepath</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>basepath</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;Z:\Data\HMC1\day8&quot;</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>ripples</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_ripples_events</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>delta_waves</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_events</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>epoch_name</span><span class=o>=</span><span class=s2>&quot;deltaWaves&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span><span class=n>cm</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span><span class=n>brainRegion</span><span class=o>=</span><span class=s2>&quot;PFC&quot;</span><span class=p>,</span><span class=n>putativeCellType</span><span class=o>=</span><span class=s2>&quot;Pyr&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># flatten spikes (nelpy has .flatten(), but get_spindices is much faster)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>spikes</span> <span class=o>=</span> <span class=n>get_spindices</span><span class=p>(</span><span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># create peri-event time histograms (PETHs) for the three signals</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>labels</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&quot;spikes&quot;</span><span class=p>,</span> <span class=s2>&quot;ripple&quot;</span><span class=p>,</span> <span class=s2>&quot;delta&quot;</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_1</span><span class=p>,</span><span class=n>ts</span> <span class=o>=</span> <span class=n>peth_matrix</span><span class=p>(</span><span class=n>spikes</span><span class=o>.</span><span class=n>spike_times</span><span class=o>.</span><span class=n>values</span><span class=p>,</span> <span class=n>delta_waves</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.02</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>101</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>peth_2</span><span class=p>,</span><span class=n>ts</span> <span class=o>=</span> <span class=n>peth_matrix</span><span class=p>(</span><span class=n>ripples</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>delta_waves</span><span class=o>.</span><span class=n>starts</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.02</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>101</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># calculate the joint, expected, and difference histograms</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>joint</span><span class=p>,</span> <span class=n>expected</span><span class=p>,</span> <span class=n>difference</span> <span class=o>=</span> <span class=n>joint_peth</span><span class=p>(</span><span class=n>peth_1</span><span class=o>.</span><span class=n>T</span><span class=p>,</span> <span class=n>peth_2</span><span class=o>.</span><span class=n>T</span><span class=p>,</span> <span class=n>smooth_std</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
</code></pre></div> <details class=note open> <summary>Notes</summary> <p>Note: sometimes the difference between "joint" and "expected" may be dominated due to brain state effects (e.g. if both ripples are spindles are more common around delta waves taking place in early SWS and have decreased rates around delta waves in late SWS, then all the values of "joint" would be larger than the value of "expected". In such a case, to investigate the timing effects in particular and ignore such global changes (correlations across the rows of "PETH1" and "PETH2"), consider normalizing the rows of the PETHs before calling joint_peth.</p> <p>See Sirota et al. (2003)</p> <p>Adapted from JointPETH.m, Copyright (C) 2018-2022 by Ralitsa Todorova</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>168</span>
<span class=normal>169</span>
<span class=normal>170</span>
<span class=normal>171</span>
<span class=normal>172</span>
<span class=normal>173</span>
<span class=normal>174</span>
<span class=normal>175</span>
<span class=normal>176</span>
<span class=normal>177</span>
<span class=normal>178</span>
<span class=normal>179</span>
<span class=normal>180</span>
<span class=normal>181</span>
<span class=normal>182</span>
<span class=normal>183</span>
<span class=normal>184</span>
<span class=normal>185</span>
<span class=normal>186</span>
<span class=normal>187</span>
<span class=normal>188</span>
<span class=normal>189</span>
<span class=normal>190</span>
<span class=normal>191</span>
<span class=normal>192</span>
<span class=normal>193</span>
<span class=normal>194</span>
<span class=normal>195</span>
<span class=normal>196</span>
<span class=normal>197</span>
<span class=normal>198</span>
<span class=normal>199</span>
<span class=normal>200</span>
<span class=normal>201</span>
<span class=normal>202</span>
<span class=normal>203</span>
<span class=normal>204</span>
<span class=normal>205</span>
<span class=normal>206</span>
<span class=normal>207</span>
<span class=normal>208</span>
<span class=normal>209</span>
<span class=normal>210</span>
<span class=normal>211</span>
<span class=normal>212</span>
<span class=normal>213</span>
<span class=normal>214</span>
<span class=normal>215</span>
<span class=normal>216</span>
<span class=normal>217</span>
<span class=normal>218</span>
<span class=normal>219</span>
<span class=normal>220</span>
<span class=normal>221</span>
<span class=normal>222</span>
<span class=normal>223</span>
<span class=normal>224</span>
<span class=normal>225</span>
<span class=normal>226</span>
<span class=normal>227</span>
<span class=normal>228</span>
<span class=normal>229</span>
<span class=normal>230</span>
<span class=normal>231</span>
<span class=normal>232</span>
<span class=normal>233</span>
<span class=normal>234</span>
<span class=normal>235</span>
<span class=normal>236</span>
<span class=normal>237</span>
<span class=normal>238</span>
<span class=normal>239</span>
<span class=normal>240</span>
<span class=normal>241</span>
<span class=normal>242</span>
<span class=normal>243</span>
<span class=normal>244</span>
<span class=normal>245</span>
<span class=normal>246</span>
<span class=normal>247</span>
<span class=normal>248</span>
<span class=normal>249</span>
<span class=normal>250</span>
<span class=normal>251</span>
<span class=normal>252</span>
<span class=normal>253</span>
<span class=normal>254</span>
<span class=normal>255</span>
<span class=normal>256</span>
<span class=normal>257</span>
<span class=normal>258</span>
<span class=normal>259</span>
<span class=normal>260</span>
<span class=normal>261</span>
<span class=normal>262</span>
<span class=normal>263</span>
<span class=normal>264</span>
<span class=normal>265</span>
<span class=normal>266</span>
<span class=normal>267</span>
<span class=normal>268</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>joint_peth</span><span class=p>(</span>
    <span class=n>peth_1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>peth_2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>smooth_std</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>2</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    joint_peth - produce a joint histogram for the co-occurrence of two sets of signals around events.</span>

<span class=sd>    This analysis tests for interactions. For example, the interaction of</span>
<span class=sd>    ripples and spindles around the occurrence of delta waves. It is a good way</span>
<span class=sd>    to control whether the relationships between two variables is entirely explained</span>
<span class=sd>    by a third variable (the events serving as basis for the PETHs).</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    peth_1 : np.ndarray</span>
<span class=sd>        The first peri-event time histogram (PETH) signal, shape (n_events, n_time).</span>
<span class=sd>    peth_2 : np.ndarray</span>
<span class=sd>        The second peri-event time histogram (PETH) signal, shape (n_events, n_time).</span>
<span class=sd>    smooth_std : float, optional</span>
<span class=sd>        The standard deviation of the Gaussian smoothing kernel (default is 2).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    joint : np.ndarray</span>
<span class=sd>        The joint histogram of the two PETH signals (n_time, n_time).</span>
<span class=sd>    expected : np.ndarray</span>
<span class=sd>        The expected histogram of the two PETH signals (n_time, n_time).</span>
<span class=sd>    difference : np.ndarray</span>
<span class=sd>        The difference between the joint and expected histograms of the two PETH signals (n_time, n_time).</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.process.peri_event import joint_peth, peth_matrix, joint_peth</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.spikes.spike_tools import get_spindices</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.io import loading</span>

<span class=sd>    &gt;&gt;&gt; # load ripples, delta waves, and PFC pyramidal cell spikes from basepath</span>

<span class=sd>    &gt;&gt;&gt; basepath = r&quot;Z:\\Data\\HMC1\\day8&quot;</span>

<span class=sd>    &gt;&gt;&gt; ripples = loading.load_ripples_events(basepath, return_epoch_array=True)</span>
<span class=sd>    &gt;&gt;&gt; delta_waves = loading.load_events(basepath, epoch_name=&quot;deltaWaves&quot;)</span>
<span class=sd>    &gt;&gt;&gt; st,cm = loading.load_spikes(basepath,brainRegion=&quot;PFC&quot;,putativeCellType=&quot;Pyr&quot;)</span>

<span class=sd>    &gt;&gt;&gt; # flatten spikes (nelpy has .flatten(), but get_spindices is much faster)</span>
<span class=sd>    &gt;&gt;&gt; spikes = get_spindices(st.data)</span>

<span class=sd>    &gt;&gt;&gt; # create peri-event time histograms (PETHs) for the three signals</span>
<span class=sd>    &gt;&gt;&gt; window=[-1,1]</span>
<span class=sd>    &gt;&gt;&gt; labels = [&quot;spikes&quot;, &quot;ripple&quot;, &quot;delta&quot;]</span>
<span class=sd>    &gt;&gt;&gt; peth_1,ts = peth_matrix(spikes.spike_times.values, delta_waves.starts, bin_width=0.02, n_bins=101)</span>
<span class=sd>    &gt;&gt;&gt; peth_2,ts = peth_matrix(ripples.starts, delta_waves.starts, bin_width=0.02, n_bins=101)</span>

<span class=sd>    &gt;&gt;&gt; # calculate the joint, expected, and difference histograms</span>
<span class=sd>    &gt;&gt;&gt; joint, expected, difference = joint_peth(peth_1.T, peth_2.T, smooth_std=2)</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Note: sometimes the difference between &quot;joint&quot; and &quot;expected&quot; may be dominated due to</span>
<span class=sd>    brain state effects (e.g. if both ripples are spindles are more common around delta</span>
<span class=sd>    waves taking place in early SWS and have decreased rates around delta waves in late</span>
<span class=sd>    SWS, then all the values of &quot;joint&quot; would be larger than the value of &quot;expected&quot;.</span>
<span class=sd>    In such a case, to investigate the timing effects in particular and ignore such</span>
<span class=sd>    global changes (correlations across the rows of &quot;PETH1&quot; and &quot;PETH2&quot;), consider</span>
<span class=sd>    normalizing the rows of the PETHs before calling joint_peth.</span>

<span class=sd>    See Sirota et al. (2003)</span>

<span class=sd>    Adapted from JointPETH.m, Copyright (C) 2018-2022 by Ralitsa Todorova</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=kn>from</span><span class=w> </span><span class=nn>scipy.ndimage</span><span class=w> </span><span class=kn>import</span> <span class=n>gaussian_filter</span>

    <span class=c1># make inputs np.ndarrays</span>
    <span class=n>peth_1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>peth_1</span><span class=p>)</span>
    <span class=n>peth_2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>peth_2</span><span class=p>)</span>

    <span class=c1># calculate the joint histogram</span>
    <span class=n>joint</span> <span class=o>=</span> <span class=n>peth_1</span><span class=o>.</span><span class=n>T</span> <span class=o>@</span> <span class=n>peth_2</span>

    <span class=c1># smooth the 2d joint histogram</span>
    <span class=n>joint</span> <span class=o>=</span> <span class=n>gaussian_filter</span><span class=p>(</span><span class=n>joint</span><span class=p>,</span> <span class=n>smooth_std</span><span class=p>)</span>

    <span class=c1># calculate the expected histogram</span>
    <span class=n>expected</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>peth_1</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>),</span> <span class=p>[</span><span class=n>peth_1</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=mi>1</span><span class=p>])</span><span class=o>.</span><span class=n>T</span> <span class=o>@</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=n>peth_2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>),</span> <span class=p>[</span><span class=n>peth_2</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=mi>1</span><span class=p>]</span>
    <span class=p>)</span>

    <span class=c1># smooth the 2d expected histogram</span>
    <span class=n>expected</span> <span class=o>=</span> <span class=n>gaussian_filter</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=n>smooth_std</span><span class=p>)</span>

    <span class=c1># normalize the joint and expected histograms</span>
    <span class=n>joint</span> <span class=o>=</span> <span class=n>joint</span> <span class=o>/</span> <span class=n>peth_1</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>expected</span> <span class=o>=</span> <span class=n>expected</span> <span class=o>/</span> <span class=n>peth_1</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>

    <span class=c1># square root the joint and expected histograms so result is Hz</span>
    <span class=n>joint</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>joint</span><span class=p>)</span>
    <span class=n>expected</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>expected</span><span class=p>)</span>

    <span class=c1># calculate the difference between the joint and expected histograms</span>
    <span class=n>difference</span> <span class=o>=</span> <span class=n>joint</span> <span class=o>-</span> <span class=n>expected</span>

    <span class=k>return</span> <span class=n>joint</span><span class=p>,</span> <span class=n>expected</span><span class=p>,</span> <span class=n>difference</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.load_results class="doc doc-heading"> <code class="highlight language-python"><span class=n>load_results</span><span class=p>(</span><span class=n>save_path</span><span class=p>,</span> <span class=n>verbose</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>add_save_file_name</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>format_type</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Load results from pickled pandas DataFrames or HDF5 files in the specified directory.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>save_path</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Path to the folder containing pickled results.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>verbose</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to print progress for each file. Defaults to False.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>add_save_file_name</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to add a column with the name of the save file. Defaults to False.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>format_type</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=typing.Literal>Literal</span>[&#39;pickle&#39;, &#39;hdf5&#39;]]</code> </td> <td> <div class=doc-md-description> <p>File format to load. If None, will auto-detect based on file extension.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>Concatenated pandas DataFrame with all results.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Raises:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=ValueError>ValueError</span></code> </td> <td> <div class=doc-md-description> <p>If the specified folder does not exist or is empty.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/batch_analysis.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>647</span>
<span class=normal>648</span>
<span class=normal>649</span>
<span class=normal>650</span>
<span class=normal>651</span>
<span class=normal>652</span>
<span class=normal>653</span>
<span class=normal>654</span>
<span class=normal>655</span>
<span class=normal>656</span>
<span class=normal>657</span>
<span class=normal>658</span>
<span class=normal>659</span>
<span class=normal>660</span>
<span class=normal>661</span>
<span class=normal>662</span>
<span class=normal>663</span>
<span class=normal>664</span>
<span class=normal>665</span>
<span class=normal>666</span>
<span class=normal>667</span>
<span class=normal>668</span>
<span class=normal>669</span>
<span class=normal>670</span>
<span class=normal>671</span>
<span class=normal>672</span>
<span class=normal>673</span>
<span class=normal>674</span>
<span class=normal>675</span>
<span class=normal>676</span>
<span class=normal>677</span>
<span class=normal>678</span>
<span class=normal>679</span>
<span class=normal>680</span>
<span class=normal>681</span>
<span class=normal>682</span>
<span class=normal>683</span>
<span class=normal>684</span>
<span class=normal>685</span>
<span class=normal>686</span>
<span class=normal>687</span>
<span class=normal>688</span>
<span class=normal>689</span>
<span class=normal>690</span>
<span class=normal>691</span>
<span class=normal>692</span>
<span class=normal>693</span>
<span class=normal>694</span>
<span class=normal>695</span>
<span class=normal>696</span>
<span class=normal>697</span>
<span class=normal>698</span>
<span class=normal>699</span>
<span class=normal>700</span>
<span class=normal>701</span>
<span class=normal>702</span>
<span class=normal>703</span>
<span class=normal>704</span>
<span class=normal>705</span>
<span class=normal>706</span>
<span class=normal>707</span>
<span class=normal>708</span>
<span class=normal>709</span>
<span class=normal>710</span>
<span class=normal>711</span>
<span class=normal>712</span>
<span class=normal>713</span>
<span class=normal>714</span>
<span class=normal>715</span>
<span class=normal>716</span>
<span class=normal>717</span>
<span class=normal>718</span>
<span class=normal>719</span>
<span class=normal>720</span>
<span class=normal>721</span>
<span class=normal>722</span>
<span class=normal>723</span>
<span class=normal>724</span>
<span class=normal>725</span>
<span class=normal>726</span>
<span class=normal>727</span>
<span class=normal>728</span>
<span class=normal>729</span>
<span class=normal>730</span>
<span class=normal>731</span>
<span class=normal>732</span>
<span class=normal>733</span>
<span class=normal>734</span>
<span class=normal>735</span>
<span class=normal>736</span>
<span class=normal>737</span>
<span class=normal>738</span>
<span class=normal>739</span>
<span class=normal>740</span>
<span class=normal>741</span>
<span class=normal>742</span>
<span class=normal>743</span>
<span class=normal>744</span>
<span class=normal>745</span>
<span class=normal>746</span>
<span class=normal>747</span>
<span class=normal>748</span>
<span class=normal>749</span>
<span class=normal>750</span>
<span class=normal>751</span>
<span class=normal>752</span>
<span class=normal>753</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>load_results</span><span class=p>(</span>
    <span class=n>save_path</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=n>verbose</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
    <span class=n>add_save_file_name</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
    <span class=n>format_type</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=n>Literal</span><span class=p>[</span><span class=s2>&quot;pickle&quot;</span><span class=p>,</span> <span class=s2>&quot;hdf5&quot;</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Load results from pickled pandas DataFrames or HDF5 files in the specified directory.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    save_path : str</span>
<span class=sd>        Path to the folder containing pickled results.</span>
<span class=sd>    verbose : bool, optional</span>
<span class=sd>        Whether to print progress for each file. Defaults to False.</span>
<span class=sd>    add_save_file_name : bool, optional</span>
<span class=sd>        Whether to add a column with the name of the save file. Defaults to False.</span>
<span class=sd>    format_type : Optional[Literal[&quot;pickle&quot;, &quot;hdf5&quot;]], optional</span>
<span class=sd>        File format to load. If None, will auto-detect based on file extension.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame</span>
<span class=sd>        Concatenated pandas DataFrame with all results.</span>

<span class=sd>    Raises</span>
<span class=sd>    ------</span>
<span class=sd>    ValueError</span>
<span class=sd>        If the specified folder does not exist or is empty.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>exists</span><span class=p>(</span><span class=n>save_path</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;folder </span><span class=si>{</span><span class=n>save_path</span><span class=si>}</span><span class=s2> does not exist&quot;</span><span class=p>)</span>

    <span class=c1># Determine file pattern based on format_type</span>
    <span class=k>if</span> <span class=n>format_type</span> <span class=o>==</span> <span class=s2>&quot;pickle&quot;</span><span class=p>:</span>
        <span class=n>file_pattern</span> <span class=o>=</span> <span class=s2>&quot;*.pkl&quot;</span>
    <span class=k>elif</span> <span class=n>format_type</span> <span class=o>==</span> <span class=s2>&quot;hdf5&quot;</span><span class=p>:</span>
        <span class=n>file_pattern</span> <span class=o>=</span> <span class=s2>&quot;*.h5&quot;</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=c1># Auto-detect: look for both formats</span>
        <span class=n>file_pattern</span> <span class=o>=</span> <span class=s2>&quot;*&quot;</span>

    <span class=n>sessions</span> <span class=o>=</span> <span class=n>glob</span><span class=o>.</span><span class=n>glob</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>save_path</span><span class=p>,</span> <span class=n>file_pattern</span><span class=p>))</span>

    <span class=c1># Filter by supported extensions if auto-detecting</span>
    <span class=k>if</span> <span class=n>format_type</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>sessions</span> <span class=o>=</span> <span class=p>[</span><span class=n>s</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>sessions</span> <span class=k>if</span> <span class=n>s</span><span class=o>.</span><span class=n>endswith</span><span class=p>((</span><span class=s2>&quot;.pkl&quot;</span><span class=p>,</span> <span class=s2>&quot;.h5&quot;</span><span class=p>))]</span>

    <span class=c1># Sort sessions for consistent ordering</span>
    <span class=n>sessions</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>

    <span class=n>results</span> <span class=o>=</span> <span class=p>[]</span>

    <span class=k>for</span> <span class=n>session</span> <span class=ow>in</span> <span class=n>sessions</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>verbose</span><span class=p>:</span>
            <span class=nb>print</span><span class=p>(</span><span class=n>session</span><span class=p>)</span>

        <span class=c1># Determine format based on file extension</span>
        <span class=k>if</span> <span class=n>session</span><span class=o>.</span><span class=n>endswith</span><span class=p>(</span><span class=s2>&quot;.h5&quot;</span><span class=p>):</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=n>results_</span> <span class=o>=</span> <span class=n>_load_from_hdf5</span><span class=p>(</span><span class=n>session</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Error loading HDF5 file </span><span class=si>{</span><span class=n>session</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
                <span class=k>continue</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>session</span><span class=p>,</span> <span class=s2>&quot;rb&quot;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
                    <span class=n>results_</span> <span class=o>=</span> <span class=n>pickle</span><span class=o>.</span><span class=n>load</span><span class=p>(</span><span class=n>f</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Error loading pickle file </span><span class=si>{</span><span class=n>session</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
                <span class=k>continue</span>

        <span class=k>if</span> <span class=n>results_</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=k>continue</span>

        <span class=c1># Convert to DataFrame if it&#39;s a dict containing a single DataFrame</span>
        <span class=k>if</span> <span class=p>(</span>
            <span class=nb>isinstance</span><span class=p>(</span><span class=n>results_</span><span class=p>,</span> <span class=nb>dict</span><span class=p>)</span>
            <span class=ow>and</span> <span class=nb>len</span><span class=p>(</span><span class=n>results_</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span>
            <span class=ow>and</span> <span class=nb>isinstance</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>results_</span><span class=o>.</span><span class=n>values</span><span class=p>())[</span><span class=mi>0</span><span class=p>],</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>)</span>
        <span class=p>):</span>
            <span class=n>results_</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>results_</span><span class=o>.</span><span class=n>values</span><span class=p>())[</span><span class=mi>0</span><span class=p>]</span>
        <span class=k>elif</span> <span class=p>(</span>
            <span class=nb>isinstance</span><span class=p>(</span><span class=n>results_</span><span class=p>,</span> <span class=nb>dict</span><span class=p>)</span>
            <span class=ow>and</span> <span class=s2>&quot;dataframe&quot;</span> <span class=ow>in</span> <span class=n>results_</span>
            <span class=ow>and</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>results_</span><span class=p>[</span><span class=s2>&quot;dataframe&quot;</span><span class=p>],</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>)</span>
        <span class=p>):</span>
            <span class=n>results_</span> <span class=o>=</span> <span class=n>results_</span><span class=p>[</span><span class=s2>&quot;dataframe&quot;</span><span class=p>]</span>

        <span class=c1># Ensure we have a DataFrame</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>results_</span><span class=p>,</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>):</span>
            <span class=k>if</span> <span class=n>verbose</span><span class=p>:</span>
                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Skipping </span><span class=si>{</span><span class=n>session</span><span class=si>}</span><span class=s2>: not a DataFrame&quot;</span><span class=p>)</span>
            <span class=k>continue</span>

        <span class=k>if</span> <span class=n>add_save_file_name</span><span class=p>:</span>
            <span class=n>results_</span><span class=p>[</span><span class=s2>&quot;save_file_name&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>basename</span><span class=p>(</span><span class=n>session</span><span class=p>)</span>

        <span class=n>results</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>results_</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>results</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;No valid results found in </span><span class=si>{</span><span class=n>save_path</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

    <span class=n>results</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=n>results</span><span class=p>,</span> <span class=n>ignore_index</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>results</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.mtcoherencept class="doc doc-heading"> <code class="highlight language-python"><span class=n>mtcoherencept</span><span class=p>(</span><span class=n>data1</span><span class=p>,</span> <span class=n>data2</span><span class=p>,</span> <span class=n>Fs</span><span class=p>,</span> <span class=n>fpass</span><span class=p>,</span> <span class=n>NW</span><span class=o>=</span><span class=mf>2.5</span><span class=p>,</span> <span class=n>n_tapers</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>time_support</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>tapers</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>nfft</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Multitaper coherence for point processes.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of spike times for the first signal (in seconds).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>data2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of spike times for the second signal (in seconds).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>Fs</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fpass</code> </td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>Frequency range to evaluate as [min_freq, max_freq].</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>NW</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=int>int</span>, <span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>Time-bandwidth product, by default 2.5.</p> </div> </td> <td> <code>2.5</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_tapers</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of tapers, by default 4.</p> </div> </td> <td> <code>4</code> </td> </tr> <tr class=doc-section-item> <td> <code>time_support</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=list>list</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Time range to evaluate, by default None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>tapers</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Precomputed tapers, given as [NW, K] or [tapers, eigenvalues], by default None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>tapers_ts</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Taper time series, by default None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>nfft</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=int>int</span>]</code> </td> <td> <div class=doc-md-description> <p>Number of points for FFT, by default None.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>Coherence between the two point processes.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>570</span>
<span class=normal>571</span>
<span class=normal>572</span>
<span class=normal>573</span>
<span class=normal>574</span>
<span class=normal>575</span>
<span class=normal>576</span>
<span class=normal>577</span>
<span class=normal>578</span>
<span class=normal>579</span>
<span class=normal>580</span>
<span class=normal>581</span>
<span class=normal>582</span>
<span class=normal>583</span>
<span class=normal>584</span>
<span class=normal>585</span>
<span class=normal>586</span>
<span class=normal>587</span>
<span class=normal>588</span>
<span class=normal>589</span>
<span class=normal>590</span>
<span class=normal>591</span>
<span class=normal>592</span>
<span class=normal>593</span>
<span class=normal>594</span>
<span class=normal>595</span>
<span class=normal>596</span>
<span class=normal>597</span>
<span class=normal>598</span>
<span class=normal>599</span>
<span class=normal>600</span>
<span class=normal>601</span>
<span class=normal>602</span>
<span class=normal>603</span>
<span class=normal>604</span>
<span class=normal>605</span>
<span class=normal>606</span>
<span class=normal>607</span>
<span class=normal>608</span>
<span class=normal>609</span>
<span class=normal>610</span>
<span class=normal>611</span>
<span class=normal>612</span>
<span class=normal>613</span>
<span class=normal>614</span>
<span class=normal>615</span>
<span class=normal>616</span>
<span class=normal>617</span>
<span class=normal>618</span>
<span class=normal>619</span>
<span class=normal>620</span>
<span class=normal>621</span>
<span class=normal>622</span>
<span class=normal>623</span>
<span class=normal>624</span>
<span class=normal>625</span>
<span class=normal>626</span>
<span class=normal>627</span>
<span class=normal>628</span>
<span class=normal>629</span>
<span class=normal>630</span>
<span class=normal>631</span>
<span class=normal>632</span>
<span class=normal>633</span>
<span class=normal>634</span>
<span class=normal>635</span>
<span class=normal>636</span>
<span class=normal>637</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>mtcoherencept</span><span class=p>(</span>
    <span class=n>data1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>data2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>Fs</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
    <span class=n>fpass</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span>
    <span class=n>NW</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>,</span>
    <span class=n>n_tapers</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span>
    <span class=n>time_support</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>list</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>tapers</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>tapers_ts</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>nfft</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Multitaper coherence for point processes.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data1 : np.ndarray</span>
<span class=sd>        Array of spike times for the first signal (in seconds).</span>
<span class=sd>    data2 : np.ndarray</span>
<span class=sd>        Array of spike times for the second signal (in seconds).</span>
<span class=sd>    Fs : int</span>
<span class=sd>        Sampling frequency.</span>
<span class=sd>    fpass : list</span>
<span class=sd>        Frequency range to evaluate as [min_freq, max_freq].</span>
<span class=sd>    NW : Union[int, float], optional</span>
<span class=sd>        Time-bandwidth product, by default 2.5.</span>
<span class=sd>    n_tapers : int, optional</span>
<span class=sd>        Number of tapers, by default 4.</span>
<span class=sd>    time_support : Union[list, None], optional</span>
<span class=sd>        Time range to evaluate, by default None.</span>
<span class=sd>    tapers : Union[np.ndarray, None], optional</span>
<span class=sd>        Precomputed tapers, given as [NW, K] or [tapers, eigenvalues], by default None.</span>
<span class=sd>    tapers_ts : Union[np.ndarray, None], optional</span>
<span class=sd>        Taper time series, by default None.</span>
<span class=sd>    nfft : Optional[int], optional</span>
<span class=sd>        Number of points for FFT, by default None.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame</span>
<span class=sd>        Coherence between the two point processes.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Check if data is a single unit and put in array</span>
    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data1</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>):</span>
        <span class=n>data1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>data1</span><span class=p>])</span>
    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data2</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>):</span>
        <span class=n>data2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>data2</span><span class=p>])</span>

    <span class=c1># Compute power spectral densities (PSD) for both spike trains</span>
    <span class=n>psd1</span> <span class=o>=</span> <span class=n>mtspectrumpt</span><span class=p>(</span>
        <span class=n>data1</span><span class=p>,</span> <span class=n>Fs</span><span class=p>,</span> <span class=n>fpass</span><span class=p>,</span> <span class=n>NW</span><span class=p>,</span> <span class=n>n_tapers</span><span class=p>,</span> <span class=n>time_support</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=p>,</span> <span class=n>nfft</span>
    <span class=p>)</span>
    <span class=n>psd2</span> <span class=o>=</span> <span class=n>mtspectrumpt</span><span class=p>(</span>
        <span class=n>data2</span><span class=p>,</span> <span class=n>Fs</span><span class=p>,</span> <span class=n>fpass</span><span class=p>,</span> <span class=n>NW</span><span class=p>,</span> <span class=n>n_tapers</span><span class=p>,</span> <span class=n>time_support</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=p>,</span> <span class=n>nfft</span>
    <span class=p>)</span>

    <span class=c1># Compute cross-spectral density (CSD) between the two spike trains</span>
    <span class=n>csd</span> <span class=o>=</span> <span class=n>mtcsdpt</span><span class=p>(</span>
        <span class=n>data1</span><span class=p>,</span> <span class=n>data2</span><span class=p>,</span> <span class=n>Fs</span><span class=p>,</span> <span class=n>fpass</span><span class=p>,</span> <span class=n>NW</span><span class=p>,</span> <span class=n>n_tapers</span><span class=p>,</span> <span class=n>time_support</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=p>,</span> <span class=n>nfft</span>
    <span class=p>)</span>

    <span class=c1># Calculate coherence: |Sxy(f)|^2 / (Sxx(f) * Syy(f))</span>
    <span class=n>coherence</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>csd</span><span class=p>[</span><span class=s2>&quot;CSD&quot;</span><span class=p>]</span><span class=o>.</span><span class=n>values</span><span class=p>)</span> <span class=o>**</span> <span class=mi>2</span> <span class=o>/</span> <span class=p>(</span><span class=n>psd1</span><span class=o>.</span><span class=n>values</span> <span class=o>*</span> <span class=n>psd2</span><span class=o>.</span><span class=n>values</span><span class=p>)</span><span class=o>.</span><span class=n>flatten</span><span class=p>()</span>

    <span class=c1># Return coherence as a pandas DataFrame</span>
    <span class=n>coherence_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>csd</span><span class=o>.</span><span class=n>index</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=n>coherence</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s2>&quot;Coherence&quot;</span><span class=p>])</span>
    <span class=k>return</span> <span class=n>coherence_df</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.mtcsdpt class="doc doc-heading"> <code class="highlight language-python"><span class=n>mtcsdpt</span><span class=p>(</span><span class=n>data1</span><span class=p>,</span> <span class=n>data2</span><span class=p>,</span> <span class=n>Fs</span><span class=p>,</span> <span class=n>fpass</span><span class=p>,</span> <span class=n>NW</span><span class=o>=</span><span class=mf>2.5</span><span class=p>,</span> <span class=n>n_tapers</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>time_support</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>tapers</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>nfft</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Multitaper cross-spectral density (CSD) for point processes.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of spike times for the first signal (in seconds).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>data2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of spike times for the second signal (in seconds).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>Fs</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fpass</code> </td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>Frequency range to evaluate as [min_freq, max_freq].</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>NW</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=int>int</span>, <span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>Time-bandwidth product, by default 2.5.</p> </div> </td> <td> <code>2.5</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_tapers</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of tapers, by default 4.</p> </div> </td> <td> <code>4</code> </td> </tr> <tr class=doc-section-item> <td> <code>time_support</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=list>list</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Time range to evaluate, by default None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>tapers</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Precomputed tapers, given as [NW, K] or [tapers, eigenvalues], by default None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>tapers_ts</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Taper time series, by default None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>nfft</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=int>int</span>]</code> </td> <td> <div class=doc-md-description> <p>Number of points for FFT, by default None.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>Cross-spectral density between the two point processes.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>495</span>
<span class=normal>496</span>
<span class=normal>497</span>
<span class=normal>498</span>
<span class=normal>499</span>
<span class=normal>500</span>
<span class=normal>501</span>
<span class=normal>502</span>
<span class=normal>503</span>
<span class=normal>504</span>
<span class=normal>505</span>
<span class=normal>506</span>
<span class=normal>507</span>
<span class=normal>508</span>
<span class=normal>509</span>
<span class=normal>510</span>
<span class=normal>511</span>
<span class=normal>512</span>
<span class=normal>513</span>
<span class=normal>514</span>
<span class=normal>515</span>
<span class=normal>516</span>
<span class=normal>517</span>
<span class=normal>518</span>
<span class=normal>519</span>
<span class=normal>520</span>
<span class=normal>521</span>
<span class=normal>522</span>
<span class=normal>523</span>
<span class=normal>524</span>
<span class=normal>525</span>
<span class=normal>526</span>
<span class=normal>527</span>
<span class=normal>528</span>
<span class=normal>529</span>
<span class=normal>530</span>
<span class=normal>531</span>
<span class=normal>532</span>
<span class=normal>533</span>
<span class=normal>534</span>
<span class=normal>535</span>
<span class=normal>536</span>
<span class=normal>537</span>
<span class=normal>538</span>
<span class=normal>539</span>
<span class=normal>540</span>
<span class=normal>541</span>
<span class=normal>542</span>
<span class=normal>543</span>
<span class=normal>544</span>
<span class=normal>545</span>
<span class=normal>546</span>
<span class=normal>547</span>
<span class=normal>548</span>
<span class=normal>549</span>
<span class=normal>550</span>
<span class=normal>551</span>
<span class=normal>552</span>
<span class=normal>553</span>
<span class=normal>554</span>
<span class=normal>555</span>
<span class=normal>556</span>
<span class=normal>557</span>
<span class=normal>558</span>
<span class=normal>559</span>
<span class=normal>560</span>
<span class=normal>561</span>
<span class=normal>562</span>
<span class=normal>563</span>
<span class=normal>564</span>
<span class=normal>565</span>
<span class=normal>566</span>
<span class=normal>567</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>mtcsdpt</span><span class=p>(</span>
    <span class=n>data1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>data2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>Fs</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
    <span class=n>fpass</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span>
    <span class=n>NW</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>,</span>
    <span class=n>n_tapers</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span>
    <span class=n>time_support</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>list</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>tapers</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>tapers_ts</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>nfft</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Multitaper cross-spectral density (CSD) for point processes.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data1 : np.ndarray</span>
<span class=sd>        Array of spike times for the first signal (in seconds).</span>
<span class=sd>    data2 : np.ndarray</span>
<span class=sd>        Array of spike times for the second signal (in seconds).</span>
<span class=sd>    Fs : int</span>
<span class=sd>        Sampling frequency.</span>
<span class=sd>    fpass : list</span>
<span class=sd>        Frequency range to evaluate as [min_freq, max_freq].</span>
<span class=sd>    NW : Union[int, float], optional</span>
<span class=sd>        Time-bandwidth product, by default 2.5.</span>
<span class=sd>    n_tapers : int, optional</span>
<span class=sd>        Number of tapers, by default 4.</span>
<span class=sd>    time_support : Union[list, None], optional</span>
<span class=sd>        Time range to evaluate, by default None.</span>
<span class=sd>    tapers : Union[np.ndarray, None], optional</span>
<span class=sd>        Precomputed tapers, given as [NW, K] or [tapers, eigenvalues], by default None.</span>
<span class=sd>    tapers_ts : Union[np.ndarray, None], optional</span>
<span class=sd>        Taper time series, by default None.</span>
<span class=sd>    nfft : Optional[int], optional</span>
<span class=sd>        Number of points for FFT, by default None.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame</span>
<span class=sd>        Cross-spectral density between the two point processes.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>time_support</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>mintime</span><span class=p>,</span> <span class=n>maxtime</span> <span class=o>=</span> <span class=n>time_support</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>mintime</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>data1</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>data2</span><span class=p>))</span>
        <span class=n>maxtime</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>data1</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>data2</span><span class=p>))</span>
    <span class=n>dt</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>Fs</span>

    <span class=c1># Create tapers if not provided</span>
    <span class=k>if</span> <span class=n>tapers</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>tapers_ts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>mintime</span> <span class=o>-</span> <span class=n>dt</span><span class=p>,</span> <span class=n>maxtime</span> <span class=o>+</span> <span class=n>dt</span><span class=p>,</span> <span class=n>dt</span><span class=p>)</span>
        <span class=n>N</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>tapers_ts</span><span class=p>)</span>
        <span class=n>tapers</span><span class=p>,</span> <span class=n>eigens</span> <span class=o>=</span> <span class=n>dpss</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>NW</span><span class=p>,</span> <span class=n>n_tapers</span><span class=p>,</span> <span class=n>return_ratios</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

    <span class=n>tapers</span> <span class=o>=</span> <span class=n>tapers</span><span class=o>.</span><span class=n>T</span>
    <span class=n>N</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>tapers_ts</span><span class=p>)</span>

    <span class=c1># Number of points in FFT</span>
    <span class=k>if</span> <span class=n>nfft</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>nfft</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>([</span><span class=nb>int</span><span class=p>(</span><span class=mi>2</span> <span class=o>**</span> <span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>log2</span><span class=p>(</span><span class=n>N</span><span class=p>))),</span> <span class=n>N</span><span class=p>])</span>
    <span class=n>f</span><span class=p>,</span> <span class=n>findx</span> <span class=o>=</span> <span class=n>getfgrid</span><span class=p>(</span><span class=n>Fs</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>fpass</span><span class=p>)</span>

    <span class=c1># Compute the multitaper Fourier transforms of both spike trains</span>
    <span class=n>J1</span><span class=p>,</span> <span class=n>Msp1</span><span class=p>,</span> <span class=n>Nsp1</span> <span class=o>=</span> <span class=n>mtfftpt</span><span class=p>(</span><span class=n>data1</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=p>,</span> <span class=n>f</span><span class=p>,</span> <span class=n>findx</span><span class=p>)</span>
    <span class=n>J2</span><span class=p>,</span> <span class=n>Msp2</span><span class=p>,</span> <span class=n>Nsp2</span> <span class=o>=</span> <span class=n>mtfftpt</span><span class=p>(</span><span class=n>data2</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=p>,</span> <span class=n>f</span><span class=p>,</span> <span class=n>findx</span><span class=p>)</span>

    <span class=c1># Cross-spectral density: Sxy = mean(conjugate(J1) * J2)</span>
    <span class=n>csd</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>real</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>conj</span><span class=p>(</span><span class=n>J1</span><span class=p>)</span> <span class=o>*</span> <span class=n>J2</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>))</span>

    <span class=n>csd_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=n>csd</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s2>&quot;CSD&quot;</span><span class=p>])</span>
    <span class=k>return</span> <span class=n>csd_df</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.mtfftc class="doc doc-heading"> <code class="highlight language-python"><span class=n>mtfftc</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>Fs</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Multi-taper Fourier Transform - Continuous Data (Single Signal)</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of data (samples).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>tapers</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Precomputed DPSS tapers with shape (samples, tapers).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>nfft</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Length of padded data for FFT.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>Fs</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>J</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>FFT in the form (nfft, K), where K is the number of tapers.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>329</span>
<span class=normal>330</span>
<span class=normal>331</span>
<span class=normal>332</span>
<span class=normal>333</span>
<span class=normal>334</span>
<span class=normal>335</span>
<span class=normal>336</span>
<span class=normal>337</span>
<span class=normal>338</span>
<span class=normal>339</span>
<span class=normal>340</span>
<span class=normal>341</span>
<span class=normal>342</span>
<span class=normal>343</span>
<span class=normal>344</span>
<span class=normal>345</span>
<span class=normal>346</span>
<span class=normal>347</span>
<span class=normal>348</span>
<span class=normal>349</span>
<span class=normal>350</span>
<span class=normal>351</span>
<span class=normal>352</span>
<span class=normal>353</span>
<span class=normal>354</span>
<span class=normal>355</span>
<span class=normal>356</span>
<span class=normal>357</span>
<span class=normal>358</span>
<span class=normal>359</span>
<span class=normal>360</span>
<span class=normal>361</span>
<span class=normal>362</span>
<span class=normal>363</span>
<span class=normal>364</span>
<span class=normal>365</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>mtfftc</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>tapers</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>nfft</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>Fs</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Multi-taper Fourier Transform - Continuous Data (Single Signal)</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray</span>
<span class=sd>        1D array of data (samples).</span>
<span class=sd>    tapers : np.ndarray</span>
<span class=sd>        Precomputed DPSS tapers with shape (samples, tapers).</span>
<span class=sd>    nfft : int</span>
<span class=sd>        Length of padded data for FFT.</span>
<span class=sd>    Fs : int</span>
<span class=sd>        Sampling frequency.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    J : np.ndarray</span>
<span class=sd>        FFT in the form (nfft, K), where K is the number of tapers.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Ensure data is 1D</span>
    <span class=k>if</span> <span class=n>data</span><span class=o>.</span><span class=n>ndim</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;Input data must be a 1D array.&quot;</span><span class=p>)</span>

    <span class=n>NC</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># Number of samples in data</span>
    <span class=n>NK</span><span class=p>,</span> <span class=n>K</span> <span class=o>=</span> <span class=n>tapers</span><span class=o>.</span><span class=n>shape</span>  <span class=c1># Number of samples and tapers</span>

    <span class=k>if</span> <span class=n>NK</span> <span class=o>!=</span> <span class=n>NC</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;Length of tapers is incompatible with length of data.&quot;</span><span class=p>)</span>

    <span class=c1># Project data onto tapers</span>
    <span class=n>data_proj</span> <span class=o>=</span> <span class=n>data</span><span class=p>[:,</span> <span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>]</span> <span class=o>*</span> <span class=n>tapers</span>  <span class=c1># Shape: (samples, tapers)</span>

    <span class=c1># Compute FFT for each taper</span>
    <span class=n>J</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>fft</span><span class=o>.</span><span class=n>fft</span><span class=p>(</span><span class=n>data_proj</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=n>nfft</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=o>/</span> <span class=n>Fs</span>  <span class=c1># Shape: (nfft, K)</span>

    <span class=k>return</span> <span class=n>J</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.mtfftpt class="doc doc-heading"> <code class="highlight language-python"><span class=n>mtfftpt</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>f</span><span class=p>,</span> <span class=n>findx</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Multitaper FFT for point process times.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of spike times (in seconds).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>tapers</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Tapers from the DPSS method.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>nfft</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of points for FFT.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>t</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Time vector.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>f</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Frequency vector.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>findx</code> </td> <td> <code>list of bool</code> </td> <td> <div class=doc-md-description> <p>Frequency index.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>J</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>FFT of the data.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>Msp</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Mean spikes per time.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>Nsp</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Total number of spikes in data.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>The function computes the multitaper FFT of spike times using the specified tapers and returns the FFT result, mean spikes, and total spike count.</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>145</span>
<span class=normal>146</span>
<span class=normal>147</span>
<span class=normal>148</span>
<span class=normal>149</span>
<span class=normal>150</span>
<span class=normal>151</span>
<span class=normal>152</span>
<span class=normal>153</span>
<span class=normal>154</span>
<span class=normal>155</span>
<span class=normal>156</span>
<span class=normal>157</span>
<span class=normal>158</span>
<span class=normal>159</span>
<span class=normal>160</span>
<span class=normal>161</span>
<span class=normal>162</span>
<span class=normal>163</span>
<span class=normal>164</span>
<span class=normal>165</span>
<span class=normal>166</span>
<span class=normal>167</span>
<span class=normal>168</span>
<span class=normal>169</span>
<span class=normal>170</span>
<span class=normal>171</span>
<span class=normal>172</span>
<span class=normal>173</span>
<span class=normal>174</span>
<span class=normal>175</span>
<span class=normal>176</span>
<span class=normal>177</span>
<span class=normal>178</span>
<span class=normal>179</span>
<span class=normal>180</span>
<span class=normal>181</span>
<span class=normal>182</span>
<span class=normal>183</span>
<span class=normal>184</span>
<span class=normal>185</span>
<span class=normal>186</span>
<span class=normal>187</span>
<span class=normal>188</span>
<span class=normal>189</span>
<span class=normal>190</span>
<span class=normal>191</span>
<span class=normal>192</span>
<span class=normal>193</span>
<span class=normal>194</span>
<span class=normal>195</span>
<span class=normal>196</span>
<span class=normal>197</span>
<span class=normal>198</span>
<span class=normal>199</span>
<span class=normal>200</span>
<span class=normal>201</span>
<span class=normal>202</span>
<span class=normal>203</span>
<span class=normal>204</span>
<span class=normal>205</span>
<span class=normal>206</span>
<span class=normal>207</span>
<span class=normal>208</span>
<span class=normal>209</span>
<span class=normal>210</span>
<span class=normal>211</span>
<span class=normal>212</span>
<span class=normal>213</span>
<span class=normal>214</span>
<span class=normal>215</span>
<span class=normal>216</span>
<span class=normal>217</span>
<span class=normal>218</span>
<span class=normal>219</span>
<span class=normal>220</span>
<span class=normal>221</span>
<span class=normal>222</span>
<span class=normal>223</span>
<span class=normal>224</span>
<span class=normal>225</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>mtfftpt</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>tapers</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>nfft</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
    <span class=n>t</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>f</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>findx</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>bool</span><span class=p>],</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Multitaper FFT for point process times.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray</span>
<span class=sd>        1D array of spike times (in seconds).</span>
<span class=sd>    tapers : np.ndarray</span>
<span class=sd>        Tapers from the DPSS method.</span>
<span class=sd>    nfft : int</span>
<span class=sd>        Number of points for FFT.</span>
<span class=sd>    t : np.ndarray</span>
<span class=sd>        Time vector.</span>
<span class=sd>    f : np.ndarray</span>
<span class=sd>        Frequency vector.</span>
<span class=sd>    findx : list of bool</span>
<span class=sd>        Frequency index.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    J : np.ndarray</span>
<span class=sd>        FFT of the data.</span>
<span class=sd>    Msp : float</span>
<span class=sd>        Mean spikes per time.</span>
<span class=sd>    Nsp : float</span>
<span class=sd>        Total number of spikes in data.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    The function computes the multitaper FFT of spike times using</span>
<span class=sd>    the specified tapers and returns the FFT result, mean spikes,</span>
<span class=sd>    and total spike count.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>K</span> <span class=o>=</span> <span class=n>tapers</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=n>nfreq</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>f</span><span class=p>)</span>

    <span class=c1># get the FFT of the tapers</span>
    <span class=n>H</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>nfft</span><span class=p>,</span> <span class=n>K</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>complex128</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>K</span><span class=p>):</span>
        <span class=n>H</span><span class=p>[:,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>fft</span><span class=o>.</span><span class=n>fft</span><span class=p>(</span><span class=n>tapers</span><span class=p>[:,</span> <span class=n>i</span><span class=p>],</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

    <span class=n>H</span> <span class=o>=</span> <span class=n>H</span><span class=p>[</span><span class=n>findx</span><span class=p>,</span> <span class=p>:]</span>
    <span class=n>w</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=n>f</span>
    <span class=n>dtmp</span> <span class=o>=</span> <span class=n>data</span>
    <span class=n>indx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>logical_and</span><span class=p>(</span><span class=n>dtmp</span> <span class=o>&gt;=</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>t</span><span class=p>),</span> <span class=n>dtmp</span> <span class=o>&lt;=</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>t</span><span class=p>))</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>indx</span><span class=p>):</span>
        <span class=n>dtmp</span> <span class=o>=</span> <span class=n>dtmp</span><span class=p>[</span><span class=n>indx</span><span class=p>]</span>
    <span class=n>Nsp</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>dtmp</span><span class=p>)</span>

    <span class=c1># get the mean spike rate</span>
    <span class=n>Msp</span> <span class=o>=</span> <span class=n>Nsp</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>Msp</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
        <span class=c1># Interpolate spike times for each taper</span>
        <span class=n>data_proj</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>empty</span><span class=p>((</span><span class=nb>len</span><span class=p>(</span><span class=n>dtmp</span><span class=p>),</span> <span class=n>K</span><span class=p>))</span>
        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>K</span><span class=p>):</span>
            <span class=n>data_proj</span><span class=p>[:,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span><span class=n>dtmp</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>tapers</span><span class=p>[:,</span> <span class=n>i</span><span class=p>])</span>

        <span class=k>def</span><span class=w> </span><span class=nf>compute_J</span><span class=p>(</span><span class=n>k</span><span class=p>):</span>
            <span class=n>J_k</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=n>nfreq</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>complex128</span><span class=p>)</span>
            <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>freq</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>w</span><span class=p>):</span>
                <span class=n>phase</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=n>j</span> <span class=o>*</span> <span class=n>freq</span> <span class=o>*</span> <span class=p>(</span><span class=n>dtmp</span> <span class=o>-</span> <span class=n>t</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
                <span class=n>J_k</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>exp</span><span class=p>(</span><span class=n>phase</span><span class=p>)</span> <span class=o>*</span> <span class=n>data_proj</span><span class=p>[:,</span> <span class=n>k</span><span class=p>])</span>
            <span class=k>return</span> <span class=n>J_k</span>

        <span class=n>J</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>Parallel</span><span class=p>(</span><span class=n>n_jobs</span><span class=o>=-</span><span class=mi>1</span><span class=p>)(</span><span class=n>delayed</span><span class=p>(</span><span class=n>compute_J</span><span class=p>)(</span><span class=n>k</span><span class=p>)</span> <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>K</span><span class=p>)))</span><span class=o>.</span><span class=n>T</span>

        <span class=n>J</span> <span class=o>-=</span> <span class=n>H</span> <span class=o>*</span> <span class=n>Msp</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=c1># No spikes: return zeros</span>
        <span class=n>J</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>nfreq</span><span class=p>,</span> <span class=n>K</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>complex128</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>J</span><span class=p>,</span> <span class=n>Msp</span><span class=p>,</span> <span class=n>Nsp</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.mtspectrumc class="doc doc-heading"> <code class="highlight language-python"><span class=n>mtspectrumc</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>Fs</span><span class=p>,</span> <span class=n>fpass</span><span class=p>,</span> <span class=n>tapers</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the multitaper power spectrum for continuous data.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of continuous data (e.g., LFP).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>Fs</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency in Hz.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fpass</code> </td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>Frequency range to evaluate as [min_freq, max_freq].</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>tapers</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Tapers array with shape [NW, K] or [tapers, eigenvalues].</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>S</code></td> <td> <code><span title=pandas.Series>Series</span></code> </td> <td> <div class=doc-md-description> <p>Power spectrum with frequencies as the index.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>This function utilizes the multitaper method for spectral estimation and returns the power spectrum as a pandas Series.</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>368</span>
<span class=normal>369</span>
<span class=normal>370</span>
<span class=normal>371</span>
<span class=normal>372</span>
<span class=normal>373</span>
<span class=normal>374</span>
<span class=normal>375</span>
<span class=normal>376</span>
<span class=normal>377</span>
<span class=normal>378</span>
<span class=normal>379</span>
<span class=normal>380</span>
<span class=normal>381</span>
<span class=normal>382</span>
<span class=normal>383</span>
<span class=normal>384</span>
<span class=normal>385</span>
<span class=normal>386</span>
<span class=normal>387</span>
<span class=normal>388</span>
<span class=normal>389</span>
<span class=normal>390</span>
<span class=normal>391</span>
<span class=normal>392</span>
<span class=normal>393</span>
<span class=normal>394</span>
<span class=normal>395</span>
<span class=normal>396</span>
<span class=normal>397</span>
<span class=normal>398</span>
<span class=normal>399</span>
<span class=normal>400</span>
<span class=normal>401</span>
<span class=normal>402</span>
<span class=normal>403</span>
<span class=normal>404</span>
<span class=normal>405</span>
<span class=normal>406</span>
<span class=normal>407</span>
<span class=normal>408</span>
<span class=normal>409</span>
<span class=normal>410</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>mtspectrumc</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>Fs</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>fpass</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span> <span class=n>tapers</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>Series</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the multitaper power spectrum for continuous data.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray</span>
<span class=sd>        1D array of continuous data (e.g., LFP).</span>
<span class=sd>    Fs : int</span>
<span class=sd>        Sampling frequency in Hz.</span>
<span class=sd>    fpass : list</span>
<span class=sd>        Frequency range to evaluate as [min_freq, max_freq].</span>
<span class=sd>    tapers : np.ndarray</span>
<span class=sd>        Tapers array with shape [NW, K] or [tapers, eigenvalues].</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    S : pd.Series</span>
<span class=sd>        Power spectrum with frequencies as the index.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    This function utilizes the multitaper method for spectral estimation</span>
<span class=sd>    and returns the power spectrum as a pandas Series.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>N</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
    <span class=n>nfft</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span>
        <span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=mi>2</span> <span class=o>**</span> <span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>log2</span><span class=p>(</span><span class=n>N</span><span class=p>))),</span> <span class=n>N</span><span class=p>]</span>
    <span class=p>)</span>  <span class=c1># number of points in fft of prolates</span>
    <span class=c1># get the frequency grid</span>
    <span class=n>f</span><span class=p>,</span> <span class=n>findx</span> <span class=o>=</span> <span class=n>getfgrid</span><span class=p>(</span><span class=n>Fs</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>fpass</span><span class=p>)</span>
    <span class=c1># get the fft of the tapers</span>
    <span class=n>tapers</span> <span class=o>=</span> <span class=n>dpsschk</span><span class=p>(</span><span class=n>tapers</span><span class=p>,</span> <span class=n>N</span><span class=p>,</span> <span class=n>Fs</span><span class=p>)</span>
    <span class=c1># get the fft of the data</span>
    <span class=n>J</span> <span class=o>=</span> <span class=n>mtfftc</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>Fs</span><span class=p>)</span>
    <span class=c1># restrict fft of tapers to required frequencies</span>
    <span class=n>J</span> <span class=o>=</span> <span class=n>J</span><span class=p>[</span><span class=n>findx</span><span class=p>,</span> <span class=p>:]</span>
    <span class=c1># get the power spectrum</span>
    <span class=n>S</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>real</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>conj</span><span class=p>(</span><span class=n>J</span><span class=p>)</span> <span class=o>*</span> <span class=n>J</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
    <span class=c1># return the power spectrum</span>
    <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>Series</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=n>S</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.mtspectrumpt class="doc doc-heading"> <code class="highlight language-python"><span class=n>mtspectrumpt</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>Fs</span><span class=p>,</span> <span class=n>fpass</span><span class=p>,</span> <span class=n>NW</span><span class=o>=</span><span class=mf>2.5</span><span class=p>,</span> <span class=n>n_tapers</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>time_support</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>tapers</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>nfft</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Multitaper power spectrum estimation for point process data.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of spike times (in seconds).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>Fs</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fpass</code> </td> <td> <code>list of float</code> </td> <td> <div class=doc-md-description> <p>Frequency range to evaluate.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>NW</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=int>int</span>, <span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>Time-bandwidth product (default is 2.5).</p> </div> </td> <td> <code>2.5</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_tapers</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of tapers (default is 4).</p> </div> </td> <td> <code>4</code> </td> </tr> <tr class=doc-section-item> <td> <code>time_support</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=list>list</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Time range to evaluate (default is None).</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>tapers</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Precomputed tapers, given as [NW, K] or [tapers, eigenvalues] (default is None).</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>tapers_ts</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Taper time series (default is None).</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>nfft</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=int>int</span>]</code> </td> <td> <div class=doc-md-description> <p>Number of points for FFT (default is None).</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>DataFrame containing the power spectrum.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>spec</span> <span class=o>=</span> <span class=n>pychronux</span><span class=o>.</span><span class=n>mtspectrumpt</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>   <span class=n>st</span><span class=o>.</span><span class=n>data</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span>   <span class=mi>100</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span>   <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>20</span><span class=p>],</span>
<span class=gp>&gt;&gt;&gt; </span>   <span class=n>NW</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span>   <span class=n>n_tapers</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span>   <span class=n>time_support</span><span class=o>=</span><span class=p>[</span><span class=n>st</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>start</span><span class=p>,</span> <span class=n>st</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>stop</span><span class=p>],</span>
<span class=gp>&gt;&gt;&gt; </span>   <span class=n>nfft</span><span class=o>=</span><span class=mi>500</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>228</span>
<span class=normal>229</span>
<span class=normal>230</span>
<span class=normal>231</span>
<span class=normal>232</span>
<span class=normal>233</span>
<span class=normal>234</span>
<span class=normal>235</span>
<span class=normal>236</span>
<span class=normal>237</span>
<span class=normal>238</span>
<span class=normal>239</span>
<span class=normal>240</span>
<span class=normal>241</span>
<span class=normal>242</span>
<span class=normal>243</span>
<span class=normal>244</span>
<span class=normal>245</span>
<span class=normal>246</span>
<span class=normal>247</span>
<span class=normal>248</span>
<span class=normal>249</span>
<span class=normal>250</span>
<span class=normal>251</span>
<span class=normal>252</span>
<span class=normal>253</span>
<span class=normal>254</span>
<span class=normal>255</span>
<span class=normal>256</span>
<span class=normal>257</span>
<span class=normal>258</span>
<span class=normal>259</span>
<span class=normal>260</span>
<span class=normal>261</span>
<span class=normal>262</span>
<span class=normal>263</span>
<span class=normal>264</span>
<span class=normal>265</span>
<span class=normal>266</span>
<span class=normal>267</span>
<span class=normal>268</span>
<span class=normal>269</span>
<span class=normal>270</span>
<span class=normal>271</span>
<span class=normal>272</span>
<span class=normal>273</span>
<span class=normal>274</span>
<span class=normal>275</span>
<span class=normal>276</span>
<span class=normal>277</span>
<span class=normal>278</span>
<span class=normal>279</span>
<span class=normal>280</span>
<span class=normal>281</span>
<span class=normal>282</span>
<span class=normal>283</span>
<span class=normal>284</span>
<span class=normal>285</span>
<span class=normal>286</span>
<span class=normal>287</span>
<span class=normal>288</span>
<span class=normal>289</span>
<span class=normal>290</span>
<span class=normal>291</span>
<span class=normal>292</span>
<span class=normal>293</span>
<span class=normal>294</span>
<span class=normal>295</span>
<span class=normal>296</span>
<span class=normal>297</span>
<span class=normal>298</span>
<span class=normal>299</span>
<span class=normal>300</span>
<span class=normal>301</span>
<span class=normal>302</span>
<span class=normal>303</span>
<span class=normal>304</span>
<span class=normal>305</span>
<span class=normal>306</span>
<span class=normal>307</span>
<span class=normal>308</span>
<span class=normal>309</span>
<span class=normal>310</span>
<span class=normal>311</span>
<span class=normal>312</span>
<span class=normal>313</span>
<span class=normal>314</span>
<span class=normal>315</span>
<span class=normal>316</span>
<span class=normal>317</span>
<span class=normal>318</span>
<span class=normal>319</span>
<span class=normal>320</span>
<span class=normal>321</span>
<span class=normal>322</span>
<span class=normal>323</span>
<span class=normal>324</span>
<span class=normal>325</span>
<span class=normal>326</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>mtspectrumpt</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>Fs</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
    <span class=n>fpass</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span>
    <span class=n>NW</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>,</span>
    <span class=n>n_tapers</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span>
    <span class=n>time_support</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>list</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>tapers</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>tapers_ts</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>nfft</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Multitaper power spectrum estimation for point process data.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray</span>
<span class=sd>        Array of spike times (in seconds).</span>
<span class=sd>    Fs : int</span>
<span class=sd>        Sampling frequency.</span>
<span class=sd>    fpass : list of float</span>
<span class=sd>        Frequency range to evaluate.</span>
<span class=sd>    NW : Union[int, float], optional</span>
<span class=sd>        Time-bandwidth product (default is 2.5).</span>
<span class=sd>    n_tapers : int, optional</span>
<span class=sd>        Number of tapers (default is 4).</span>
<span class=sd>    time_support : Union[list, None], optional</span>
<span class=sd>        Time range to evaluate (default is None).</span>
<span class=sd>    tapers : Union[np.ndarray, None], optional</span>
<span class=sd>        Precomputed tapers, given as [NW, K] or [tapers, eigenvalues] (default is None).</span>
<span class=sd>    tapers_ts : Union[np.ndarray, None], optional</span>
<span class=sd>        Taper time series (default is None).</span>
<span class=sd>    nfft : Optional[int], optional</span>
<span class=sd>        Number of points for FFT (default is None).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    pd.DataFrame</span>
<span class=sd>        DataFrame containing the power spectrum.</span>


<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; spec = pychronux.mtspectrumpt(</span>
<span class=sd>    &gt;&gt;&gt;    st.data,</span>
<span class=sd>    &gt;&gt;&gt;    100,</span>
<span class=sd>    &gt;&gt;&gt;    [1, 20],</span>
<span class=sd>    &gt;&gt;&gt;    NW=3,</span>
<span class=sd>    &gt;&gt;&gt;    n_tapers=5,</span>
<span class=sd>    &gt;&gt;&gt;    time_support=[st.support.start, st.support.stop],</span>
<span class=sd>    &gt;&gt;&gt;    nfft=500,</span>
<span class=sd>    &gt;&gt;&gt; )</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># check data</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>()</span>

    <span class=c1># check frequency range</span>
    <span class=k>if</span> <span class=n>fpass</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>fpass</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;Invalid frequency range: fpass[0] should be less than fpass[1].&quot;</span>
        <span class=p>)</span>

    <span class=k>if</span> <span class=n>time_support</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>mintime</span><span class=p>,</span> <span class=n>maxtime</span> <span class=o>=</span> <span class=n>time_support</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>data</span><span class=o>.</span><span class=n>dtype</span> <span class=o>==</span> <span class=n>np</span><span class=o>.</span><span class=n>object_</span><span class=p>:</span>
            <span class=n>mintime</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>concatenate</span><span class=p>(</span><span class=n>data</span><span class=p>))</span>
            <span class=n>maxtime</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>concatenate</span><span class=p>(</span><span class=n>data</span><span class=p>))</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>mintime</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
            <span class=n>maxtime</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>

    <span class=n>dt</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>Fs</span>

    <span class=k>if</span> <span class=n>tapers</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>tapers_ts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>mintime</span> <span class=o>-</span> <span class=n>dt</span><span class=p>,</span> <span class=n>maxtime</span> <span class=o>+</span> <span class=n>dt</span><span class=p>,</span> <span class=n>dt</span><span class=p>)</span>
        <span class=n>N</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>tapers_ts</span><span class=p>)</span>
        <span class=n>tapers</span><span class=p>,</span> <span class=n>eigens</span> <span class=o>=</span> <span class=n>dpss</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>NW</span><span class=p>,</span> <span class=n>n_tapers</span><span class=p>,</span> <span class=n>return_ratios</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
        <span class=n>tapers</span> <span class=o>=</span> <span class=n>tapers</span><span class=o>.</span><span class=n>T</span>

    <span class=k>if</span> <span class=n>tapers_ts</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>tapers_ts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>mintime</span> <span class=o>-</span> <span class=n>dt</span><span class=p>,</span> <span class=n>maxtime</span> <span class=o>+</span> <span class=n>dt</span><span class=p>,</span> <span class=n>dt</span><span class=p>)</span>

    <span class=n>N</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>tapers_ts</span><span class=p>)</span>
    <span class=c1># number of points in fft of prolates</span>
    <span class=k>if</span> <span class=n>nfft</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>nfft</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>([</span><span class=nb>int</span><span class=p>(</span><span class=mi>2</span> <span class=o>**</span> <span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>log2</span><span class=p>(</span><span class=n>N</span><span class=p>))),</span> <span class=n>N</span><span class=p>])</span>
    <span class=n>f</span><span class=p>,</span> <span class=n>findx</span> <span class=o>=</span> <span class=n>getfgrid</span><span class=p>(</span><span class=n>Fs</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>fpass</span><span class=p>)</span>

    <span class=n>spec</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=nb>len</span><span class=p>(</span><span class=n>f</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)))</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>d</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
        <span class=n>J</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>mtfftpt</span><span class=p>(</span><span class=n>d</span><span class=p>,</span> <span class=n>tapers</span><span class=p>,</span> <span class=n>nfft</span><span class=p>,</span> <span class=n>tapers_ts</span><span class=p>,</span> <span class=n>f</span><span class=p>,</span> <span class=n>findx</span><span class=p>)</span>
        <span class=n>spec</span><span class=p>[:,</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>real</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>conj</span><span class=p>(</span><span class=n>J</span><span class=p>)</span> <span class=o>*</span> <span class=n>J</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>

    <span class=n>spectrum_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>index</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)),</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span>
    <span class=n>spectrum_df</span><span class=p>[:]</span> <span class=o>=</span> <span class=n>spec</span>
    <span class=k>return</span> <span class=n>spectrum_df</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.nearest_event_delay class="doc doc-heading"> <code class="highlight language-python"><span class=n>nearest_event_delay</span><span class=p>(</span><span class=n>ts_1</span><span class=p>,</span> <span class=n>ts_2</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Return for each timestamp in ts_1 the nearest timestamp in ts_2 and the delay between the two.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>ts_1</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of timestamps.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>ts_2</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of timestamps (must be monotonically increasing).</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>nearest_ts</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Nearest timestamps in ts_2 for each timestamp in ts_1.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>delays</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Delays between ts_1 and nearest_ts.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>nearest_index</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Index of nearest_ts in ts_2.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Raises:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=ValueError>ValueError</span></code> </td> <td> <div class=doc-md-description> <p>If ts_1 or ts_2 are empty or not monotonically increasing.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>Both ts_1 and ts_2 must be monotonically increasing arrays of timestamps.</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1125</span>
<span class=normal>1126</span>
<span class=normal>1127</span>
<span class=normal>1128</span>
<span class=normal>1129</span>
<span class=normal>1130</span>
<span class=normal>1131</span>
<span class=normal>1132</span>
<span class=normal>1133</span>
<span class=normal>1134</span>
<span class=normal>1135</span>
<span class=normal>1136</span>
<span class=normal>1137</span>
<span class=normal>1138</span>
<span class=normal>1139</span>
<span class=normal>1140</span>
<span class=normal>1141</span>
<span class=normal>1142</span>
<span class=normal>1143</span>
<span class=normal>1144</span>
<span class=normal>1145</span>
<span class=normal>1146</span>
<span class=normal>1147</span>
<span class=normal>1148</span>
<span class=normal>1149</span>
<span class=normal>1150</span>
<span class=normal>1151</span>
<span class=normal>1152</span>
<span class=normal>1153</span>
<span class=normal>1154</span>
<span class=normal>1155</span>
<span class=normal>1156</span>
<span class=normal>1157</span>
<span class=normal>1158</span>
<span class=normal>1159</span>
<span class=normal>1160</span>
<span class=normal>1161</span>
<span class=normal>1162</span>
<span class=normal>1163</span>
<span class=normal>1164</span>
<span class=normal>1165</span>
<span class=normal>1166</span>
<span class=normal>1167</span>
<span class=normal>1168</span>
<span class=normal>1169</span>
<span class=normal>1170</span>
<span class=normal>1171</span>
<span class=normal>1172</span>
<span class=normal>1173</span>
<span class=normal>1174</span>
<span class=normal>1175</span>
<span class=normal>1176</span>
<span class=normal>1177</span>
<span class=normal>1178</span>
<span class=normal>1179</span>
<span class=normal>1180</span>
<span class=normal>1181</span>
<span class=normal>1182</span>
<span class=normal>1183</span>
<span class=normal>1184</span>
<span class=normal>1185</span>
<span class=normal>1186</span>
<span class=normal>1187</span>
<span class=normal>1188</span>
<span class=normal>1189</span>
<span class=normal>1190</span>
<span class=normal>1191</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>nearest_event_delay</span><span class=p>(</span>
    <span class=n>ts_1</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>ts_2</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Return for each timestamp in ts_1 the nearest timestamp in ts_2 and the delay between the two.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    ts_1 : np.ndarray</span>
<span class=sd>        1D array of timestamps.</span>
<span class=sd>    ts_2 : np.ndarray</span>
<span class=sd>        1D array of timestamps (must be monotonically increasing).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    nearest_ts : np.ndarray</span>
<span class=sd>        Nearest timestamps in ts_2 for each timestamp in ts_1.</span>
<span class=sd>    delays : np.ndarray</span>
<span class=sd>        Delays between ts_1 and nearest_ts.</span>
<span class=sd>    nearest_index : np.ndarray</span>
<span class=sd>        Index of nearest_ts in ts_2.</span>

<span class=sd>    Raises</span>
<span class=sd>    ------</span>
<span class=sd>    ValueError</span>
<span class=sd>        If ts_1 or ts_2 are empty or not monotonically increasing.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Both ts_1 and ts_2 must be monotonically increasing arrays of timestamps.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>ts_1</span><span class=p>,</span> <span class=n>ts_2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>ts_1</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>ts_2</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>all</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>ts_2</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ts_2 must be monotonically increasing&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>all</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>ts_1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ts_1 must be monotonically increasing&quot;</span><span class=p>)</span>
    <span class=c1># check if empty</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>ts_1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ts_1 is empty&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>ts_2</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ts_2 is empty&quot;</span><span class=p>)</span>

    <span class=c1># Use searchsorted to find the indices where elements of ts_1 should be inserted</span>
    <span class=n>nearest_indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>ts_2</span><span class=p>,</span> <span class=n>ts_1</span><span class=p>,</span> <span class=n>side</span><span class=o>=</span><span class=s2>&quot;left&quot;</span><span class=p>)</span>

    <span class=c1># Calculate indices for the elements before and after the insertion points</span>
    <span class=n>before</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>maximum</span><span class=p>(</span><span class=n>nearest_indices</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
    <span class=n>after</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>minimum</span><span class=p>(</span><span class=n>nearest_indices</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>ts_2</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

    <span class=c1># Determine the nearest timestamp for each element in ts_1</span>
    <span class=n>nearest_ts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>ts_1</span> <span class=o>-</span> <span class=n>ts_2</span><span class=p>[</span><span class=n>before</span><span class=p>])</span> <span class=o>&lt;</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>ts_1</span> <span class=o>-</span> <span class=n>ts_2</span><span class=p>[</span><span class=n>after</span><span class=p>]),</span>
        <span class=n>ts_2</span><span class=p>[</span><span class=n>before</span><span class=p>],</span>
        <span class=n>ts_2</span><span class=p>[</span><span class=n>after</span><span class=p>],</span>
    <span class=p>)</span>

    <span class=c1># Calculate delays between ts_1 and nearest_ts</span>
    <span class=n>delays</span> <span class=o>=</span> <span class=n>ts_1</span> <span class=o>-</span> <span class=n>nearest_ts</span>

    <span class=c1># Find the nearest_index using the absolute difference</span>
    <span class=n>absolute_diff_before</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>ts_1</span> <span class=o>-</span> <span class=n>ts_2</span><span class=p>[</span><span class=n>before</span><span class=p>])</span>
    <span class=n>absolute_diff_after</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>ts_1</span> <span class=o>-</span> <span class=n>ts_2</span><span class=p>[</span><span class=n>after</span><span class=p>])</span>
    <span class=n>nearest_index</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span><span class=n>absolute_diff_before</span> <span class=o>&lt;</span> <span class=n>absolute_diff_after</span><span class=p>,</span> <span class=n>before</span><span class=p>,</span> <span class=n>after</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>nearest_ts</span><span class=p>,</span> <span class=n>delays</span><span class=p>,</span> <span class=n>nearest_index</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.nonspatial_phase_precession class="doc doc-heading"> <code class="highlight language-python"><span class=n>nonspatial_phase_precession</span><span class=p>(</span><span class=n>unwrapped_spike_phases</span><span class=p>,</span> <span class=n>width</span><span class=o>=</span><span class=mi>4</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>/</span> <span class=mi>3</span><span class=p>,</span> <span class=n>cut_peak</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>norm</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>psd_lims</span><span class=o>=</span><span class=p>[</span><span class=mf>0.65</span><span class=p>,</span> <span class=mf>1.55</span><span class=p>],</span> <span class=n>upsample</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>smooth_sigma</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute the nonspatial spike-LFP relationship modulation index.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>unwrapped_spike_phases</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>1D array of spike phases that have been linearly unwrapped.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Time window for ACF in cycles (default = 4 cycles).</p> </div> </td> <td> <code>4 * 2 * <span title=numpy.pi>pi</span></code> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Width of bins in radians (default = pi/3 radians).</p> </div> </td> <td> <code><span title=numpy.pi>pi</span> / 3</code> </td> </tr> <tr class=doc-section-item> <td> <code>cut_peak</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether or not the largest central peak should be replaced for subsequent fitting.</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>norm</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>To normalize the ACF or not.</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>psd_lims</code> </td> <td> <code><span title=typing.List>List</span>[<span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>Limits of the PSD to consider for peak finding (default = [0.65, 1.55]).</p> </div> </td> <td> <code>[0.65, 1.55]</code> </td> </tr> <tr class=doc-section-item> <td> <code>upsample</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Upsampling factor (default = 4).</p> </div> </td> <td> <code>4</code> </td> </tr> <tr class=doc-section-item> <td> <code>smooth_sigma</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Standard deviation for Gaussian smoothing of the PSD (default = 1).</p> </div> </td> <td> <code>1</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>max_freq</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Relative spike-LFP frequency of the PSD peak.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>MI</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Modulation index of non-spatial phase relationship.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>psd</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Power spectral density of interest.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>frequencies</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Frequencies corresponding to the PSD.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>acf</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Autocorrelation function.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>The modulation index (MI) is computed based on the maximum peak of the power spectral density (PSD) within specified frequency limits.</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/precession_utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>423</span>
<span class=normal>424</span>
<span class=normal>425</span>
<span class=normal>426</span>
<span class=normal>427</span>
<span class=normal>428</span>
<span class=normal>429</span>
<span class=normal>430</span>
<span class=normal>431</span>
<span class=normal>432</span>
<span class=normal>433</span>
<span class=normal>434</span>
<span class=normal>435</span>
<span class=normal>436</span>
<span class=normal>437</span>
<span class=normal>438</span>
<span class=normal>439</span>
<span class=normal>440</span>
<span class=normal>441</span>
<span class=normal>442</span>
<span class=normal>443</span>
<span class=normal>444</span>
<span class=normal>445</span>
<span class=normal>446</span>
<span class=normal>447</span>
<span class=normal>448</span>
<span class=normal>449</span>
<span class=normal>450</span>
<span class=normal>451</span>
<span class=normal>452</span>
<span class=normal>453</span>
<span class=normal>454</span>
<span class=normal>455</span>
<span class=normal>456</span>
<span class=normal>457</span>
<span class=normal>458</span>
<span class=normal>459</span>
<span class=normal>460</span>
<span class=normal>461</span>
<span class=normal>462</span>
<span class=normal>463</span>
<span class=normal>464</span>
<span class=normal>465</span>
<span class=normal>466</span>
<span class=normal>467</span>
<span class=normal>468</span>
<span class=normal>469</span>
<span class=normal>470</span>
<span class=normal>471</span>
<span class=normal>472</span>
<span class=normal>473</span>
<span class=normal>474</span>
<span class=normal>475</span>
<span class=normal>476</span>
<span class=normal>477</span>
<span class=normal>478</span>
<span class=normal>479</span>
<span class=normal>480</span>
<span class=normal>481</span>
<span class=normal>482</span>
<span class=normal>483</span>
<span class=normal>484</span>
<span class=normal>485</span>
<span class=normal>486</span>
<span class=normal>487</span>
<span class=normal>488</span>
<span class=normal>489</span>
<span class=normal>490</span>
<span class=normal>491</span>
<span class=normal>492</span>
<span class=normal>493</span>
<span class=normal>494</span>
<span class=normal>495</span>
<span class=normal>496</span>
<span class=normal>497</span>
<span class=normal>498</span>
<span class=normal>499</span>
<span class=normal>500</span>
<span class=normal>501</span>
<span class=normal>502</span>
<span class=normal>503</span>
<span class=normal>504</span>
<span class=normal>505</span>
<span class=normal>506</span>
<span class=normal>507</span>
<span class=normal>508</span>
<span class=normal>509</span>
<span class=normal>510</span>
<span class=normal>511</span>
<span class=normal>512</span>
<span class=normal>513</span>
<span class=normal>514</span>
<span class=normal>515</span>
<span class=normal>516</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>nonspatial_phase_precession</span><span class=p>(</span>
    <span class=n>unwrapped_spike_phases</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>/</span> <span class=mi>3</span><span class=p>,</span>
    <span class=n>cut_peak</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
    <span class=n>norm</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
    <span class=n>psd_lims</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.65</span><span class=p>,</span> <span class=mf>1.55</span><span class=p>],</span>
    <span class=n>upsample</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span>
    <span class=n>smooth_sigma</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the nonspatial spike-LFP relationship modulation index.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    unwrapped_spike_phases : np.ndarray</span>
<span class=sd>        1D array of spike phases that have been linearly unwrapped.</span>
<span class=sd>    width : float</span>
<span class=sd>        Time window for ACF in cycles (default = 4 cycles).</span>
<span class=sd>    bin_width : float</span>
<span class=sd>        Width of bins in radians (default = pi/3 radians).</span>
<span class=sd>    cut_peak : bool</span>
<span class=sd>        Whether or not the largest central peak should be replaced for subsequent fitting.</span>
<span class=sd>    norm : bool</span>
<span class=sd>        To normalize the ACF or not.</span>
<span class=sd>    psd_lims : List[float]</span>
<span class=sd>        Limits of the PSD to consider for peak finding (default = [0.65, 1.55]).</span>
<span class=sd>    upsample : int</span>
<span class=sd>        Upsampling factor (default = 4).</span>
<span class=sd>    smooth_sigma : float</span>
<span class=sd>        Standard deviation for Gaussian smoothing of the PSD (default = 1).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    max_freq : float</span>
<span class=sd>        Relative spike-LFP frequency of the PSD peak.</span>
<span class=sd>    MI : float</span>
<span class=sd>        Modulation index of non-spatial phase relationship.</span>
<span class=sd>    psd : np.ndarray</span>
<span class=sd>        Power spectral density of interest.</span>
<span class=sd>    frequencies : np.ndarray</span>
<span class=sd>        Frequencies corresponding to the PSD.</span>
<span class=sd>    acf : np.ndarray</span>
<span class=sd>        Autocorrelation function.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    The modulation index (MI) is computed based on the maximum peak of the power</span>
<span class=sd>    spectral density (PSD) within specified frequency limits.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>frequencies</span> <span class=o>=</span> <span class=p>(</span>
        <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=p>(</span><span class=n>width</span> <span class=o>//</span> <span class=n>bin_width</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
        <span class=o>*</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>)</span>
        <span class=o>/</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>width</span> <span class=o>-</span> <span class=n>bin_width</span><span class=p>)</span>
    <span class=p>)</span>

    <span class=n>frequencies</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>frequencies</span><span class=p>),</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>upsample</span><span class=p>),</span>
        <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>frequencies</span><span class=p>)),</span>
        <span class=n>frequencies</span><span class=p>,</span>
    <span class=p>)</span>

    <span class=n>freqs_of_interest</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>intersect1d</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span><span class=n>frequencies</span> <span class=o>&gt;</span> <span class=n>psd_lims</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span> <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span><span class=n>frequencies</span> <span class=o>&lt;</span> <span class=n>psd_lims</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=p>)</span>

    <span class=n>acf</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>fast_acf</span><span class=p>(</span><span class=n>unwrapped_spike_phases</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>cut_peak</span><span class=o>=</span><span class=n>cut_peak</span><span class=p>)</span>
    <span class=n>psd</span> <span class=o>=</span> <span class=n>acf_power</span><span class=p>(</span><span class=n>acf</span><span class=p>,</span> <span class=n>norm</span><span class=o>=</span><span class=n>norm</span><span class=p>)</span>

    <span class=c1># upsample 2x psd</span>
    <span class=n>psd</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>psd</span><span class=p>),</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>upsample</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>psd</span><span class=p>)),</span> <span class=n>psd</span><span class=p>)</span>
    <span class=c1># smooth psd with gaussian filter</span>
    <span class=n>psd</span> <span class=o>=</span> <span class=n>gaussian_filter1d</span><span class=p>(</span><span class=n>psd</span><span class=p>,</span> <span class=n>smooth_sigma</span><span class=p>)</span>

    <span class=c1># FIND ALL LOCAL MAXIMA IN WINDOW OF INTEREST</span>
    <span class=n>all_peaks</span> <span class=o>=</span> <span class=n>find_peaks</span><span class=p>(</span><span class=n>psd</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>],</span> <span class=kc>None</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>

    <span class=c1># make sure there is a peak</span>
    <span class=k>if</span> <span class=o>~</span><span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>all_peaks</span><span class=p>):</span>
        <span class=k>return</span> <span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span>
            <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span>
            <span class=n>psd</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>],</span>
            <span class=n>frequencies</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>],</span>
            <span class=n>acf</span><span class=p>,</span>
        <span class=p>)</span>

    <span class=n>max_peak</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>psd</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>][</span><span class=n>all_peaks</span><span class=p>])</span>
    <span class=n>max_idx</span> <span class=o>=</span> <span class=p>[</span><span class=n>all_peaks</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>psd</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>][</span><span class=n>all_peaks</span><span class=p>])]]</span>
    <span class=n>max_freq</span> <span class=o>=</span> <span class=n>frequencies</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>][</span><span class=n>max_idx</span><span class=p>]</span>
    <span class=n>MI</span> <span class=o>=</span> <span class=n>max_peak</span> <span class=o>/</span> <span class=n>np</span><span class=o>.</span><span class=n>trapezoid</span><span class=p>(</span><span class=n>psd</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>])</span>

    <span class=k>return</span> <span class=n>max_freq</span><span class=p>,</span> <span class=n>MI</span><span class=p>,</span> <span class=n>psd</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>],</span> <span class=n>frequencies</span><span class=p>[</span><span class=n>freqs_of_interest</span><span class=p>],</span> <span class=n>acf</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.overlap_intersect class="doc doc-heading"> <code class="highlight language-python"><span class=n>overlap_intersect</span><span class=p>(</span><span class=n>epoch</span><span class=p>,</span> <span class=n>interval</span><span class=p>,</span> <span class=n>return_indices</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Returns the epochs with overlap with the given interval.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>epoch</code> </td> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>The epochs to check.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>interval</code> </td> <td> <code><span title=nelpy.IntervalArray>IntervalArray</span></code> </td> <td> <div class=doc-md-description> <p>The interval to check for overlap.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>return_indices</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, returns the indices of the overlapping epochs. Default is True.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>The epochs with overlap with the interval.</p> </div> </td> </tr> <tr class=doc-section-item> <td> <code>(<span title=typing.Tuple>Tuple</span>[<span title=nelpy.EpochArray>EpochArray</span>, <span title=numpy.ndarray>ndarray</span>], <span title=optional>optional</span>)</code> </td> <td> <div class=doc-md-description> <p>If <code>return_indices</code> is True, also returns the indices of the overlapping epochs.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>150</span>
<span class=normal>151</span>
<span class=normal>152</span>
<span class=normal>153</span>
<span class=normal>154</span>
<span class=normal>155</span>
<span class=normal>156</span>
<span class=normal>157</span>
<span class=normal>158</span>
<span class=normal>159</span>
<span class=normal>160</span>
<span class=normal>161</span>
<span class=normal>162</span>
<span class=normal>163</span>
<span class=normal>164</span>
<span class=normal>165</span>
<span class=normal>166</span>
<span class=normal>167</span>
<span class=normal>168</span>
<span class=normal>169</span>
<span class=normal>170</span>
<span class=normal>171</span>
<span class=normal>172</span>
<span class=normal>173</span>
<span class=normal>174</span>
<span class=normal>175</span>
<span class=normal>176</span>
<span class=normal>177</span>
<span class=normal>178</span>
<span class=normal>179</span>
<span class=normal>180</span>
<span class=normal>181</span>
<span class=normal>182</span>
<span class=normal>183</span>
<span class=normal>184</span>
<span class=normal>185</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>overlap_intersect</span><span class=p>(</span>
    <span class=n>epoch</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span> <span class=n>interval</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>IntervalArray</span><span class=p>,</span> <span class=n>return_indices</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Union</span><span class=p>[</span><span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Returns the epochs with overlap with the given interval.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    epoch : nelpy.EpochArray</span>
<span class=sd>        The epochs to check.</span>
<span class=sd>    interval : nelpy.IntervalArray</span>
<span class=sd>        The interval to check for overlap.</span>
<span class=sd>    return_indices : bool, optional</span>
<span class=sd>        If True, returns the indices of the overlapping epochs. Default is True.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    nelpy.EpochArray</span>
<span class=sd>        The epochs with overlap with the interval.</span>
<span class=sd>    Tuple[nelpy.EpochArray, np.ndarray], optional</span>
<span class=sd>        If `return_indices` is True, also returns the indices of the overlapping epochs.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>new_intervals</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>indices</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>for</span> <span class=n>epa</span> <span class=ow>in</span> <span class=n>epoch</span><span class=p>:</span>
        <span class=k>if</span> <span class=nb>any</span><span class=p>((</span><span class=n>interval</span><span class=o>.</span><span class=n>starts</span> <span class=o>&lt;</span> <span class=n>epa</span><span class=o>.</span><span class=n>stop</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>interval</span><span class=o>.</span><span class=n>stops</span> <span class=o>&gt;</span> <span class=n>epa</span><span class=o>.</span><span class=n>start</span><span class=p>)):</span>
            <span class=n>new_intervals</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>epa</span><span class=o>.</span><span class=n>start</span><span class=p>,</span> <span class=n>epa</span><span class=o>.</span><span class=n>stop</span><span class=p>])</span>
            <span class=n>cand_ep_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span>
                <span class=p>(</span><span class=n>interval</span><span class=o>.</span><span class=n>starts</span> <span class=o>&lt;</span> <span class=n>epa</span><span class=o>.</span><span class=n>stop</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>interval</span><span class=o>.</span><span class=n>stops</span> <span class=o>&gt;</span> <span class=n>epa</span><span class=o>.</span><span class=n>start</span><span class=p>)</span>
            <span class=p>)</span>
            <span class=n>indices</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>cand_ep_idx</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>out</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=n>epoch</span><span class=p>)(</span><span class=n>new_intervals</span><span class=p>)</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_domain</span> <span class=o>=</span> <span class=n>epoch</span><span class=o>.</span><span class=n>domain</span>
    <span class=k>if</span> <span class=n>return_indices</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>out</span><span class=p>,</span> <span class=n>indices</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.pairwise_corr class="doc doc-heading"> <code class="highlight language-python"><span class=n>pairwise_corr</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>method</span><span class=o>=</span><span class=s1>&#39;pearson&#39;</span><span class=p>,</span> <span class=n>pairs</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute pairwise correlations between all rows of a matrix.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>X</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>2D numpy array of shape (n, p), where n is the number of rows (variables) and p is the number of columns (features).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>method</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Correlation method to use ('pearson', 'spearman', or 'kendall'), by default "pearson".</p> </div> </td> <td> <code>&#39;pearson&#39;</code> </td> </tr> <tr class=doc-section-item> <td> <code>pairs</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of shape (m, 2) specifying the pairs of rows to compute correlations between. If None, computes correlations for all unique row pairs.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>rho</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of correlation coefficients.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>pval</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of p-values for the correlation tests.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>pairs</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of pairs (indices) for which correlations were computed.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Raises:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=ValueError>ValueError</span></code> </td> <td> <div class=doc-md-description> <p>If the method is not 'pearson', 'spearman', or 'kendall'.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>X</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>rho</span><span class=p>,</span> <span class=n>pval</span><span class=p>,</span> <span class=n>pairs</span> <span class=o>=</span> <span class=n>pairwise_corr</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>method</span><span class=o>=</span><span class=s2>&quot;spearman&quot;</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/correlations.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 51</span>
<span class=normal> 52</span>
<span class=normal> 53</span>
<span class=normal> 54</span>
<span class=normal> 55</span>
<span class=normal> 56</span>
<span class=normal> 57</span>
<span class=normal> 58</span>
<span class=normal> 59</span>
<span class=normal> 60</span>
<span class=normal> 61</span>
<span class=normal> 62</span>
<span class=normal> 63</span>
<span class=normal> 64</span>
<span class=normal> 65</span>
<span class=normal> 66</span>
<span class=normal> 67</span>
<span class=normal> 68</span>
<span class=normal> 69</span>
<span class=normal> 70</span>
<span class=normal> 71</span>
<span class=normal> 72</span>
<span class=normal> 73</span>
<span class=normal> 74</span>
<span class=normal> 75</span>
<span class=normal> 76</span>
<span class=normal> 77</span>
<span class=normal> 78</span>
<span class=normal> 79</span>
<span class=normal> 80</span>
<span class=normal> 81</span>
<span class=normal> 82</span>
<span class=normal> 83</span>
<span class=normal> 84</span>
<span class=normal> 85</span>
<span class=normal> 86</span>
<span class=normal> 87</span>
<span class=normal> 88</span>
<span class=normal> 89</span>
<span class=normal> 90</span>
<span class=normal> 91</span>
<span class=normal> 92</span>
<span class=normal> 93</span>
<span class=normal> 94</span>
<span class=normal> 95</span>
<span class=normal> 96</span>
<span class=normal> 97</span>
<span class=normal> 98</span>
<span class=normal> 99</span>
<span class=normal>100</span>
<span class=normal>101</span>
<span class=normal>102</span>
<span class=normal>103</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>pairwise_corr</span><span class=p>(</span>
    <span class=n>X</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>method</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s2>&quot;pearson&quot;</span><span class=p>,</span> <span class=n>pairs</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute pairwise correlations between all rows of a matrix.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    X : np.ndarray</span>
<span class=sd>        2D numpy array of shape (n, p), where n is the number of rows (variables) and p is the number of columns (features).</span>
<span class=sd>    method : str, optional</span>
<span class=sd>        Correlation method to use (&#39;pearson&#39;, &#39;spearman&#39;, or &#39;kendall&#39;), by default &quot;pearson&quot;.</span>
<span class=sd>    pairs : np.ndarray, optional</span>
<span class=sd>        Array of shape (m, 2) specifying the pairs of rows to compute correlations between.</span>
<span class=sd>        If None, computes correlations for all unique row pairs.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    rho : np.ndarray</span>
<span class=sd>        Array of correlation coefficients.</span>
<span class=sd>    pval : np.ndarray</span>
<span class=sd>        Array of p-values for the correlation tests.</span>
<span class=sd>    pairs : np.ndarray</span>
<span class=sd>        Array of pairs (indices) for which correlations were computed.</span>

<span class=sd>    Raises</span>
<span class=sd>    ------</span>
<span class=sd>    ValueError</span>
<span class=sd>        If the method is not &#39;pearson&#39;, &#39;spearman&#39;, or &#39;kendall&#39;.</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; X = np.random.rand(10, 5)</span>
<span class=sd>    &gt;&gt;&gt; rho, pval, pairs = pairwise_corr(X, method=&quot;spearman&quot;)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>pairs</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>X</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=n>pairs</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>itertools</span><span class=o>.</span><span class=n>combinations</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=mi>2</span><span class=p>)))</span>

    <span class=n>rho</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>pval</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>pairs</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>method</span> <span class=o>==</span> <span class=s2>&quot;pearson&quot;</span><span class=p>:</span>
            <span class=n>rho_</span><span class=p>,</span> <span class=n>pval_</span> <span class=o>=</span> <span class=n>stats</span><span class=o>.</span><span class=n>pearsonr</span><span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=p>:],</span> <span class=n>X</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=p>:])</span>
        <span class=k>elif</span> <span class=n>method</span> <span class=o>==</span> <span class=s2>&quot;spearman&quot;</span><span class=p>:</span>
            <span class=n>rho_</span><span class=p>,</span> <span class=n>pval_</span> <span class=o>=</span> <span class=n>stats</span><span class=o>.</span><span class=n>spearmanr</span><span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=p>:],</span> <span class=n>X</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=p>:])</span>
        <span class=k>elif</span> <span class=n>method</span> <span class=o>==</span> <span class=s2>&quot;kendall&quot;</span><span class=p>:</span>
            <span class=n>rho_</span><span class=p>,</span> <span class=n>pval_</span> <span class=o>=</span> <span class=n>stats</span><span class=o>.</span><span class=n>kendalltau</span><span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=p>:],</span> <span class=n>X</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=p>:])</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;method must be pearson, spearman or kendall&quot;</span><span class=p>)</span>
        <span class=n>rho</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>rho_</span><span class=p>)</span>
        <span class=n>pval</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>pval_</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>rho</span><span class=p>,</span> <span class=n>pval</span><span class=p>,</span> <span class=n>pairs</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.pairwise_cross_corr class="doc doc-heading"> <code class="highlight language-python"><span class=n>pairwise_cross_corr</span><span class=p>(</span><span class=n>spks</span><span class=p>,</span> <span class=n>binsize</span><span class=o>=</span><span class=mf>0.001</span><span class=p>,</span> <span class=n>nbins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>return_index</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>pairs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>deconvolve</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute pairwise time-lagged cross-correlations between spike trains of different cells.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>spks</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Nested numpy arrays, where each array contains the spike times for a cell.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>binsize</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The size of time bins in seconds. Default is 0.001 (1 ms).</p> </div> </td> <td> <code>0.001</code> </td> </tr> <tr class=doc-section-item> <td> <code>nbins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of bins to use for the correlation window. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>return_index</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to return the index (pairs) of cells used for the correlation. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>pairs</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Precomputed list of pairs of cells (indices) to compute the cross-correlation for. If None, all unique pairs will be computed. Default is None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>deconvolve</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to apply deconvolution when computing the cross-correlation. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>crosscorrs</code></td> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>A pandas DataFrame of shape (t, n_pairs), where t is the time axis and n_pairs are the pairs of cells.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>pairs</code></td> <td> <code>(<span title=numpy.ndarray>ndarray</span>, <span title=optional>optional</span>)</code> </td> <td> <div class=doc-md-description> <p>The pairs of cells for which cross-correlations were computed. Returned only if <code>return_index</code> is True.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>spks</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>100</span><span class=p>)])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>crosscorrs</span><span class=p>,</span> <span class=n>pairs</span> <span class=o>=</span> <span class=n>pairwise_cross_corr</span><span class=p>(</span><span class=n>spks</span><span class=p>,</span> <span class=n>binsize</span><span class=o>=</span><span class=mf>0.01</span><span class=p>,</span> <span class=n>nbins</span><span class=o>=</span><span class=mi>50</span><span class=p>,</span> <span class=n>return_index</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/correlations.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>106</span>
<span class=normal>107</span>
<span class=normal>108</span>
<span class=normal>109</span>
<span class=normal>110</span>
<span class=normal>111</span>
<span class=normal>112</span>
<span class=normal>113</span>
<span class=normal>114</span>
<span class=normal>115</span>
<span class=normal>116</span>
<span class=normal>117</span>
<span class=normal>118</span>
<span class=normal>119</span>
<span class=normal>120</span>
<span class=normal>121</span>
<span class=normal>122</span>
<span class=normal>123</span>
<span class=normal>124</span>
<span class=normal>125</span>
<span class=normal>126</span>
<span class=normal>127</span>
<span class=normal>128</span>
<span class=normal>129</span>
<span class=normal>130</span>
<span class=normal>131</span>
<span class=normal>132</span>
<span class=normal>133</span>
<span class=normal>134</span>
<span class=normal>135</span>
<span class=normal>136</span>
<span class=normal>137</span>
<span class=normal>138</span>
<span class=normal>139</span>
<span class=normal>140</span>
<span class=normal>141</span>
<span class=normal>142</span>
<span class=normal>143</span>
<span class=normal>144</span>
<span class=normal>145</span>
<span class=normal>146</span>
<span class=normal>147</span>
<span class=normal>148</span>
<span class=normal>149</span>
<span class=normal>150</span>
<span class=normal>151</span>
<span class=normal>152</span>
<span class=normal>153</span>
<span class=normal>154</span>
<span class=normal>155</span>
<span class=normal>156</span>
<span class=normal>157</span>
<span class=normal>158</span>
<span class=normal>159</span>
<span class=normal>160</span>
<span class=normal>161</span>
<span class=normal>162</span>
<span class=normal>163</span>
<span class=normal>164</span>
<span class=normal>165</span>
<span class=normal>166</span>
<span class=normal>167</span>
<span class=normal>168</span>
<span class=normal>169</span>
<span class=normal>170</span>
<span class=normal>171</span>
<span class=normal>172</span>
<span class=normal>173</span>
<span class=normal>174</span>
<span class=normal>175</span>
<span class=normal>176</span>
<span class=normal>177</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>pairwise_cross_corr</span><span class=p>(</span>
    <span class=n>spks</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>binsize</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.001</span><span class=p>,</span>
    <span class=n>nbins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>return_index</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
    <span class=n>pairs</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>deconvolve</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>,</span> <span class=n>Optional</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute pairwise time-lagged cross-correlations between spike trains of different cells.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    spks : np.ndarray</span>
<span class=sd>        Nested numpy arrays, where each array contains the spike times for a cell.</span>
<span class=sd>    binsize : float, optional</span>
<span class=sd>        The size of time bins in seconds. Default is 0.001 (1 ms).</span>
<span class=sd>    nbins : int, optional</span>
<span class=sd>        Number of bins to use for the correlation window. Default is 100.</span>
<span class=sd>    return_index : bool, optional</span>
<span class=sd>        Whether to return the index (pairs) of cells used for the correlation. Default is False.</span>
<span class=sd>    pairs : np.ndarray, optional</span>
<span class=sd>        Precomputed list of pairs of cells (indices) to compute the cross-correlation for.</span>
<span class=sd>        If None, all unique pairs will be computed. Default is None.</span>
<span class=sd>    deconvolve : bool, optional</span>
<span class=sd>        Whether to apply deconvolution when computing the cross-correlation. Default is False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    crosscorrs : pd.DataFrame</span>
<span class=sd>        A pandas DataFrame of shape (t, n_pairs), where t is the time axis and n_pairs are the pairs of cells.</span>
<span class=sd>    pairs : np.ndarray, optional</span>
<span class=sd>        The pairs of cells for which cross-correlations were computed. Returned only if `return_index` is True.</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; spks = np.array([np.random.rand(100), np.random.rand(100)])</span>
<span class=sd>    &gt;&gt;&gt; crosscorrs, pairs = pairwise_cross_corr(spks, binsize=0.01, nbins=50, return_index=True)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Get unique combo without repeats</span>
    <span class=k>if</span> <span class=n>pairs</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>spks</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=n>pairs</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>itertools</span><span class=o>.</span><span class=n>combinations</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=mi>2</span><span class=p>)))</span>

    <span class=c1># prepare a pandas dataframe to receive the data</span>
    <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=o>-</span><span class=p>(</span><span class=n>nbins</span> <span class=o>*</span> <span class=n>binsize</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>nbins</span> <span class=o>*</span> <span class=n>binsize</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>nbins</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>compute_crosscorr</span><span class=p>(</span><span class=n>pair</span><span class=p>):</span>
        <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>pair</span>
        <span class=n>crosscorr</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>(</span><span class=n>spks</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>spks</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>binsize</span><span class=p>,</span> <span class=n>nbins</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>crosscorr</span>

    <span class=k>def</span><span class=w> </span><span class=nf>compute_crosscorr_deconvolve</span><span class=p>(</span><span class=n>pair</span><span class=p>):</span>
        <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>pair</span>
        <span class=n>crosscorr</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>deconvolve_peth</span><span class=p>(</span><span class=n>spks</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>spks</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>binsize</span><span class=p>,</span> <span class=n>nbins</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>crosscorr</span>

    <span class=k>if</span> <span class=n>deconvolve</span><span class=p>:</span>
        <span class=n>crosscorrs</span> <span class=o>=</span> <span class=p>[</span><span class=n>compute_crosscorr_deconvolve</span><span class=p>(</span><span class=n>pair</span><span class=p>)</span> <span class=k>for</span> <span class=n>pair</span> <span class=ow>in</span> <span class=n>pairs</span><span class=p>]</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>crosscorrs</span> <span class=o>=</span> <span class=p>[</span><span class=n>compute_crosscorr</span><span class=p>(</span><span class=n>pair</span><span class=p>)</span> <span class=k>for</span> <span class=n>pair</span> <span class=ow>in</span> <span class=n>pairs</span><span class=p>]</span>

    <span class=n>crosscorrs</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span>
        <span class=n>index</span><span class=o>=</span><span class=n>times</span><span class=p>,</span>
        <span class=n>data</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>crosscorrs</span><span class=p>)</span><span class=o>.</span><span class=n>T</span><span class=p>,</span>
        <span class=n>columns</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>pairs</span><span class=p>)),</span>
    <span class=p>)</span>

    <span class=k>if</span> <span class=n>return_index</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>crosscorrs</span><span class=p>,</span> <span class=n>pairs</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>crosscorrs</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.pairwise_event_triggered_cross_correlation class="doc doc-heading"> <code class="highlight language-python"><span class=n>pairwise_event_triggered_cross_correlation</span><span class=p>(</span><span class=n>event_times</span><span class=p>,</span> <span class=n>signals_data</span><span class=p>,</span> <span class=n>signals_ts</span><span class=p>,</span> <span class=n>time_lags</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.005</span><span class=p>,</span> <span class=n>pairs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>n_jobs</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Computes event-triggered cross-correlation for all unique signal pairs.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>event_times</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of event times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>signals_data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>2D array (n_signals, n_samples) of signal data.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>signals_ts</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of timestamps for each signal.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_lags</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=numpy.ndarray>ndarray</span>, None]</code> </td> <td> <div class=doc-md-description> <p>Array of time lags to compute correlation. If None, computed automatically.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>Window to compute correlation. Default is [-0.5, 0.5].</p> </div> </td> <td> <code>[-0.5, 0.5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Bin width to compute correlation. Default is 0.005.</p> </div> </td> <td> <code>0.005</code> </td> </tr> <tr class=doc-section-item> <td> <code>pairs</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=numpy.ndarray>ndarray</span>]</code> </td> <td> <div class=doc-md-description> <p>Array of shape (n_pairs, 2) specifying pairs of signals to compute correlations for. If None, computes correlations for all unique signal pairs.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>correlation_lags</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of time lags.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>avg_correlation</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of shape (n_pairs, n_lags) with average correlation for each pair.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>pairs</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of shape (n_pairs, 2) with indices of signal pairs.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/correlations.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>401</span>
<span class=normal>402</span>
<span class=normal>403</span>
<span class=normal>404</span>
<span class=normal>405</span>
<span class=normal>406</span>
<span class=normal>407</span>
<span class=normal>408</span>
<span class=normal>409</span>
<span class=normal>410</span>
<span class=normal>411</span>
<span class=normal>412</span>
<span class=normal>413</span>
<span class=normal>414</span>
<span class=normal>415</span>
<span class=normal>416</span>
<span class=normal>417</span>
<span class=normal>418</span>
<span class=normal>419</span>
<span class=normal>420</span>
<span class=normal>421</span>
<span class=normal>422</span>
<span class=normal>423</span>
<span class=normal>424</span>
<span class=normal>425</span>
<span class=normal>426</span>
<span class=normal>427</span>
<span class=normal>428</span>
<span class=normal>429</span>
<span class=normal>430</span>
<span class=normal>431</span>
<span class=normal>432</span>
<span class=normal>433</span>
<span class=normal>434</span>
<span class=normal>435</span>
<span class=normal>436</span>
<span class=normal>437</span>
<span class=normal>438</span>
<span class=normal>439</span>
<span class=normal>440</span>
<span class=normal>441</span>
<span class=normal>442</span>
<span class=normal>443</span>
<span class=normal>444</span>
<span class=normal>445</span>
<span class=normal>446</span>
<span class=normal>447</span>
<span class=normal>448</span>
<span class=normal>449</span>
<span class=normal>450</span>
<span class=normal>451</span>
<span class=normal>452</span>
<span class=normal>453</span>
<span class=normal>454</span>
<span class=normal>455</span>
<span class=normal>456</span>
<span class=normal>457</span>
<span class=normal>458</span>
<span class=normal>459</span>
<span class=normal>460</span>
<span class=normal>461</span>
<span class=normal>462</span>
<span class=normal>463</span>
<span class=normal>464</span>
<span class=normal>465</span>
<span class=normal>466</span>
<span class=normal>467</span>
<span class=normal>468</span>
<span class=normal>469</span>
<span class=normal>470</span>
<span class=normal>471</span>
<span class=normal>472</span>
<span class=normal>473</span>
<span class=normal>474</span>
<span class=normal>475</span>
<span class=normal>476</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>pairwise_event_triggered_cross_correlation</span><span class=p>(</span>
    <span class=n>event_times</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>signals_data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>signals_ts</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>time_lags</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=nb>list</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.005</span><span class=p>,</span>
    <span class=n>pairs</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>n_jobs</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Computes event-triggered cross-correlation for all unique signal pairs.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    event_times : np.ndarray</span>
<span class=sd>        Array of event times.</span>
<span class=sd>    signals_data : np.ndarray</span>
<span class=sd>        2D array (n_signals, n_samples) of signal data.</span>
<span class=sd>    signals_ts : np.ndarray</span>
<span class=sd>        Array of timestamps for each signal.</span>
<span class=sd>    time_lags : Union[np.ndarray, None], optional</span>
<span class=sd>        Array of time lags to compute correlation. If None, computed automatically.</span>
<span class=sd>    window : list, optional</span>
<span class=sd>        Window to compute correlation. Default is [-0.5, 0.5].</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        Bin width to compute correlation. Default is 0.005.</span>
<span class=sd>    pairs : Optional[np.ndarray], optional</span>
<span class=sd>        Array of shape (n_pairs, 2) specifying pairs of signals to compute correlations for.</span>
<span class=sd>        If None, computes correlations for all unique signal pairs.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    correlation_lags : np.ndarray</span>
<span class=sd>        Array of time lags.</span>
<span class=sd>    avg_correlation : np.ndarray</span>
<span class=sd>        Array of shape (n_pairs, n_lags) with average correlation for each pair.</span>
<span class=sd>    pairs : np.ndarray</span>
<span class=sd>        Array of shape (n_pairs, 2) with indices of signal pairs.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=n>pairs</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>n_signals</span> <span class=o>=</span> <span class=n>signals_data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=n>pairs</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>itertools</span><span class=o>.</span><span class=n>combinations</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>n_signals</span><span class=p>),</span> <span class=mi>2</span><span class=p>)))</span>

    <span class=k>def</span><span class=w> </span><span class=nf>compute_pair</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>):</span>
        <span class=n>lags</span><span class=p>,</span> <span class=n>corr</span> <span class=o>=</span> <span class=n>event_triggered_cross_correlation</span><span class=p>(</span>
            <span class=n>event_times</span><span class=p>,</span>
            <span class=n>signals_data</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=p>:],</span>
            <span class=n>signals_ts</span><span class=p>,</span>
            <span class=n>signals_data</span><span class=p>[</span><span class=n>j</span><span class=p>,</span> <span class=p>:],</span>
            <span class=n>signals_ts</span><span class=p>,</span>
            <span class=n>time_lags</span><span class=o>=</span><span class=n>time_lags</span><span class=p>,</span>
            <span class=n>window</span><span class=o>=</span><span class=n>window</span><span class=p>,</span>
            <span class=n>bin_width</span><span class=o>=</span><span class=n>bin_width</span><span class=p>,</span>
        <span class=p>)</span>
        <span class=k>return</span> <span class=n>corr</span>

    <span class=n>results</span> <span class=o>=</span> <span class=n>Parallel</span><span class=p>(</span><span class=n>n_jobs</span><span class=o>=</span><span class=n>n_jobs</span><span class=p>,</span> <span class=n>prefer</span><span class=o>=</span><span class=s2>&quot;processes&quot;</span><span class=p>)(</span>
        <span class=n>delayed</span><span class=p>(</span><span class=n>compute_pair</span><span class=p>)(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>pairs</span>
    <span class=p>)</span>
    <span class=n>avg_correlation</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>(</span><span class=n>results</span><span class=p>)</span>

    <span class=c1># Calculate lags directly (avoid extra function call)</span>
    <span class=k>if</span> <span class=n>time_lags</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>time_lags_arr</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>bin_width</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>time_lags_arr</span> <span class=o>=</span> <span class=n>time_lags</span>
    <span class=n>n_lags</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_lags_arr</span><span class=p>)</span>
    <span class=n>max_lag_samples</span> <span class=o>=</span> <span class=n>n_lags</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=n>lags</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=o>-</span><span class=n>max_lag_samples</span><span class=p>,</span> <span class=n>max_lag_samples</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span>
        <span class=n>time_lags_arr</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>time_lags_arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=p>)</span>
    <span class=n>lags</span> <span class=o>=</span> <span class=n>lags</span><span class=p>[(</span><span class=n>lags</span> <span class=o>&gt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>lags</span> <span class=o>&lt;=</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>])]</span>

    <span class=k>return</span> <span class=n>lags</span><span class=p>,</span> <span class=n>avg_correlation</span><span class=p>,</span> <span class=n>pairs</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.pairwise_spatial_corr class="doc doc-heading"> <code class="highlight language-python"><span class=n>pairwise_spatial_corr</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>return_index</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>pairs</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute pairwise spatial correlations between cells' spatial maps.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>X</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 3D numpy array of shape (n_cells, n_space, n_space) representing the spatial maps of cells.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>return_index</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, returns the indices of the cell pairs used for the correlation.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>pairs</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of cell pairs for which to compute the correlation. If not provided, all unique pairs are used.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>spatial_corr</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array containing the Pearson correlation coefficients for each pair of cells.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>pairs</code></td> <td> <code>(<span title=numpy.ndarray>ndarray</span>, <span title=optional>optional</span>)</code> </td> <td> <div class=doc-md-description> <p>Array of cell pairs used for the correlation (if return_index is True).</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/correlations.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>180</span>
<span class=normal>181</span>
<span class=normal>182</span>
<span class=normal>183</span>
<span class=normal>184</span>
<span class=normal>185</span>
<span class=normal>186</span>
<span class=normal>187</span>
<span class=normal>188</span>
<span class=normal>189</span>
<span class=normal>190</span>
<span class=normal>191</span>
<span class=normal>192</span>
<span class=normal>193</span>
<span class=normal>194</span>
<span class=normal>195</span>
<span class=normal>196</span>
<span class=normal>197</span>
<span class=normal>198</span>
<span class=normal>199</span>
<span class=normal>200</span>
<span class=normal>201</span>
<span class=normal>202</span>
<span class=normal>203</span>
<span class=normal>204</span>
<span class=normal>205</span>
<span class=normal>206</span>
<span class=normal>207</span>
<span class=normal>208</span>
<span class=normal>209</span>
<span class=normal>210</span>
<span class=normal>211</span>
<span class=normal>212</span>
<span class=normal>213</span>
<span class=normal>214</span>
<span class=normal>215</span>
<span class=normal>216</span>
<span class=normal>217</span>
<span class=normal>218</span>
<span class=normal>219</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>pairwise_spatial_corr</span><span class=p>(</span>
    <span class=n>X</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>return_index</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span> <span class=n>pairs</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span> <span class=o>=</span> <span class=kc>None</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute pairwise spatial correlations between cells&#39; spatial maps.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    X : np.ndarray</span>
<span class=sd>        A 3D numpy array of shape (n_cells, n_space, n_space) representing the spatial maps of cells.</span>
<span class=sd>    return_index : bool, optional</span>
<span class=sd>        If True, returns the indices of the cell pairs used for the correlation.</span>
<span class=sd>    pairs : np.ndarray, optional</span>
<span class=sd>        Array of cell pairs for which to compute the correlation. If not provided, all unique pairs are used.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    spatial_corr : np.ndarray</span>
<span class=sd>        Array containing the Pearson correlation coefficients for each pair of cells.</span>
<span class=sd>    pairs : np.ndarray, optional</span>
<span class=sd>        Array of cell pairs used for the correlation (if return_index is True).</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Get unique combo without repeats</span>
    <span class=k>if</span> <span class=n>pairs</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>X</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=n>pairs</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>itertools</span><span class=o>.</span><span class=n>combinations</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=mi>2</span><span class=p>)))</span>

    <span class=n>spatial_corr</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=c1># Now we can iterate over spikes</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>pairs</span><span class=p>):</span>
        <span class=c1># Calling the crossCorr function</span>
        <span class=n>x1</span> <span class=o>=</span> <span class=n>X</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=p>:,</span> <span class=p>:]</span><span class=o>.</span><span class=n>flatten</span><span class=p>()</span>
        <span class=n>x2</span> <span class=o>=</span> <span class=n>X</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=p>:,</span> <span class=p>:]</span><span class=o>.</span><span class=n>flatten</span><span class=p>()</span>
        <span class=n>bad_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>isnan</span><span class=p>(</span><span class=n>x1</span><span class=p>)</span> <span class=o>|</span> <span class=n>np</span><span class=o>.</span><span class=n>isnan</span><span class=p>(</span><span class=n>x2</span><span class=p>)</span>
        <span class=n>spatial_corr</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>corrcoef</span><span class=p>(</span><span class=n>x1</span><span class=p>[</span><span class=o>~</span><span class=n>bad_idx</span><span class=p>],</span> <span class=n>x2</span><span class=p>[</span><span class=o>~</span><span class=n>bad_idx</span><span class=p>])[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>

    <span class=k>if</span> <span class=n>return_index</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>spatial_corr</span><span class=p>),</span> <span class=n>pairs</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>spatial_corr</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.peth_matrix class="doc doc-heading"> <code class="highlight language-python"><span class=n>peth_matrix</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>time_ref</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.002</span><span class=p>,</span> <span class=n>n_bins</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>window</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Generate a peri-event time histogram (PETH) matrix.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of time values.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time_ref</code> </td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of reference times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of each bin in the PETH matrix, in seconds. Default is 0.002 seconds.</p> </div> </td> <td> <code>0.002</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_bins</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of bins in the PETH matrix. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>window</code> </td> <td> <code><span title=tuple>tuple</span></code> </td> <td> <div class=doc-md-description> <p>A tuple containing the start and end times of the window to be plotted around each reference time. If not provided, the window will be centered around each reference time and have a width of <code>n_bins * bin_width</code> seconds.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>H</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array representing the PETH matrix.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>t</code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 1D array of time values corresponding to the bins in the PETH matrix.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>385</span>
<span class=normal>386</span>
<span class=normal>387</span>
<span class=normal>388</span>
<span class=normal>389</span>
<span class=normal>390</span>
<span class=normal>391</span>
<span class=normal>392</span>
<span class=normal>393</span>
<span class=normal>394</span>
<span class=normal>395</span>
<span class=normal>396</span>
<span class=normal>397</span>
<span class=normal>398</span>
<span class=normal>399</span>
<span class=normal>400</span>
<span class=normal>401</span>
<span class=normal>402</span>
<span class=normal>403</span>
<span class=normal>404</span>
<span class=normal>405</span>
<span class=normal>406</span>
<span class=normal>407</span>
<span class=normal>408</span>
<span class=normal>409</span>
<span class=normal>410</span>
<span class=normal>411</span>
<span class=normal>412</span>
<span class=normal>413</span>
<span class=normal>414</span>
<span class=normal>415</span>
<span class=normal>416</span>
<span class=normal>417</span>
<span class=normal>418</span>
<span class=normal>419</span>
<span class=normal>420</span>
<span class=normal>421</span>
<span class=normal>422</span>
<span class=normal>423</span>
<span class=normal>424</span>
<span class=normal>425</span>
<span class=normal>426</span>
<span class=normal>427</span>
<span class=normal>428</span>
<span class=normal>429</span>
<span class=normal>430</span>
<span class=normal>431</span>
<span class=normal>432</span>
<span class=normal>433</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>parallel</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>peth_matrix</span><span class=p>(</span>
    <span class=n>data</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>time_ref</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.002</span><span class=p>,</span>
    <span class=n>n_bins</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>window</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>list</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Generate a peri-event time histogram (PETH) matrix.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : ndarray</span>
<span class=sd>        A 1D array of time values.</span>
<span class=sd>    time_ref : ndarray</span>
<span class=sd>        A 1D array of reference times.</span>
<span class=sd>    bin_width : float, optional</span>
<span class=sd>        The width of each bin in the PETH matrix, in seconds. Default is 0.002 seconds.</span>
<span class=sd>    n_bins : int, optional</span>
<span class=sd>        The number of bins in the PETH matrix. Default is 100.</span>
<span class=sd>    window : tuple, optional</span>
<span class=sd>        A tuple containing the start and end times of the window to be plotted around each reference time.</span>
<span class=sd>        If not provided, the window will be centered around each reference time and have a width of `n_bins * bin_width` seconds.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    H : ndarray</span>
<span class=sd>        A 2D array representing the PETH matrix.</span>
<span class=sd>    t : ndarray</span>
<span class=sd>        A 1D array of time values corresponding to the bins in the PETH matrix.</span>

<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>window</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>window</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
        <span class=n>n_bins</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>times</span> <span class=o>=</span> <span class=p>(</span>
            <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>bin_width</span> <span class=o>*</span> <span class=n>n_bins</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
            <span class=o>-</span> <span class=p>(</span><span class=n>bin_width</span> <span class=o>*</span> <span class=n>n_bins</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
            <span class=o>+</span> <span class=n>bin_width</span> <span class=o>/</span> <span class=mi>2</span>
        <span class=p>)</span>

    <span class=n>H</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=nb>len</span><span class=p>(</span><span class=n>times</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>time_ref</span><span class=p>)))</span>

    <span class=k>for</span> <span class=n>event_i</span> <span class=ow>in</span> <span class=n>prange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>time_ref</span><span class=p>)):</span>
        <span class=n>H</span><span class=p>[:,</span> <span class=n>event_i</span><span class=p>]</span> <span class=o>=</span> <span class=n>crossCorr</span><span class=p>([</span><span class=n>time_ref</span><span class=p>[</span><span class=n>event_i</span><span class=p>]],</span> <span class=n>data</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>n_bins</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>H</span> <span class=o>*</span> <span class=n>bin_width</span><span class=p>,</span> <span class=n>times</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.point_spectra class="doc doc-heading"> <code class="highlight language-python"><span class=n>point_spectra</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>Fs</span><span class=o>=</span><span class=mi>1250</span><span class=p>,</span> <span class=n>freq_range</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>20</span><span class=p>],</span> <span class=n>tapers0</span><span class=o>=</span><span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>],</span> <span class=n>pad</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>nfft</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Compute multitaper power spectrum for point processes.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>times</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of spike times (in seconds).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>Fs</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency (default is 1250 Hz).</p> </div> </td> <td> <code>1250</code> </td> </tr> <tr class=doc-section-item> <td> <code>freq_range</code> </td> <td> <code><span title=typing.List>List</span>[<span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>Frequency range to evaluate (default is [1, 20] Hz).</p> </div> </td> <td> <code>[1, 20]</code> </td> </tr> <tr class=doc-section-item> <td> <code>tapers0</code> </td> <td> <code><span title=typing.List>List</span>[<span title=int>int</span>]</code> </td> <td> <div class=doc-md-description> <p>Time-bandwidth product and number of tapers (default is [3, 5]). The time-bandwidth product is used to compute the tapers.</p> </div> </td> <td> <code>[3, 5]</code> </td> </tr> <tr class=doc-section-item> <td> <code>pad</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Padding for the FFT (default is 0).</p> </div> </td> <td> <code>0</code> </td> </tr> <tr class=doc-section-item> <td> <code>nfft</code> </td> <td> <code><span title=typing.Optional>Optional</span>[<span title=int>int</span>]</code> </td> <td> <div class=doc-md-description> <p>Number of points for FFT (default is None).</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>spectra</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Power spectrum.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>f</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Frequency vector.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>Alternative function to <code>mtspectrumpt</code> for computing the power spectrum</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/pychronux.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>413</span>
<span class=normal>414</span>
<span class=normal>415</span>
<span class=normal>416</span>
<span class=normal>417</span>
<span class=normal>418</span>
<span class=normal>419</span>
<span class=normal>420</span>
<span class=normal>421</span>
<span class=normal>422</span>
<span class=normal>423</span>
<span class=normal>424</span>
<span class=normal>425</span>
<span class=normal>426</span>
<span class=normal>427</span>
<span class=normal>428</span>
<span class=normal>429</span>
<span class=normal>430</span>
<span class=normal>431</span>
<span class=normal>432</span>
<span class=normal>433</span>
<span class=normal>434</span>
<span class=normal>435</span>
<span class=normal>436</span>
<span class=normal>437</span>
<span class=normal>438</span>
<span class=normal>439</span>
<span class=normal>440</span>
<span class=normal>441</span>
<span class=normal>442</span>
<span class=normal>443</span>
<span class=normal>444</span>
<span class=normal>445</span>
<span class=normal>446</span>
<span class=normal>447</span>
<span class=normal>448</span>
<span class=normal>449</span>
<span class=normal>450</span>
<span class=normal>451</span>
<span class=normal>452</span>
<span class=normal>453</span>
<span class=normal>454</span>
<span class=normal>455</span>
<span class=normal>456</span>
<span class=normal>457</span>
<span class=normal>458</span>
<span class=normal>459</span>
<span class=normal>460</span>
<span class=normal>461</span>
<span class=normal>462</span>
<span class=normal>463</span>
<span class=normal>464</span>
<span class=normal>465</span>
<span class=normal>466</span>
<span class=normal>467</span>
<span class=normal>468</span>
<span class=normal>469</span>
<span class=normal>470</span>
<span class=normal>471</span>
<span class=normal>472</span>
<span class=normal>473</span>
<span class=normal>474</span>
<span class=normal>475</span>
<span class=normal>476</span>
<span class=normal>477</span>
<span class=normal>478</span>
<span class=normal>479</span>
<span class=normal>480</span>
<span class=normal>481</span>
<span class=normal>482</span>
<span class=normal>483</span>
<span class=normal>484</span>
<span class=normal>485</span>
<span class=normal>486</span>
<span class=normal>487</span>
<span class=normal>488</span>
<span class=normal>489</span>
<span class=normal>490</span>
<span class=normal>491</span>
<span class=normal>492</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>point_spectra</span><span class=p>(</span>
    <span class=n>times</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>Fs</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>1250</span><span class=p>,</span>
    <span class=n>freq_range</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>20</span><span class=p>],</span>
    <span class=n>tapers0</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>],</span>
    <span class=n>pad</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
    <span class=n>nfft</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute multitaper power spectrum for point processes.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    times : np.ndarray</span>
<span class=sd>        Array of spike times (in seconds).</span>
<span class=sd>    Fs : int, optional</span>
<span class=sd>        Sampling frequency (default is 1250 Hz).</span>
<span class=sd>    freq_range : List[float], optional</span>
<span class=sd>        Frequency range to evaluate (default is [1, 20] Hz).</span>
<span class=sd>    tapers0 : List[int], optional</span>
<span class=sd>        Time-bandwidth product and number of tapers (default is [3, 5]).</span>
<span class=sd>        The time-bandwidth product is used to compute the tapers.</span>
<span class=sd>    pad : int, optional</span>
<span class=sd>        Padding for the FFT (default is 0).</span>
<span class=sd>    nfft : Optional[int], optional</span>
<span class=sd>        Number of points for FFT (default is None).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    spectra : np.ndarray</span>
<span class=sd>        Power spectrum.</span>
<span class=sd>    f : np.ndarray</span>
<span class=sd>        Frequency vector.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Alternative function to `mtspectrumpt` for computing the power spectrum</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># generate frequency grid</span>
    <span class=n>timesRange</span> <span class=o>=</span> <span class=p>[</span><span class=nb>min</span><span class=p>(</span><span class=n>times</span><span class=p>),</span> <span class=nb>max</span><span class=p>(</span><span class=n>times</span><span class=p>)]</span>
    <span class=n>window</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>floor</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>timesRange</span><span class=p>))</span>
    <span class=n>nSamplesPerWindow</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>round</span><span class=p>(</span><span class=n>Fs</span> <span class=o>*</span> <span class=n>window</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
    <span class=k>if</span> <span class=n>nfft</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>nfft</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span>
            <span class=p>[(</span><span class=nb>int</span><span class=p>(</span><span class=mi>2</span> <span class=o>**</span> <span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>log2</span><span class=p>(</span><span class=n>nSamplesPerWindow</span><span class=p>)))</span> <span class=o>+</span> <span class=n>pad</span><span class=p>),</span> <span class=n>nSamplesPerWindow</span><span class=p>]</span>
        <span class=p>)</span>
    <span class=n>fAll</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>Fs</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=n>nfft</span><span class=p>))</span>
    <span class=n>frequency_ind</span> <span class=o>=</span> <span class=p>(</span><span class=n>fAll</span> <span class=o>&gt;=</span> <span class=n>freq_range</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>fAll</span> <span class=o>&lt;=</span> <span class=n>freq_range</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>

    <span class=c1># Generate tapers</span>
    <span class=n>tapers</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>dpss</span><span class=p>(</span><span class=n>nSamplesPerWindow</span><span class=p>,</span> <span class=n>tapers0</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>tapers0</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>return_ratios</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
    <span class=n>tapers</span> <span class=o>=</span> <span class=n>tapers</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>Fs</span><span class=p>)</span>

    <span class=c1># Compute FFT of tapers and restrict to required frequencies</span>
    <span class=n>H</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>fft</span><span class=o>.</span><span class=n>fft</span><span class=p>(</span><span class=n>tapers</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=n>nfft</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># Shape: (K, nfft)</span>
    <span class=n>H</span> <span class=o>=</span> <span class=n>H</span><span class=p>[:,</span> <span class=n>frequency_ind</span><span class=p>]</span>  <span class=c1># Shape: (K, Nf)</span>

    <span class=c1># Angular frequencies</span>
    <span class=n>f</span> <span class=o>=</span> <span class=n>fAll</span><span class=p>[</span><span class=n>frequency_ind</span><span class=p>]</span>
    <span class=n>w</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=n>f</span>

    <span class=c1># Time grid</span>
    <span class=n>timegrid</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=n>timesRange</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>timesRange</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>nSamplesPerWindow</span><span class=p>)</span>

    <span class=c1># Ensure times are within range</span>
    <span class=n>data</span> <span class=o>=</span> <span class=n>times</span><span class=p>[(</span><span class=n>times</span> <span class=o>&gt;=</span> <span class=n>timegrid</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>times</span> <span class=o>&lt;=</span> <span class=n>timegrid</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])]</span>

    <span class=c1># Project spike times onto tapers</span>
    <span class=n>data_proj</span> <span class=o>=</span> <span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>interp</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>timegrid</span><span class=p>,</span> <span class=n>taper</span><span class=p>)</span> <span class=k>for</span> <span class=n>taper</span> <span class=ow>in</span> <span class=n>tapers</span><span class=p>]</span>
    <span class=n>data_proj</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>(</span><span class=n>data_proj</span><span class=p>)</span>  <span class=c1># Shape: (K, len(data))</span>

    <span class=c1># Compute multitaper spectrum</span>
    <span class=n>exponential</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>exp</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>outer</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=n>j</span> <span class=o>*</span> <span class=n>w</span><span class=p>,</span> <span class=p>(</span><span class=n>data</span> <span class=o>-</span> <span class=n>timegrid</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
    <span class=p>)</span>  <span class=c1># Shape: (Nf, len(data))</span>
    <span class=n>J</span> <span class=o>=</span> <span class=n>exponential</span> <span class=o>@</span> <span class=n>data_proj</span><span class=o>.</span><span class=n>T</span> <span class=o>-</span> <span class=n>H</span><span class=o>.</span><span class=n>T</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>timegrid</span><span class=p>)</span>  <span class=c1># Shape: (Nf, K)</span>
    <span class=n>spectra</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>squeeze</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>real</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>conj</span><span class=p>(</span><span class=n>J</span><span class=p>)</span> <span class=o>*</span> <span class=n>J</span><span class=p>),</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>))</span>  <span class=c1># Mean across tapers</span>

    <span class=k>return</span> <span class=n>spectra</span><span class=p>,</span> <span class=n>f</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.randomize_epochs class="doc doc-heading"> <code class="highlight language-python"><span class=n>randomize_epochs</span><span class=p>(</span><span class=n>epoch</span><span class=p>,</span> <span class=n>randomize_each</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>start_stop</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Randomly shifts the epochs of a EpochArray object and wraps them around the original time boundaries.</p> <p>This method takes a EpochArray object as input, and can either randomly shift each epoch by a different amount (if <code>randomize_each</code> is True) or shift all the epochs by the same amount (if <code>randomize_each</code> is False). In either case, the method wraps the shifted epochs around the original time boundaries to make sure they remain within the original time range. It then returns the modified EpochArray object.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>epoch</code> </td> <td> <code><span title=nelpy.core.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>The EpochArray object whose epochs should be shifted and wrapped.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>randomize_each</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, each epoch will be shifted by a different random amount. If False, all the epochs will be shifted by the same random amount. Defaults to True.</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>start_stop</code> </td> <td> <code><span title=array>array</span></code> </td> <td> <div class=doc-md-description> <p>If not None, time support will be taken from start_stop</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>new_epochs</code></td> <td> <code><span title=nelpy.core.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>The modified EpochArray object with the shifted and wrapped epochs.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span>
<span class=normal>72</span>
<span class=normal>73</span>
<span class=normal>74</span>
<span class=normal>75</span>
<span class=normal>76</span>
<span class=normal>77</span>
<span class=normal>78</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>randomize_epochs</span><span class=p>(</span>
    <span class=n>epoch</span><span class=p>:</span> <span class=n>EpochArray</span><span class=p>,</span>
    <span class=n>randomize_each</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
    <span class=n>start_stop</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>EpochArray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Randomly shifts the epochs of a EpochArray object and wraps them around the original time boundaries.</span>

<span class=sd>    This method takes a EpochArray object as input, and can either randomly shift each epoch by a different amount</span>
<span class=sd>    (if `randomize_each` is True) or shift all the epochs by the same amount (if `randomize_each` is False).</span>
<span class=sd>    In either case, the method wraps the shifted epochs around the original time boundaries to make sure they remain</span>
<span class=sd>    within the original time range. It then returns the modified EpochArray object.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    epoch : EpochArray</span>
<span class=sd>        The EpochArray object whose epochs should be shifted and wrapped.</span>
<span class=sd>    randomize_each : bool, optional</span>
<span class=sd>        If True, each epoch will be shifted by a different random amount.</span>
<span class=sd>        If False, all the epochs will be shifted by the same random amount. Defaults to True.</span>
<span class=sd>    start_stop : array, optional</span>
<span class=sd>        If not None, time support will be taken from start_stop</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    new_epochs : EpochArray</span>
<span class=sd>        The modified EpochArray object with the shifted and wrapped epochs.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>def</span><span class=w> </span><span class=nf>wrap_intervals</span><span class=p>(</span><span class=n>intervals</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=p>):</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>intervals</span> <span class=o>&gt;</span> <span class=n>stop</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>intervals</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>intervals</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>-</span> <span class=n>stop</span> <span class=o>+</span> <span class=n>start</span>

        <span class=n>idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>intervals</span> <span class=o>&lt;</span> <span class=n>start</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>intervals</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>intervals</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>-</span> <span class=n>start</span> <span class=o>+</span> <span class=n>stop</span>
        <span class=k>return</span> <span class=n>intervals</span>

    <span class=n>new_epochs</span> <span class=o>=</span> <span class=n>epoch</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>

    <span class=k>if</span> <span class=n>start_stop</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>start</span> <span class=o>=</span> <span class=n>new_epochs</span><span class=o>.</span><span class=n>start</span>
        <span class=n>stop</span> <span class=o>=</span> <span class=n>new_epochs</span><span class=o>.</span><span class=n>stop</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=o>=</span> <span class=n>start_stop</span>

    <span class=n>ts_range</span> <span class=o>=</span> <span class=n>stop</span> <span class=o>-</span> <span class=n>start</span>

    <span class=k>if</span> <span class=n>randomize_each</span><span class=p>:</span>
        <span class=c1># Randomly shift each epoch by a different amount</span>
        <span class=n>random_order</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span>
            <span class=nb>range</span><span class=p>(</span><span class=o>-</span><span class=nb>int</span><span class=p>(</span><span class=n>ts_range</span><span class=p>),</span> <span class=nb>int</span><span class=p>(</span><span class=n>ts_range</span><span class=p>)),</span> <span class=n>new_epochs</span><span class=o>.</span><span class=n>n_intervals</span>
        <span class=p>)</span>

        <span class=n>new_intervals</span> <span class=o>=</span> <span class=n>new_epochs</span><span class=o>.</span><span class=n>data</span> <span class=o>+</span> <span class=n>np</span><span class=o>.</span><span class=n>expand_dims</span><span class=p>(</span><span class=n>random_order</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>new_epochs</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>wrap_intervals</span><span class=p>(</span><span class=n>new_intervals</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=c1># Shift all the epochs by the same amount</span>
        <span class=n>random_shift</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=o>-</span><span class=nb>int</span><span class=p>(</span><span class=n>ts_range</span><span class=p>),</span> <span class=nb>int</span><span class=p>(</span><span class=n>ts_range</span><span class=p>))</span>
        <span class=n>new_epochs</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>wrap_intervals</span><span class=p>((</span><span class=n>new_epochs</span><span class=o>.</span><span class=n>data</span> <span class=o>+</span> <span class=n>random_shift</span><span class=p>),</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>new_epochs</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>new_epochs</span><span class=o>.</span><span class=n>data</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>new_epochs</span><span class=o>.</span><span class=n>data</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>):</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;start must be less than or equal to stop&quot;</span><span class=p>)</span>

    <span class=n>new_epochs</span><span class=o>.</span><span class=n>_sort</span><span class=p>()</span>

    <span class=k>return</span> <span class=n>new_epochs</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.relative_times class="doc doc-heading"> <code class="highlight language-python"><span class=n>relative_times</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>intervals</span><span class=p>,</span> <span class=n>values</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]))</span></code> </h2> <div class="doc doc-contents "> <p>Calculate relative times and interval IDs for a set of time points.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>t</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time points.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>intervals</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of time intervals, represented as pairs of start and end times.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>values</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of values to assign to interval bounds. The default is [0,1].</p> </div> </td> <td> <code><span title=numpy.array>array</span>([0, 1])</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>rt</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of relative times, one for each time point (same len as t).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>intervalID</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>An array of interval IDs, one for each time point (same len as t).</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>t</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span> <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>9</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>relative_times</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>intervals</span><span class=p>)</span>
<span class=go>    (array([nan, 0. , 0.5, 1. , 0. , 0.5, 1. , 0. , 0.5, 1. ]),</span>
<span class=go>    array([nan,  0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.]))</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>t</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span> <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>9</span><span class=p>]])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>values</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=o>*</span><span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>relative_times</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>intervals</span><span class=p>,</span> <span class=n>values</span><span class=p>)</span>
<span class=go>    (array([       nan, 0.        , 3.14159265, 6.28318531, 0.        ,</span>
<span class=go>            3.14159265, 6.28318531, 0.        , 3.14159265, 6.28318531]),</span>
<span class=go>    array([nan,  0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.]))</span>
</code></pre></div> <details class=note open> <summary>Notes</summary> <p>Intervals are defined as pairs of start and end times. The relative time is the time within the interval, normalized to the interval duration. The interval ID is the index of the interval in the intervals array. The values array can be used to assign a value to each interval.</p> <p>By Ryan H, based on RelativeTimes.m by Ralitsa Todorova</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/peri_event.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1050</span>
<span class=normal>1051</span>
<span class=normal>1052</span>
<span class=normal>1053</span>
<span class=normal>1054</span>
<span class=normal>1055</span>
<span class=normal>1056</span>
<span class=normal>1057</span>
<span class=normal>1058</span>
<span class=normal>1059</span>
<span class=normal>1060</span>
<span class=normal>1061</span>
<span class=normal>1062</span>
<span class=normal>1063</span>
<span class=normal>1064</span>
<span class=normal>1065</span>
<span class=normal>1066</span>
<span class=normal>1067</span>
<span class=normal>1068</span>
<span class=normal>1069</span>
<span class=normal>1070</span>
<span class=normal>1071</span>
<span class=normal>1072</span>
<span class=normal>1073</span>
<span class=normal>1074</span>
<span class=normal>1075</span>
<span class=normal>1076</span>
<span class=normal>1077</span>
<span class=normal>1078</span>
<span class=normal>1079</span>
<span class=normal>1080</span>
<span class=normal>1081</span>
<span class=normal>1082</span>
<span class=normal>1083</span>
<span class=normal>1084</span>
<span class=normal>1085</span>
<span class=normal>1086</span>
<span class=normal>1087</span>
<span class=normal>1088</span>
<span class=normal>1089</span>
<span class=normal>1090</span>
<span class=normal>1091</span>
<span class=normal>1092</span>
<span class=normal>1093</span>
<span class=normal>1094</span>
<span class=normal>1095</span>
<span class=normal>1096</span>
<span class=normal>1097</span>
<span class=normal>1098</span>
<span class=normal>1099</span>
<span class=normal>1100</span>
<span class=normal>1101</span>
<span class=normal>1102</span>
<span class=normal>1103</span>
<span class=normal>1104</span>
<span class=normal>1105</span>
<span class=normal>1106</span>
<span class=normal>1107</span>
<span class=normal>1108</span>
<span class=normal>1109</span>
<span class=normal>1110</span>
<span class=normal>1111</span>
<span class=normal>1112</span>
<span class=normal>1113</span>
<span class=normal>1114</span>
<span class=normal>1115</span>
<span class=normal>1116</span>
<span class=normal>1117</span>
<span class=normal>1118</span>
<span class=normal>1119</span>
<span class=normal>1120</span>
<span class=normal>1121</span>
<span class=normal>1122</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@jit</span><span class=p>(</span><span class=n>nopython</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>relative_times</span><span class=p>(</span>
    <span class=n>t</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>intervals</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>values</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Calculate relative times and interval IDs for a set of time points.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    t : np.ndarray</span>
<span class=sd>        An array of time points.</span>
<span class=sd>    intervals : np.ndarray</span>
<span class=sd>        An array of time intervals, represented as pairs of start and end times.</span>
<span class=sd>    values : np.ndarray, optional</span>
<span class=sd>        An array of values to assign to interval bounds. The default is [0,1].</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    rt : np.ndarray</span>
<span class=sd>        An array of relative times, one for each time point (same len as t).</span>
<span class=sd>    intervalID : np.ndarray</span>
<span class=sd>        An array of interval IDs, one for each time point (same len as t).</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; t = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class=sd>    &gt;&gt;&gt; intervals = np.array([[1, 3], [4, 6], [7, 9]])</span>
<span class=sd>    &gt;&gt;&gt; relative_times(t, intervals)</span>
<span class=sd>        (array([nan, 0. , 0.5, 1. , 0. , 0.5, 1. , 0. , 0.5, 1. ]),</span>
<span class=sd>        array([nan,  0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.]))</span>

<span class=sd>    &gt;&gt;&gt; t = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class=sd>    &gt;&gt;&gt; intervals = np.array([[1, 3], [4, 6], [7, 9]])</span>
<span class=sd>    &gt;&gt;&gt; values = np.array([0, 2*np.pi])</span>
<span class=sd>    &gt;&gt;&gt; relative_times(t, intervals, values)</span>
<span class=sd>        (array([       nan, 0.        , 3.14159265, 6.28318531, 0.        ,</span>
<span class=sd>                3.14159265, 6.28318531, 0.        , 3.14159265, 6.28318531]),</span>
<span class=sd>        array([nan,  0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.]))</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Intervals are defined as pairs of start and end times. The relative time is the time</span>
<span class=sd>    within the interval, normalized to the interval duration. The interval ID is the index</span>
<span class=sd>    of the interval in the intervals array. The values array can be used to assign a value</span>
<span class=sd>    to each interval.</span>

<span class=sd>    By Ryan H, based on RelativeTimes.m by Ralitsa Todorova</span>

<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>rt</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
    <span class=n>intervalID</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float64</span><span class=p>)</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>

    <span class=n>start_times</span> <span class=o>=</span> <span class=n>intervals</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span>
    <span class=n>end_times</span> <span class=o>=</span> <span class=n>intervals</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>]</span>
    <span class=n>values_diff</span> <span class=o>=</span> <span class=n>values</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>values</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>intervals_diff</span> <span class=o>=</span> <span class=n>end_times</span> <span class=o>-</span> <span class=n>start_times</span>
    <span class=n>intervals_scale</span> <span class=o>=</span> <span class=n>values_diff</span> <span class=o>/</span> <span class=n>intervals_diff</span>

    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>)):</span>
        <span class=n>idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>start_times</span><span class=p>,</span> <span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
        <span class=k>if</span> <span class=n>idx</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>end_times</span><span class=p>[</span><span class=n>idx</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]:</span>
            <span class=n>interval_i</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>-</span> <span class=mi>1</span>
        <span class=k>elif</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>start_times</span><span class=p>)</span> <span class=ow>and</span> <span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>start_times</span><span class=p>[</span><span class=n>idx</span><span class=p>]:</span>
            <span class=n>interval_i</span> <span class=o>=</span> <span class=n>idx</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>continue</span>

        <span class=n>scale</span> <span class=o>=</span> <span class=n>intervals_scale</span><span class=p>[</span><span class=n>interval_i</span><span class=p>]</span>
        <span class=n>rt</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>((</span><span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>start_times</span><span class=p>[</span><span class=n>interval_i</span><span class=p>])</span> <span class=o>*</span> <span class=n>scale</span><span class=p>)</span> <span class=o>+</span> <span class=n>values</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=n>intervalID</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>interval_i</span>

    <span class=k>return</span> <span class=n>rt</span><span class=p>,</span> <span class=n>intervalID</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.remove_inactive_cells class="doc doc-heading"> <code class="highlight language-python"><span class=n>remove_inactive_cells</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>epochs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>min_spikes</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>remove_inactive_cells: Remove cells with fewer than min_spikes spikes per sub-epoch</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>st</code> </td> <td> <code><span title=SpikeTrainArray>SpikeTrainArray</span></code> </td> <td> <div class=doc-md-description> <p>SpikeTrainArray object containing spike times for multiple cells.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>cell_metrics</code> </td> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>DataFrame containing metrics for each cell (e.g., quality metrics).</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>epochs</code> </td> <td> <code>EpochArray or list of EpochArray</code> </td> <td> <div class=doc-md-description> <p>If a list of EpochArray objects is provided, each EpochArray object is treated as a sub-epoch. If a single EpochArray object is provided, each interval in the EpochArray object is treated as a sub-epoch.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>min_spikes</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Minimum number of spikes required per sub-epoch to retain a cell. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Tuple>Tuple</span>[<span title=SpikeTrainArray>SpikeTrainArray</span>, <span title=typing.Union>Union</span>[<span title=pandas.DataFrame>DataFrame</span>, None]]</code> </td> <td> <div class=doc-md-description> <p>A tuple containing: - SpikeTrainArray object with inactive cells removed. - DataFrame containing cell metrics with inactive cells removed (if provided).</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.process.intervals</span><span class=w> </span><span class=kn>import</span> <span class=n>truncate_epoch</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.session.locate_epochs</span><span class=w> </span><span class=kn>import</span> <span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>find_multitask_pre_post</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>compress_repeated_epochs</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.io</span><span class=w> </span><span class=kn>import</span> <span class=n>loading</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span><span class=w> </span><span class=nn>nelpy</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>nel</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.process.utils</span><span class=w> </span><span class=kn>import</span> <span class=n>remove_inactive_cells</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load data from session</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>basepath</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;Z:\Data\hpc_ctx_project\HP04\day_1_20240320&quot;</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load spikes and cell metrics (cm)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>cm</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>brainRegion</span><span class=o>=</span><span class=s2>&quot;CA1&quot;</span><span class=p>,</span> <span class=n>putativeCellType</span><span class=o>=</span><span class=s2>&quot;Pyr&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load epochs and apply multitask epoch restrictions</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>epoch_df</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_epoch</span><span class=p>(</span><span class=n>basepath</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>epoch_df</span> <span class=o>=</span> <span class=n>compress_repeated_epochs</span><span class=p>(</span><span class=n>epoch_df</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>pre_task_post</span> <span class=o>=</span> <span class=n>find_multitask_pre_post</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>epoch_df</span><span class=o>.</span><span class=n>environment</span><span class=p>,</span> <span class=n>post_sleep_flank</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>pre_sleep_common</span><span class=o>=</span><span class=kc>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>beh_epochs</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>epoch_df</span><span class=o>.</span><span class=n>iloc</span><span class=p>[</span><span class=n>pre_task_post</span><span class=p>[</span><span class=mi>0</span><span class=p>]][[</span><span class=s2>&quot;startTime&quot;</span><span class=p>,</span> <span class=s2>&quot;stopTime&quot;</span><span class=p>]]</span><span class=o>.</span><span class=n>values</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># load sleep states to restrict to NREM and theta</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>state_dict</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_SleepState_states</span><span class=p>(</span><span class=n>basepath</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>nrem_epochs</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>state_dict</span><span class=p>[</span><span class=s2>&quot;NREMstate&quot;</span><span class=p>],</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>theta_epochs</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>state_dict</span><span class=p>[</span><span class=s2>&quot;THETA&quot;</span><span class=p>],</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># create list of restricted epochs</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>restict_epochs</span> <span class=o>=</span> <span class=p>[]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>for</span> <span class=n>epoch</span><span class=p>,</span> <span class=n>epoch_label</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>beh_epochs</span><span class=p>,</span> <span class=p>[</span><span class=s2>&quot;pre&quot;</span><span class=p>,</span> <span class=s2>&quot;task&quot;</span><span class=p>,</span> <span class=s2>&quot;post&quot;</span><span class=p>]):</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=k>if</span> <span class=n>epoch_label</span> <span class=ow>in</span> <span class=s2>&quot;pre&quot;</span><span class=p>:</span>
<span class=gp>&gt;&gt;&gt; </span>        <span class=c1># get cumulative hours of sleep</span>
<span class=gp>&gt;&gt;&gt; </span>        <span class=n>epoch_restrict</span> <span class=o>=</span> <span class=n>truncate_epoch</span><span class=p>(</span><span class=n>epoch</span> <span class=o>&amp;</span> <span class=n>nrem_epochs</span><span class=p>,</span> <span class=n>time</span><span class=o>=</span><span class=mi>3600</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=k>elif</span> <span class=n>epoch_label</span> <span class=ow>in</span> <span class=s2>&quot;post&quot;</span><span class=p>:</span>
<span class=gp>&gt;&gt;&gt; </span>        <span class=c1># get cumulative hours of sleep</span>
<span class=gp>&gt;&gt;&gt; </span>        <span class=n>epoch_restrict</span> <span class=o>=</span> <span class=n>truncate_epoch</span><span class=p>(</span><span class=n>epoch</span> <span class=o>&amp;</span> <span class=n>nrem_epochs</span><span class=p>,</span> <span class=n>time</span><span class=o>=</span><span class=mi>3600</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=k>else</span><span class=p>:</span>
<span class=gp>&gt;&gt;&gt; </span>        <span class=c1># get theta during task</span>
<span class=gp>&gt;&gt;&gt; </span>        <span class=n>epoch_restrict</span> <span class=o>=</span> <span class=n>epoch</span> <span class=o>&amp;</span> <span class=n>theta_epochs</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>restict_epochs</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>epoch_restrict</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># remove inactive cells</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>cm</span> <span class=o>=</span> <span class=n>remove_inactive_cells</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cm</span><span class=p>,</span> <span class=n>restict_epochs</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>124</span>
<span class=normal>125</span>
<span class=normal>126</span>
<span class=normal>127</span>
<span class=normal>128</span>
<span class=normal>129</span>
<span class=normal>130</span>
<span class=normal>131</span>
<span class=normal>132</span>
<span class=normal>133</span>
<span class=normal>134</span>
<span class=normal>135</span>
<span class=normal>136</span>
<span class=normal>137</span>
<span class=normal>138</span>
<span class=normal>139</span>
<span class=normal>140</span>
<span class=normal>141</span>
<span class=normal>142</span>
<span class=normal>143</span>
<span class=normal>144</span>
<span class=normal>145</span>
<span class=normal>146</span>
<span class=normal>147</span>
<span class=normal>148</span>
<span class=normal>149</span>
<span class=normal>150</span>
<span class=normal>151</span>
<span class=normal>152</span>
<span class=normal>153</span>
<span class=normal>154</span>
<span class=normal>155</span>
<span class=normal>156</span>
<span class=normal>157</span>
<span class=normal>158</span>
<span class=normal>159</span>
<span class=normal>160</span>
<span class=normal>161</span>
<span class=normal>162</span>
<span class=normal>163</span>
<span class=normal>164</span>
<span class=normal>165</span>
<span class=normal>166</span>
<span class=normal>167</span>
<span class=normal>168</span>
<span class=normal>169</span>
<span class=normal>170</span>
<span class=normal>171</span>
<span class=normal>172</span>
<span class=normal>173</span>
<span class=normal>174</span>
<span class=normal>175</span>
<span class=normal>176</span>
<span class=normal>177</span>
<span class=normal>178</span>
<span class=normal>179</span>
<span class=normal>180</span>
<span class=normal>181</span>
<span class=normal>182</span>
<span class=normal>183</span>
<span class=normal>184</span>
<span class=normal>185</span>
<span class=normal>186</span>
<span class=normal>187</span>
<span class=normal>188</span>
<span class=normal>189</span>
<span class=normal>190</span>
<span class=normal>191</span>
<span class=normal>192</span>
<span class=normal>193</span>
<span class=normal>194</span>
<span class=normal>195</span>
<span class=normal>196</span>
<span class=normal>197</span>
<span class=normal>198</span>
<span class=normal>199</span>
<span class=normal>200</span>
<span class=normal>201</span>
<span class=normal>202</span>
<span class=normal>203</span>
<span class=normal>204</span>
<span class=normal>205</span>
<span class=normal>206</span>
<span class=normal>207</span>
<span class=normal>208</span>
<span class=normal>209</span>
<span class=normal>210</span>
<span class=normal>211</span>
<span class=normal>212</span>
<span class=normal>213</span>
<span class=normal>214</span>
<span class=normal>215</span>
<span class=normal>216</span>
<span class=normal>217</span>
<span class=normal>218</span>
<span class=normal>219</span>
<span class=normal>220</span>
<span class=normal>221</span>
<span class=normal>222</span>
<span class=normal>223</span>
<span class=normal>224</span>
<span class=normal>225</span>
<span class=normal>226</span>
<span class=normal>227</span>
<span class=normal>228</span>
<span class=normal>229</span>
<span class=normal>230</span>
<span class=normal>231</span>
<span class=normal>232</span>
<span class=normal>233</span>
<span class=normal>234</span>
<span class=normal>235</span>
<span class=normal>236</span>
<span class=normal>237</span>
<span class=normal>238</span>
<span class=normal>239</span>
<span class=normal>240</span>
<span class=normal>241</span>
<span class=normal>242</span>
<span class=normal>243</span>
<span class=normal>244</span>
<span class=normal>245</span>
<span class=normal>246</span>
<span class=normal>247</span>
<span class=normal>248</span>
<span class=normal>249</span>
<span class=normal>250</span>
<span class=normal>251</span>
<span class=normal>252</span>
<span class=normal>253</span>
<span class=normal>254</span>
<span class=normal>255</span>
<span class=normal>256</span>
<span class=normal>257</span>
<span class=normal>258</span>
<span class=normal>259</span>
<span class=normal>260</span>
<span class=normal>261</span>
<span class=normal>262</span>
<span class=normal>263</span>
<span class=normal>264</span>
<span class=normal>265</span>
<span class=normal>266</span>
<span class=normal>267</span>
<span class=normal>268</span>
<span class=normal>269</span>
<span class=normal>270</span>
<span class=normal>271</span>
<span class=normal>272</span>
<span class=normal>273</span>
<span class=normal>274</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>remove_inactive_cells</span><span class=p>(</span>
    <span class=n>st</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_eventarray</span><span class=o>.</span><span class=n>SpikeTrainArray</span><span class=p>,</span>
    <span class=n>cell_metrics</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>epochs</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span>
        <span class=n>List</span><span class=p>[</span><span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>],</span>
        <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span>
        <span class=kc>None</span><span class=p>,</span>
    <span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>min_spikes</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_eventarray</span><span class=o>.</span><span class=n>SpikeTrainArray</span><span class=p>,</span> <span class=n>Union</span><span class=p>[</span><span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>,</span> <span class=kc>None</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    remove_inactive_cells: Remove cells with fewer than min_spikes spikes per sub-epoch</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    st : SpikeTrainArray</span>
<span class=sd>        SpikeTrainArray object containing spike times for multiple cells.</span>

<span class=sd>    cell_metrics : pd.DataFrame, optional</span>
<span class=sd>        DataFrame containing metrics for each cell (e.g., quality metrics).</span>

<span class=sd>    epochs : EpochArray or list of EpochArray, optional</span>
<span class=sd>        If a list of EpochArray objects is provided, each EpochArray object</span>
<span class=sd>        is treated as a sub-epoch. If a single EpochArray object is provided,</span>
<span class=sd>        each interval in the EpochArray object is treated as a sub-epoch.</span>

<span class=sd>    min_spikes : int, optional</span>
<span class=sd>        Minimum number of spikes required per sub-epoch to retain a cell.</span>
<span class=sd>        Default is 100.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Tuple[SpikeTrainArray, Union[pd.DataFrame, None]]</span>
<span class=sd>        A tuple containing:</span>
<span class=sd>        - SpikeTrainArray object with inactive cells removed.</span>
<span class=sd>        - DataFrame containing cell metrics with inactive cells removed (if provided).</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.process.intervals import truncate_epoch</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.session.locate_epochs import (</span>
<span class=sd>    &gt;&gt;&gt;     find_multitask_pre_post,</span>
<span class=sd>    &gt;&gt;&gt;     compress_repeated_epochs,</span>
<span class=sd>    &gt;&gt;&gt; )</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.io import loading</span>
<span class=sd>    &gt;&gt;&gt; import nelpy as nel</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.process.utils import remove_inactive_cells</span>

<span class=sd>    &gt;&gt;&gt; # load data from session</span>
<span class=sd>    &gt;&gt;&gt; basepath = r&quot;Z:\Data\hpc_ctx_project\HP04\day_1_20240320&quot;</span>

<span class=sd>    &gt;&gt;&gt; # load spikes and cell metrics (cm)</span>
<span class=sd>    &gt;&gt;&gt; st, cm = loading.load_spikes(basepath, brainRegion=&quot;CA1&quot;, putativeCellType=&quot;Pyr&quot;)</span>

<span class=sd>    &gt;&gt;&gt; # load epochs and apply multitask epoch restrictions</span>
<span class=sd>    &gt;&gt;&gt; epoch_df = loading.load_epoch(basepath)</span>
<span class=sd>    &gt;&gt;&gt; epoch_df = compress_repeated_epochs(epoch_df)</span>
<span class=sd>    &gt;&gt;&gt; pre_task_post = find_multitask_pre_post(</span>
<span class=sd>    &gt;&gt;&gt;     epoch_df.environment, post_sleep_flank=True, pre_sleep_common=True</span>
<span class=sd>    &gt;&gt;&gt; )</span>

<span class=sd>    &gt;&gt;&gt; beh_epochs = nel.EpochArray(</span>
<span class=sd>    &gt;&gt;&gt;     epoch_df.iloc[pre_task_post[0]][[&quot;startTime&quot;, &quot;stopTime&quot;]].values</span>
<span class=sd>    &gt;&gt;&gt; )</span>
<span class=sd>    &gt;&gt;&gt; # load sleep states to restrict to NREM and theta</span>
<span class=sd>    &gt;&gt;&gt; state_dict = loading.load_SleepState_states(basepath)</span>
<span class=sd>    &gt;&gt;&gt; nrem_epochs = nel.EpochArray(</span>
<span class=sd>    &gt;&gt;&gt;     state_dict[&quot;NREMstate&quot;],</span>
<span class=sd>    &gt;&gt;&gt; )</span>
<span class=sd>    &gt;&gt;&gt; theta_epochs = nel.EpochArray(</span>
<span class=sd>    &gt;&gt;&gt;     state_dict[&quot;THETA&quot;],</span>
<span class=sd>    &gt;&gt;&gt; )</span>
<span class=sd>    &gt;&gt;&gt; # create list of restricted epochs</span>
<span class=sd>    &gt;&gt;&gt; restict_epochs = []</span>
<span class=sd>    &gt;&gt;&gt; for epoch, epoch_label in zip(beh_epochs, [&quot;pre&quot;, &quot;task&quot;, &quot;post&quot;]):</span>
<span class=sd>    &gt;&gt;&gt;     if epoch_label in &quot;pre&quot;:</span>
<span class=sd>    &gt;&gt;&gt;         # get cumulative hours of sleep</span>
<span class=sd>    &gt;&gt;&gt;         epoch_restrict = truncate_epoch(epoch &amp; nrem_epochs, time=3600)</span>
<span class=sd>    &gt;&gt;&gt;     elif epoch_label in &quot;post&quot;:</span>
<span class=sd>    &gt;&gt;&gt;         # get cumulative hours of sleep</span>
<span class=sd>    &gt;&gt;&gt;         epoch_restrict = truncate_epoch(epoch &amp; nrem_epochs, time=3600)</span>
<span class=sd>    &gt;&gt;&gt;     else:</span>
<span class=sd>    &gt;&gt;&gt;         # get theta during task</span>
<span class=sd>    &gt;&gt;&gt;         epoch_restrict = epoch &amp; theta_epochs</span>
<span class=sd>    &gt;&gt;&gt;     restict_epochs.append(epoch_restrict)</span>

<span class=sd>    &gt;&gt;&gt; # remove inactive cells</span>
<span class=sd>    &gt;&gt;&gt; st, cm = remove_inactive_cells(st, cm, restict_epochs)</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>def</span><span class=w> </span><span class=nf>return_results</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>cell_metrics</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>st</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span>

    <span class=c1># check data types</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_eventarray</span><span class=o>.</span><span class=n>SpikeTrainArray</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;st must be a SpikeTrainArray object&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>cell_metrics</span><span class=p>,</span> <span class=p>(</span><span class=n>pd</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>frame</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>,</span> <span class=nb>type</span><span class=p>(</span><span class=kc>None</span><span class=p>))):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;cell_metrics must be a DataFrame object&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=p>(</span><span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span> <span class=nb>list</span><span class=p>)):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;epochs must be an EpochArray object or a list of EpochArray objects&quot;</span>
        <span class=p>)</span>

    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=nb>list</span><span class=p>):</span>
        <span class=k>for</span> <span class=n>epoch</span> <span class=ow>in</span> <span class=n>epochs</span><span class=p>:</span>
            <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>epoch</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>):</span>
                <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;list of epochs must contain EpochArray objects&quot;</span><span class=p>)</span>

    <span class=c1># check if st is empty</span>
    <span class=k>if</span> <span class=n>st</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>return_results</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=p>)</span>

    <span class=c1># check if epochs is empty</span>
    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>epochs</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>return_results</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=p>)</span>

    <span class=c1># check if cell_metrics is empty</span>
    <span class=k>if</span> <span class=n>cell_metrics</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>cell_metrics</span><span class=o>.</span><span class=n>empty</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>return_results</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=p>)</span>

    <span class=c1># check if min_spikes is less than 1</span>
    <span class=k>if</span> <span class=n>min_spikes</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>return_results</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=p>)</span>

    <span class=c1># check if st and cell_metrics have the same number of units</span>
    <span class=k>if</span> <span class=n>cell_metrics</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>st</span><span class=o>.</span><span class=n>n_units</span> <span class=o>!=</span> <span class=n>cell_metrics</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
        <span class=c1># assert error message</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;st and cell_metrics must have the same number of units&quot;</span><span class=p>)</span>

    <span class=n>spk_thres_met</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=c1># check if each cell has at least min_spikes spikes in each epoch</span>
    <span class=k>for</span> <span class=n>epoch_restrict</span> <span class=ow>in</span> <span class=n>epochs</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>st</span><span class=p>[</span><span class=n>epoch_restrict</span><span class=p>]</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=n>spk_thres_met</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=n>st</span><span class=o>.</span><span class=n>n_units</span><span class=p>)</span>
            <span class=k>continue</span>
        <span class=n>spk_thres_met</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>st</span><span class=p>[</span><span class=n>epoch_restrict</span><span class=p>]</span><span class=o>.</span><span class=n>n_events</span> <span class=o>&gt;=</span> <span class=n>min_spikes</span><span class=p>)</span>

    <span class=n>good_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>(</span><span class=n>spk_thres_met</span><span class=p>)</span><span class=o>.</span><span class=n>all</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

    <span class=c1># remove inactive cells</span>
    <span class=n>st</span> <span class=o>=</span> <span class=n>st</span><span class=o>.</span><span class=n>iloc</span><span class=p>[:,</span> <span class=n>good_idx</span><span class=p>]</span>
    <span class=k>if</span> <span class=n>cell_metrics</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>cell_metrics</span> <span class=o>=</span> <span class=n>cell_metrics</span><span class=p>[</span><span class=n>good_idx</span><span class=p>]</span>

    <span class=k>return</span> <span class=n>return_results</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.remove_inactive_cells_pre_task_post class="doc doc-heading"> <code class="highlight language-python"><span class=n>remove_inactive_cells_pre_task_post</span><span class=p>(</span><span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>beh_epochs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>nrem_epochs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>theta_epochs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>min_spikes</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> <span class=n>nrem_time</span><span class=o>=</span><span class=mi>3600</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>remove_inactive_cells_pre_task_post: Remove cells with fewer than min_spikes spikes per pre/task/post</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>st</code> </td> <td> <code><span title=SpikeTrainArray>SpikeTrainArray</span></code> </td> <td> <div class=doc-md-description> <p>SpikeTrainArray object containing spike times for multiple cells.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>cell_metrics</code> </td> <td> <code><span title=pandas.DataFrame>DataFrame</span></code> </td> <td> <div class=doc-md-description> <p>DataFrame containing metrics for each cell (e.g., quality metrics).</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>beh_epochs</code> </td> <td> <code><span title=EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>EpochArray object containing pre/task/post epochs.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>nrem_epochs</code> </td> <td> <code><span title=EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>EpochArray object containing NREM epochs.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>theta_epochs</code> </td> <td> <code><span title=EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>EpochArray object containing theta epochs.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>min_spikes</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Minimum number of spikes required per pre/task/post. Default is 100.</p> </div> </td> <td> <code>100</code> </td> </tr> <tr class=doc-section-item> <td> <code>nrem_time</code> </td> <td> <code><span title=int>int</span> or <span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Time in seconds to truncate NREM epochs. Default is 3600 seconds.</p> </div> </td> <td> <code>3600</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=typing.Tuple>Tuple</span>[<span title=nelpy.core._eventarray.SpikeTrainArray>SpikeTrainArray</span>, <span title=typing.Union>Union</span>[<span title=pandas.DataFrame>DataFrame</span>, None]]</code> </td> <td> <div class=doc-md-description> <p>A tuple containing: - SpikeTrainArray object with inactive cells removed. - DataFrame containing cell metrics with inactive cells removed (if provided).</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.process.utils</span><span class=w> </span><span class=kn>import</span> <span class=n>remove_inactive_cells_pre_task_post</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.io</span><span class=w> </span><span class=kn>import</span> <span class=n>loading</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>neuro_py.session.locate_epochs</span><span class=w> </span><span class=kn>import</span> <span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>find_multitask_pre_post</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>compress_repeated_epochs</span><span class=p>,</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mport</span> <span class=n>nelpy</span> <span class=k>as</span> <span class=n>nel</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load data from session</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>basepath</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&quot;Z:\Data\hpc_ctx_project\HP04\day_1_20240320&quot;</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load spikes and cell metrics (cm)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span> <span class=n>cm</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_spikes</span><span class=p>(</span><span class=n>basepath</span><span class=p>,</span> <span class=n>brainRegion</span><span class=o>=</span><span class=s2>&quot;CA1&quot;</span><span class=p>,</span> <span class=n>putativeCellType</span><span class=o>=</span><span class=s2>&quot;Pyr&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load epochs and apply multitask epoch restrictions</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>epoch_df</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_epoch</span><span class=p>(</span><span class=n>basepath</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>epoch_df</span> <span class=o>=</span> <span class=n>compress_repeated_epochs</span><span class=p>(</span><span class=n>epoch_df</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>pre_task_post</span> <span class=o>=</span> <span class=n>find_multitask_pre_post</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>epoch_df</span><span class=o>.</span><span class=n>environment</span><span class=p>,</span> <span class=n>post_sleep_flank</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>pre_sleep_common</span><span class=o>=</span><span class=kc>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>beh_epochs</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>epoch_df</span><span class=o>.</span><span class=n>iloc</span><span class=p>[</span><span class=n>pre_task_post</span><span class=p>[</span><span class=mi>0</span><span class=p>]][[</span><span class=s2>&quot;startTime&quot;</span><span class=p>,</span> <span class=s2>&quot;stopTime&quot;</span><span class=p>]]</span><span class=o>.</span><span class=n>values</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># load sleep states to restrict to NREM and theta</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>state_dict</span> <span class=o>=</span> <span class=n>loading</span><span class=o>.</span><span class=n>load_SleepState_states</span><span class=p>(</span><span class=n>basepath</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>nrem_epochs</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>state_dict</span><span class=p>[</span><span class=s2>&quot;NREMstate&quot;</span><span class=p>],</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>theta_epochs</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span>
<span class=gp>&gt;&gt;&gt; </span>    <span class=n>state_dict</span><span class=p>[</span><span class=s2>&quot;THETA&quot;</span><span class=p>],</span>
<span class=gp>&gt;&gt;&gt; </span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>st</span><span class=p>,</span><span class=n>cm</span> <span class=o>=</span> <span class=n>remove_inactive_cells_pre_task_post</span><span class=p>(</span><span class=n>st</span><span class=p>,</span><span class=n>cm</span><span class=p>,</span><span class=n>beh_epochs</span><span class=p>,</span><span class=n>nrem_epochs</span><span class=p>,</span><span class=n>theta_epochs</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>277</span>
<span class=normal>278</span>
<span class=normal>279</span>
<span class=normal>280</span>
<span class=normal>281</span>
<span class=normal>282</span>
<span class=normal>283</span>
<span class=normal>284</span>
<span class=normal>285</span>
<span class=normal>286</span>
<span class=normal>287</span>
<span class=normal>288</span>
<span class=normal>289</span>
<span class=normal>290</span>
<span class=normal>291</span>
<span class=normal>292</span>
<span class=normal>293</span>
<span class=normal>294</span>
<span class=normal>295</span>
<span class=normal>296</span>
<span class=normal>297</span>
<span class=normal>298</span>
<span class=normal>299</span>
<span class=normal>300</span>
<span class=normal>301</span>
<span class=normal>302</span>
<span class=normal>303</span>
<span class=normal>304</span>
<span class=normal>305</span>
<span class=normal>306</span>
<span class=normal>307</span>
<span class=normal>308</span>
<span class=normal>309</span>
<span class=normal>310</span>
<span class=normal>311</span>
<span class=normal>312</span>
<span class=normal>313</span>
<span class=normal>314</span>
<span class=normal>315</span>
<span class=normal>316</span>
<span class=normal>317</span>
<span class=normal>318</span>
<span class=normal>319</span>
<span class=normal>320</span>
<span class=normal>321</span>
<span class=normal>322</span>
<span class=normal>323</span>
<span class=normal>324</span>
<span class=normal>325</span>
<span class=normal>326</span>
<span class=normal>327</span>
<span class=normal>328</span>
<span class=normal>329</span>
<span class=normal>330</span>
<span class=normal>331</span>
<span class=normal>332</span>
<span class=normal>333</span>
<span class=normal>334</span>
<span class=normal>335</span>
<span class=normal>336</span>
<span class=normal>337</span>
<span class=normal>338</span>
<span class=normal>339</span>
<span class=normal>340</span>
<span class=normal>341</span>
<span class=normal>342</span>
<span class=normal>343</span>
<span class=normal>344</span>
<span class=normal>345</span>
<span class=normal>346</span>
<span class=normal>347</span>
<span class=normal>348</span>
<span class=normal>349</span>
<span class=normal>350</span>
<span class=normal>351</span>
<span class=normal>352</span>
<span class=normal>353</span>
<span class=normal>354</span>
<span class=normal>355</span>
<span class=normal>356</span>
<span class=normal>357</span>
<span class=normal>358</span>
<span class=normal>359</span>
<span class=normal>360</span>
<span class=normal>361</span>
<span class=normal>362</span>
<span class=normal>363</span>
<span class=normal>364</span>
<span class=normal>365</span>
<span class=normal>366</span>
<span class=normal>367</span>
<span class=normal>368</span>
<span class=normal>369</span>
<span class=normal>370</span>
<span class=normal>371</span>
<span class=normal>372</span>
<span class=normal>373</span>
<span class=normal>374</span>
<span class=normal>375</span>
<span class=normal>376</span>
<span class=normal>377</span>
<span class=normal>378</span>
<span class=normal>379</span>
<span class=normal>380</span>
<span class=normal>381</span>
<span class=normal>382</span>
<span class=normal>383</span>
<span class=normal>384</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>remove_inactive_cells_pre_task_post</span><span class=p>(</span>
    <span class=n>st</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_eventarray</span><span class=o>.</span><span class=n>SpikeTrainArray</span><span class=p>,</span>
    <span class=n>cell_metrics</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>pd</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>frame</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>,</span> <span class=kc>None</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>beh_epochs</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>nrem_epochs</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>theta_epochs</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
    <span class=n>min_spikes</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span>
    <span class=n>nrem_time</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3600</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    remove_inactive_cells_pre_task_post: Remove cells with fewer than min_spikes spikes per pre/task/post</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    st : SpikeTrainArray</span>
<span class=sd>        SpikeTrainArray object containing spike times for multiple cells.</span>

<span class=sd>    cell_metrics : pd.DataFrame, optional</span>
<span class=sd>        DataFrame containing metrics for each cell (e.g., quality metrics).</span>

<span class=sd>    beh_epochs : EpochArray</span>
<span class=sd>        EpochArray object containing pre/task/post epochs.</span>

<span class=sd>    nrem_epochs : EpochArray</span>
<span class=sd>        EpochArray object containing NREM epochs.</span>

<span class=sd>    theta_epochs : EpochArray</span>
<span class=sd>        EpochArray object containing theta epochs.</span>

<span class=sd>    min_spikes : int, optional</span>
<span class=sd>        Minimum number of spikes required per pre/task/post. Default is 100.</span>

<span class=sd>    nrem_time : int or float, optional</span>
<span class=sd>        Time in seconds to truncate NREM epochs. Default is 3600 seconds.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    Tuple[nel.core._eventarray.SpikeTrainArray, Union[pd.DataFrame, None]]</span>
<span class=sd>        A tuple containing:</span>
<span class=sd>        - SpikeTrainArray object with inactive cells removed.</span>
<span class=sd>        - DataFrame containing cell metrics with inactive cells removed (if provided).</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.process.utils import remove_inactive_cells_pre_task_post</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.io import loading</span>
<span class=sd>    &gt;&gt;&gt; from neuro_py.session.locate_epochs import (</span>
<span class=sd>    &gt;&gt;&gt;     find_multitask_pre_post,</span>
<span class=sd>    &gt;&gt;&gt;     compress_repeated_epochs,</span>
<span class=sd>    &gt;&gt;&gt; )</span>
<span class=sd>    &gt;&gt;&gt; mport nelpy as nel</span>

<span class=sd>    &gt;&gt;&gt; # load data from session</span>
<span class=sd>    &gt;&gt;&gt; basepath = r&quot;Z:\Data\hpc_ctx_project\HP04\day_1_20240320&quot;</span>

<span class=sd>    &gt;&gt;&gt; # load spikes and cell metrics (cm)</span>
<span class=sd>    &gt;&gt;&gt; st, cm = loading.load_spikes(basepath, brainRegion=&quot;CA1&quot;, putativeCellType=&quot;Pyr&quot;)</span>

<span class=sd>    &gt;&gt;&gt; # load epochs and apply multitask epoch restrictions</span>
<span class=sd>    &gt;&gt;&gt; epoch_df = loading.load_epoch(basepath)</span>
<span class=sd>    &gt;&gt;&gt; epoch_df = compress_repeated_epochs(epoch_df)</span>
<span class=sd>    &gt;&gt;&gt; pre_task_post = find_multitask_pre_post(</span>
<span class=sd>    &gt;&gt;&gt;     epoch_df.environment, post_sleep_flank=True, pre_sleep_common=True</span>
<span class=sd>    &gt;&gt;&gt; )</span>

<span class=sd>    &gt;&gt;&gt; beh_epochs = nel.EpochArray(</span>
<span class=sd>    &gt;&gt;&gt;     epoch_df.iloc[pre_task_post[0]][[&quot;startTime&quot;, &quot;stopTime&quot;]].values</span>
<span class=sd>    &gt;&gt;&gt; )</span>

<span class=sd>    &gt;&gt;&gt; # load sleep states to restrict to NREM and theta</span>
<span class=sd>    &gt;&gt;&gt; state_dict = loading.load_SleepState_states(basepath)</span>
<span class=sd>    &gt;&gt;&gt; nrem_epochs = nel.EpochArray(</span>
<span class=sd>    &gt;&gt;&gt;     state_dict[&quot;NREMstate&quot;],</span>
<span class=sd>    &gt;&gt;&gt; )</span>
<span class=sd>    &gt;&gt;&gt; theta_epochs = nel.EpochArray(</span>
<span class=sd>    &gt;&gt;&gt;     state_dict[&quot;THETA&quot;],</span>
<span class=sd>    &gt;&gt;&gt; )</span>

<span class=sd>    &gt;&gt;&gt; st,cm = remove_inactive_cells_pre_task_post(st,cm,beh_epochs,nrem_epochs,theta_epochs)</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># check data types (further checks are done in remove_inactive_cells)</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>beh_epochs</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;beh_epochs must be an EpochArray object&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>nrem_epochs</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;nrem_epochs must be an EpochArray object&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>theta_epochs</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>core</span><span class=o>.</span><span class=n>_intervalarray</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;theta_epochs must be an EpochArray object&quot;</span><span class=p>)</span>

    <span class=c1># create list of restricted epochs</span>
    <span class=n>restict_epochs</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>for</span> <span class=n>epoch</span><span class=p>,</span> <span class=n>epoch_label</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>beh_epochs</span><span class=p>,</span> <span class=p>[</span><span class=s2>&quot;pre&quot;</span><span class=p>,</span> <span class=s2>&quot;task&quot;</span><span class=p>,</span> <span class=s2>&quot;post&quot;</span><span class=p>]):</span>
        <span class=k>if</span> <span class=n>epoch_label</span> <span class=ow>in</span> <span class=s2>&quot;pre&quot;</span><span class=p>:</span>
            <span class=c1># get cumulative hours of sleep</span>
            <span class=n>epoch_restrict</span> <span class=o>=</span> <span class=n>truncate_epoch</span><span class=p>(</span><span class=n>epoch</span> <span class=o>&amp;</span> <span class=n>nrem_epochs</span><span class=p>,</span> <span class=n>time</span><span class=o>=</span><span class=n>nrem_time</span><span class=p>)</span>
        <span class=k>elif</span> <span class=n>epoch_label</span> <span class=ow>in</span> <span class=s2>&quot;post&quot;</span><span class=p>:</span>
            <span class=c1># get cumulative hours of sleep</span>
            <span class=n>epoch_restrict</span> <span class=o>=</span> <span class=n>truncate_epoch</span><span class=p>(</span><span class=n>epoch</span> <span class=o>&amp;</span> <span class=n>nrem_epochs</span><span class=p>,</span> <span class=n>time</span><span class=o>=</span><span class=n>nrem_time</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=c1># get theta during task</span>
            <span class=n>epoch_restrict</span> <span class=o>=</span> <span class=n>epoch</span> <span class=o>&amp;</span> <span class=n>theta_epochs</span>
        <span class=n>restict_epochs</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>epoch_restrict</span><span class=p>)</span>

    <span class=k>return</span> <span class=n>remove_inactive_cells</span><span class=p>(</span>
        <span class=n>st</span><span class=p>,</span> <span class=n>cell_metrics</span><span class=p>,</span> <span class=n>restict_epochs</span><span class=p>,</span> <span class=n>min_spikes</span><span class=o>=</span><span class=n>min_spikes</span>
    <span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.shift_epoch_array class="doc doc-heading"> <code class="highlight language-python"><span class=n>shift_epoch_array</span><span class=p>(</span><span class=n>epoch</span><span class=p>,</span> <span class=n>epoch_shift</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Shift an EpochArray by another EpochArray.</p> <p>Shifting means that intervals in 'epoch' will be relative to intervals in 'epoch_shift' as if 'epoch_shift' intervals were without gaps.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>epoch</code> </td> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>The intervals to shift.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>epoch_shift</code> </td> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>The intervals to shift by.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>The shifted EpochArray.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>This function restricts 'epoch' to those within 'epoch_shift' as epochs between 'epoch_shift' intervals would result in a duration of 0.</p> <p>Visual representation: inputs: epoch = [ ] [ ][] [] epoch_shift = [ ][] [ ] becomes: epoch = [ ] [ ] [] epoch_shift = [ ][][ ]</p> </details> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>499</span>
<span class=normal>500</span>
<span class=normal>501</span>
<span class=normal>502</span>
<span class=normal>503</span>
<span class=normal>504</span>
<span class=normal>505</span>
<span class=normal>506</span>
<span class=normal>507</span>
<span class=normal>508</span>
<span class=normal>509</span>
<span class=normal>510</span>
<span class=normal>511</span>
<span class=normal>512</span>
<span class=normal>513</span>
<span class=normal>514</span>
<span class=normal>515</span>
<span class=normal>516</span>
<span class=normal>517</span>
<span class=normal>518</span>
<span class=normal>519</span>
<span class=normal>520</span>
<span class=normal>521</span>
<span class=normal>522</span>
<span class=normal>523</span>
<span class=normal>524</span>
<span class=normal>525</span>
<span class=normal>526</span>
<span class=normal>527</span>
<span class=normal>528</span>
<span class=normal>529</span>
<span class=normal>530</span>
<span class=normal>531</span>
<span class=normal>532</span>
<span class=normal>533</span>
<span class=normal>534</span>
<span class=normal>535</span>
<span class=normal>536</span>
<span class=normal>537</span>
<span class=normal>538</span>
<span class=normal>539</span>
<span class=normal>540</span>
<span class=normal>541</span>
<span class=normal>542</span>
<span class=normal>543</span>
<span class=normal>544</span>
<span class=normal>545</span>
<span class=normal>546</span>
<span class=normal>547</span>
<span class=normal>548</span>
<span class=normal>549</span>
<span class=normal>550</span>
<span class=normal>551</span>
<span class=normal>552</span>
<span class=normal>553</span>
<span class=normal>554</span>
<span class=normal>555</span>
<span class=normal>556</span>
<span class=normal>557</span>
<span class=normal>558</span>
<span class=normal>559</span>
<span class=normal>560</span>
<span class=normal>561</span>
<span class=normal>562</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>shift_epoch_array</span><span class=p>(</span>
    <span class=n>epoch</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span> <span class=n>epoch_shift</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Shift an EpochArray by another EpochArray.</span>

<span class=sd>    Shifting means that intervals in &#39;epoch&#39; will be relative to</span>
<span class=sd>    intervals in &#39;epoch_shift&#39; as if &#39;epoch_shift&#39; intervals were without gaps.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    epoch : nel.EpochArray</span>
<span class=sd>        The intervals to shift.</span>
<span class=sd>    epoch_shift : nel.EpochArray</span>
<span class=sd>        The intervals to shift by.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    nel.EpochArray</span>
<span class=sd>        The shifted EpochArray.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    This function restricts &#39;epoch&#39; to those within &#39;epoch_shift&#39; as</span>
<span class=sd>    epochs between &#39;epoch_shift&#39; intervals would result in a duration of 0.</span>

<span class=sd>    Visual representation:</span>
<span class=sd>    inputs:</span>
<span class=sd>        epoch       =   [  ]   [  ] [  ]  []</span>
<span class=sd>        epoch_shift =   [    ] [    ]   [    ]</span>
<span class=sd>    becomes:</span>
<span class=sd>        epoch       =   [  ]  [  ]    []</span>
<span class=sd>        epoch_shift =   [    ][    ][    ]</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># input validation</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>epoch</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;epoch must be a nelpy EpochArray&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>epoch_shift</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>):</span>
        <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;epoch_shift must be a nelpy EpochArray&quot;</span><span class=p>)</span>

    <span class=c1># restrict epoch to epoch_shift and extract starts and stops</span>
    <span class=n>epoch_starts</span><span class=p>,</span> <span class=n>epoch_stops</span> <span class=o>=</span> <span class=n>epoch</span><span class=p>[</span><span class=n>epoch_shift</span><span class=p>]</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>T</span>

    <span class=c1># shift starts and stops by epoch_shift</span>
    <span class=n>_</span><span class=p>,</span> <span class=n>epoch_starts_shifted</span> <span class=o>=</span> <span class=n>in_intervals</span><span class=p>(</span><span class=n>epoch_starts</span><span class=p>,</span> <span class=n>epoch_shift</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>shift</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
    <span class=n>_</span><span class=p>,</span> <span class=n>epoch_stops_shifted</span> <span class=o>=</span> <span class=n>in_intervals</span><span class=p>(</span><span class=n>epoch_stops</span><span class=p>,</span> <span class=n>epoch_shift</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>shift</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

    <span class=c1># shift time support as well, if one exists</span>
    <span class=n>support_starts_shifted</span><span class=p>,</span> <span class=n>support_stops_shifted</span> <span class=o>=</span> <span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>inf</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>inf</span>
    <span class=k>if</span> <span class=n>epoch</span><span class=o>.</span><span class=n>domain</span><span class=o>.</span><span class=n>start</span> <span class=o>!=</span> <span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>inf</span><span class=p>:</span>
        <span class=n>_</span><span class=p>,</span> <span class=n>support_starts_shifted</span> <span class=o>=</span> <span class=n>in_intervals</span><span class=p>(</span>
            <span class=n>epoch</span><span class=o>.</span><span class=n>domain</span><span class=o>.</span><span class=n>start</span><span class=p>,</span> <span class=n>epoch_shift</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>shift</span><span class=o>=</span><span class=kc>True</span>
        <span class=p>)</span>
    <span class=k>if</span> <span class=n>epoch</span><span class=o>.</span><span class=n>domain</span><span class=o>.</span><span class=n>stop</span> <span class=o>!=</span> <span class=n>np</span><span class=o>.</span><span class=n>inf</span><span class=p>:</span>
        <span class=n>_</span><span class=p>,</span> <span class=n>support_stops_shifted</span> <span class=o>=</span> <span class=n>in_intervals</span><span class=p>(</span>
            <span class=n>epoch</span><span class=o>.</span><span class=n>domain</span><span class=o>.</span><span class=n>stop</span><span class=p>,</span> <span class=n>epoch_shift</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>shift</span><span class=o>=</span><span class=kc>True</span>
        <span class=p>)</span>

    <span class=n>session_domain</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>([</span><span class=n>support_starts_shifted</span><span class=p>,</span> <span class=n>support_stops_shifted</span><span class=p>])</span>

    <span class=c1># package shifted intervals into epoch array with shifted time support</span>
    <span class=k>return</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=n>epoch_starts_shifted</span><span class=p>,</span> <span class=n>epoch_stops_shifted</span><span class=p>])</span><span class=o>.</span><span class=n>T</span><span class=p>,</span> <span class=n>domain</span><span class=o>=</span><span class=n>session_domain</span>
    <span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.spatial_phase_precession class="doc doc-heading"> <code class="highlight language-python"><span class=n>spatial_phase_precession</span><span class=p>(</span><span class=n>circ</span><span class=p>,</span> <span class=n>lin</span><span class=p>,</span> <span class=n>slope_bounds</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mi>3</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>,</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>])</span></code> </h2> <div class="doc doc-contents "> <p>Compute the circular-linear correlation as described in https://pubmed.ncbi.nlm.nih.gov/22487609/.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>circ</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Circular data in radians (e.g., spike phases).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>lin</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Linear data (e.g., spike positions).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>slope_bounds</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=typing.List>List</span>[<span title=float>float</span>], <span title=typing.Tuple>Tuple</span>[<span title=float>float</span>, <span title=float>float</span>]]</code> </td> <td> <div class=doc-md-description> <p>The slope range for optimization (default is [-3 * np.pi, 3 * np.pi]).</p> </div> </td> <td> <code>[-3 * <span title=numpy.pi>pi</span>, 3 * <span title=numpy.pi>pi</span>]</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>rho</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Circular-linear correlation coefficient.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>pval</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>p-value for testing the significance of the correlation coefficient.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>sl</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Slope of the circular-linear correlation.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code>offs</code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Offset of the circular-linear correlation.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>This method computes a circular-linear correlation and can handle cases where one or both variables may follow a uniform distribution. It differs from the linear-circular correlation used in other studies (e.g., https://science.sciencemag.org/content/340/6138/1342).</p> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>circ</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>uniform</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>lin</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>uniform</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>rho</span><span class=p>,</span> <span class=n>pval</span><span class=p>,</span> <span class=n>sl</span><span class=p>,</span> <span class=n>offs</span> <span class=o>=</span> <span class=n>spatial_phase_precession</span><span class=p>(</span><span class=n>circ</span><span class=p>,</span> <span class=n>lin</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Correlation: </span><span class=si>{</span><span class=n>rho</span><span class=si>}</span><span class=s2>, p-value: </span><span class=si>{</span><span class=n>pval</span><span class=si>}</span><span class=s2>, slope: </span><span class=si>{</span><span class=n>sl</span><span class=si>}</span><span class=s2>, offset: </span><span class=si>{</span><span class=n>offs</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/precession_utils.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>163</span>
<span class=normal>164</span>
<span class=normal>165</span>
<span class=normal>166</span>
<span class=normal>167</span>
<span class=normal>168</span>
<span class=normal>169</span>
<span class=normal>170</span>
<span class=normal>171</span>
<span class=normal>172</span>
<span class=normal>173</span>
<span class=normal>174</span>
<span class=normal>175</span>
<span class=normal>176</span>
<span class=normal>177</span>
<span class=normal>178</span>
<span class=normal>179</span>
<span class=normal>180</span>
<span class=normal>181</span>
<span class=normal>182</span>
<span class=normal>183</span>
<span class=normal>184</span>
<span class=normal>185</span>
<span class=normal>186</span>
<span class=normal>187</span>
<span class=normal>188</span>
<span class=normal>189</span>
<span class=normal>190</span>
<span class=normal>191</span>
<span class=normal>192</span>
<span class=normal>193</span>
<span class=normal>194</span>
<span class=normal>195</span>
<span class=normal>196</span>
<span class=normal>197</span>
<span class=normal>198</span>
<span class=normal>199</span>
<span class=normal>200</span>
<span class=normal>201</span>
<span class=normal>202</span>
<span class=normal>203</span>
<span class=normal>204</span>
<span class=normal>205</span>
<span class=normal>206</span>
<span class=normal>207</span>
<span class=normal>208</span>
<span class=normal>209</span>
<span class=normal>210</span>
<span class=normal>211</span>
<span class=normal>212</span>
<span class=normal>213</span>
<span class=normal>214</span>
<span class=normal>215</span>
<span class=normal>216</span>
<span class=normal>217</span>
<span class=normal>218</span>
<span class=normal>219</span>
<span class=normal>220</span>
<span class=normal>221</span>
<span class=normal>222</span>
<span class=normal>223</span>
<span class=normal>224</span>
<span class=normal>225</span>
<span class=normal>226</span>
<span class=normal>227</span>
<span class=normal>228</span>
<span class=normal>229</span>
<span class=normal>230</span>
<span class=normal>231</span>
<span class=normal>232</span>
<span class=normal>233</span>
<span class=normal>234</span>
<span class=normal>235</span>
<span class=normal>236</span>
<span class=normal>237</span>
<span class=normal>238</span>
<span class=normal>239</span>
<span class=normal>240</span>
<span class=normal>241</span>
<span class=normal>242</span>
<span class=normal>243</span>
<span class=normal>244</span>
<span class=normal>245</span>
<span class=normal>246</span>
<span class=normal>247</span>
<span class=normal>248</span>
<span class=normal>249</span>
<span class=normal>250</span>
<span class=normal>251</span>
<span class=normal>252</span>
<span class=normal>253</span>
<span class=normal>254</span>
<span class=normal>255</span>
<span class=normal>256</span>
<span class=normal>257</span>
<span class=normal>258</span>
<span class=normal>259</span>
<span class=normal>260</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>spatial_phase_precession</span><span class=p>(</span>
    <span class=n>circ</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>lin</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
    <span class=n>slope_bounds</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>],</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]]</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mi>3</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>,</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>],</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the circular-linear correlation as described in https://pubmed.ncbi.nlm.nih.gov/22487609/.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    circ : np.ndarray</span>
<span class=sd>        Circular data in radians (e.g., spike phases).</span>
<span class=sd>    lin : np.ndarray</span>
<span class=sd>        Linear data (e.g., spike positions).</span>
<span class=sd>    slope_bounds : Union[List[float], Tuple[float, float]], optional</span>
<span class=sd>        The slope range for optimization (default is [-3 * np.pi, 3 * np.pi]).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    rho : float</span>
<span class=sd>        Circular-linear correlation coefficient.</span>
<span class=sd>    pval : float</span>
<span class=sd>        p-value for testing the significance of the correlation coefficient.</span>
<span class=sd>    sl : float</span>
<span class=sd>        Slope of the circular-linear correlation.</span>
<span class=sd>    offs : float</span>
<span class=sd>        Offset of the circular-linear correlation.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    This method computes a circular-linear correlation and can handle cases</span>
<span class=sd>    where one or both variables may follow a uniform distribution. It differs from</span>
<span class=sd>    the linear-circular correlation used in other studies (e.g., https://science.sciencemag.org/content/340/6138/1342).</span>

<span class=sd>    Examples</span>
<span class=sd>    -------</span>
<span class=sd>    &gt;&gt;&gt; circ = np.random.uniform(0, 2 * np.pi, 100)</span>
<span class=sd>    &gt;&gt;&gt; lin = np.random.uniform(0, 1, 100)</span>
<span class=sd>    &gt;&gt;&gt; rho, pval, sl, offs = spatial_phase_precession(circ, lin)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;Correlation: {rho}, p-value: {pval}, slope: {sl}, offset: {offs}&quot;)</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># Get rid of all the nans in this data</span>
    <span class=n>nan_index</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>logical_or</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>isnan</span><span class=p>(</span><span class=n>circ</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>isnan</span><span class=p>(</span><span class=n>lin</span><span class=p>))</span>
    <span class=n>circ</span> <span class=o>=</span> <span class=n>circ</span><span class=p>[</span><span class=o>~</span><span class=n>nan_index</span><span class=p>]</span>
    <span class=n>lin</span> <span class=o>=</span> <span class=n>lin</span><span class=p>[</span><span class=o>~</span><span class=n>nan_index</span><span class=p>]</span>

    <span class=c1># Make sure there are still valid data</span>
    <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>size</span><span class=p>(</span><span class=n>lin</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>

    <span class=k>def</span><span class=w> </span><span class=nf>myfun1</span><span class=p>(</span><span class=n>p</span><span class=p>):</span>
        <span class=k>return</span> <span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span>
            <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=n>circ</span> <span class=o>-</span> <span class=p>(</span><span class=n>p</span> <span class=o>*</span> <span class=n>lin</span><span class=p>)))</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>circ</span><span class=p>))</span> <span class=o>**</span> <span class=mi>2</span>
            <span class=o>+</span> <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>circ</span> <span class=o>-</span> <span class=p>(</span><span class=n>p</span> <span class=o>*</span> <span class=n>lin</span><span class=p>)))</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>circ</span><span class=p>))</span> <span class=o>**</span> <span class=mi>2</span>
        <span class=p>)</span>

    <span class=c1># finding the optimal slope, note that we have to restrict the range of slopes</span>

    <span class=n>sl</span> <span class=o>=</span> <span class=n>sp</span><span class=o>.</span><span class=n>optimize</span><span class=o>.</span><span class=n>fminbound</span><span class=p>(</span>
        <span class=n>myfun1</span><span class=p>,</span>
        <span class=n>slope_bounds</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>/</span> <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>lin</span><span class=p>)</span> <span class=o>-</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>lin</span><span class=p>)),</span>
        <span class=n>slope_bounds</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>/</span> <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=n>lin</span><span class=p>)</span> <span class=o>-</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>(</span><span class=n>lin</span><span class=p>)),</span>
    <span class=p>)</span>

    <span class=c1># calculate offset</span>
    <span class=n>offs</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arctan2</span><span class=p>(</span>
        <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>circ</span> <span class=o>-</span> <span class=p>(</span><span class=n>sl</span> <span class=o>*</span> <span class=n>lin</span><span class=p>))),</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=n>circ</span> <span class=o>-</span> <span class=p>(</span><span class=n>sl</span> <span class=o>*</span> <span class=n>lin</span><span class=p>)))</span>
    <span class=p>)</span>
    <span class=c1># offs = (offs + np.pi) % (2 * np.pi) - np.pi</span>
    <span class=n>offs</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arctan2</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>offs</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=n>offs</span><span class=p>))</span>

    <span class=c1># circular variable derived from the linearization</span>
    <span class=n>linear_circ</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mod</span><span class=p>(</span><span class=nb>abs</span><span class=p>(</span><span class=n>sl</span><span class=p>)</span> <span class=o>*</span> <span class=n>lin</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>)</span>

    <span class=c1># # marginal distributions:</span>
    <span class=n>p1</span><span class=p>,</span> <span class=n>z1</span> <span class=o>=</span> <span class=n>pcs</span><span class=o>.</span><span class=n>rayleigh</span><span class=p>(</span><span class=n>circ</span><span class=p>)</span>
    <span class=n>p2</span><span class=p>,</span> <span class=n>z2</span> <span class=o>=</span> <span class=n>pcs</span><span class=o>.</span><span class=n>rayleigh</span><span class=p>(</span><span class=n>linear_circ</span><span class=p>)</span>

    <span class=c1># circular-linear correlation:</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>p1</span> <span class=o>&gt;</span> <span class=mf>0.5</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>p2</span> <span class=o>&gt;</span> <span class=mf>0.5</span><span class=p>):</span>
        <span class=c1># This means at least one of our variables may be a uniform distribution</span>
        <span class=n>rho</span><span class=p>,</span> <span class=n>pval</span> <span class=o>=</span> <span class=n>corrcc_uniform</span><span class=p>(</span><span class=n>circ</span><span class=p>,</span> <span class=n>linear_circ</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>rho</span><span class=p>,</span> <span class=n>pval</span> <span class=o>=</span> <span class=n>corrcc</span><span class=p>(</span><span class=n>circ</span><span class=p>,</span> <span class=n>linear_circ</span><span class=p>)</span>

    <span class=c1># Assign the correct sign to rho</span>
    <span class=k>if</span> <span class=n>sl</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
        <span class=n>rho</span> <span class=o>=</span> <span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>rho</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>rho</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>rho</span><span class=p>)</span>

    <span class=c1># if offs &lt; 0:</span>
    <span class=c1>#     offs = offs + 2 * np.pi</span>
    <span class=c1># if offs &gt; np.pi:</span>
    <span class=c1>#     offs = offs - 2 * np.pi</span>

    <span class=k>return</span> <span class=n>rho</span><span class=p>,</span> <span class=n>pval</span><span class=p>,</span> <span class=n>sl</span><span class=p>,</span> <span class=n>offs</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.split_epoch_by_width class="doc doc-heading"> <code class="highlight language-python"><span class=n>split_epoch_by_width</span><span class=p>(</span><span class=n>intervals</span><span class=p>,</span> <span class=n>bin_width</span><span class=o>=</span><span class=mf>0.001</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Generate combined intervals (start, stop) at a specified width within given intervals.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>intervals</code> </td> <td> <code><span title=typing.List>List</span>[<span title=typing.Tuple>Tuple</span>[<span title=float>float</span>, <span title=float>float</span>]]</code> </td> <td> <div class=doc-md-description> <p>A list of (start, end) tuples representing intervals.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>bin_width</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The width of each bin in seconds. Default is 0.001 (1 ms).</p> </div> </td> <td> <code>0.001</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>A 2D array containing (start, stop) pairs for all bins across intervals.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 81</span>
<span class=normal> 82</span>
<span class=normal> 83</span>
<span class=normal> 84</span>
<span class=normal> 85</span>
<span class=normal> 86</span>
<span class=normal> 87</span>
<span class=normal> 88</span>
<span class=normal> 89</span>
<span class=normal> 90</span>
<span class=normal> 91</span>
<span class=normal> 92</span>
<span class=normal> 93</span>
<span class=normal> 94</span>
<span class=normal> 95</span>
<span class=normal> 96</span>
<span class=normal> 97</span>
<span class=normal> 98</span>
<span class=normal> 99</span>
<span class=normal>100</span>
<span class=normal>101</span>
<span class=normal>102</span>
<span class=normal>103</span>
<span class=normal>104</span>
<span class=normal>105</span>
<span class=normal>106</span>
<span class=normal>107</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>split_epoch_by_width</span><span class=p>(</span>
    <span class=n>intervals</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>Tuple</span><span class=p>[</span><span class=nb>float</span><span class=p>,</span> <span class=nb>float</span><span class=p>]],</span> <span class=n>bin_width</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.001</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Generate combined intervals (start, stop) at a specified width within given intervals.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    intervals : List[Tuple[float, float]]</span>
<span class=sd>        A list of (start, end) tuples representing intervals.</span>
<span class=sd>    bin_width : float</span>
<span class=sd>        The width of each bin in seconds. Default is 0.001 (1 ms).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    np.ndarray</span>
<span class=sd>        A 2D array containing (start, stop) pairs for all bins across intervals.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>bin_intervals</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span> <span class=ow>in</span> <span class=n>intervals</span><span class=p>:</span>
        <span class=c1># Generate bin edges</span>
        <span class=n>edges</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>bin_width</span><span class=p>)</span>
        <span class=n>edges</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>edges</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>  <span class=c1># Ensure the final end is included</span>
        <span class=c1># Generate intervals (start, stop) for each bin</span>
        <span class=n>intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>stack</span><span class=p>((</span><span class=n>edges</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>edges</span><span class=p>[</span><span class=mi>1</span><span class=p>:]),</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>bin_intervals</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>intervals</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>(</span><span class=n>bin_intervals</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.split_epoch_equal_parts class="doc doc-heading"> <code class="highlight language-python"><span class=n>split_epoch_equal_parts</span><span class=p>(</span><span class=n>intervals</span><span class=p>,</span> <span class=n>n_parts</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Split multiple intervals into equal parts.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>intervals</code> </td> <td> <code>(<span title=array>array</span> - <span title=like>like</span>, <span title=shape>shape</span>(<span title=n_intervals>n_intervals</span>, 2))</code> </td> <td> <div class=doc-md-description> <p>The intervals to split.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>n_parts</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of parts to split each interval into.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>return_epoch_array</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, returns the intervals as a nelpy.EpochArray object. Defaults to True.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>split_intervals</code></td> <td> <code>(<span title=array>array</span> - <span title=like>like</span>, <span title=shape>shape</span>(<span title=n_intervals>n_intervals</span> * <span title=n_parts>n_parts</span>, 2) or <span title=nelpy.EpochArray>EpochArray</span>)</code> </td> <td> <div class=doc-md-description> <p>The split intervals.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>110</span>
<span class=normal>111</span>
<span class=normal>112</span>
<span class=normal>113</span>
<span class=normal>114</span>
<span class=normal>115</span>
<span class=normal>116</span>
<span class=normal>117</span>
<span class=normal>118</span>
<span class=normal>119</span>
<span class=normal>120</span>
<span class=normal>121</span>
<span class=normal>122</span>
<span class=normal>123</span>
<span class=normal>124</span>
<span class=normal>125</span>
<span class=normal>126</span>
<span class=normal>127</span>
<span class=normal>128</span>
<span class=normal>129</span>
<span class=normal>130</span>
<span class=normal>131</span>
<span class=normal>132</span>
<span class=normal>133</span>
<span class=normal>134</span>
<span class=normal>135</span>
<span class=normal>136</span>
<span class=normal>137</span>
<span class=normal>138</span>
<span class=normal>139</span>
<span class=normal>140</span>
<span class=normal>141</span>
<span class=normal>142</span>
<span class=normal>143</span>
<span class=normal>144</span>
<span class=normal>145</span>
<span class=normal>146</span>
<span class=normal>147</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>split_epoch_equal_parts</span><span class=p>(</span>
    <span class=n>intervals</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>n_parts</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>return_epoch_array</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Union</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Split multiple intervals into equal parts.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    intervals : array-like, shape (n_intervals, 2)</span>
<span class=sd>        The intervals to split.</span>
<span class=sd>    n_parts : int</span>
<span class=sd>        The number of parts to split each interval into.</span>
<span class=sd>    return_epoch_array : bool, optional</span>
<span class=sd>        If True, returns the intervals as a nelpy.EpochArray object. Defaults to True.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    split_intervals : array-like, shape (n_intervals * n_parts, 2) or nelpy.EpochArray</span>
<span class=sd>        The split intervals.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># Ensure intervals is a numpy array</span>
    <span class=n>intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>intervals</span><span class=p>)</span>

    <span class=c1># Number of intervals</span>
    <span class=n>n_intervals</span> <span class=o>=</span> <span class=n>intervals</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>

    <span class=c1># Preallocate the output array</span>
    <span class=n>split_intervals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>n_intervals</span> <span class=o>*</span> <span class=n>n_parts</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>

    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>interval</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>intervals</span><span class=p>):</span>
        <span class=n>start</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=n>interval</span>
        <span class=n>epoch_parts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>n_parts</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
        <span class=n>epoch_parts</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>((</span><span class=n>epoch_parts</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>epoch_parts</span><span class=p>[</span><span class=mi>1</span><span class=p>:]))</span><span class=o>.</span><span class=n>T</span>
        <span class=n>split_intervals</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>n_parts</span> <span class=p>:</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>n_parts</span><span class=p>]</span> <span class=o>=</span> <span class=n>epoch_parts</span>

    <span class=k>if</span> <span class=n>return_epoch_array</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span><span class=n>split_intervals</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>split_intervals</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=neuro_py.process.truncate_epoch class="doc doc-heading"> <code class="highlight language-python"><span class=n>truncate_epoch</span><span class=p>(</span><span class=n>epoch</span><span class=p>,</span> <span class=n>time</span><span class=o>=</span><span class=mi>3600</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Truncates an EpochArray to achieve a specified cumulative time duration.</p> <p>This function takes an input EpochArray 'epoch' and a 'time' value representing the desired cumulative time duration in seconds. It returns a new EpochArray containing intervals that cumulatively match the specified time.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>epoch</code> </td> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>The input EpochArray containing intervals to be truncated.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>time</code> </td> <td> <code><span title=typing.Union>Union</span>[<span title=int>int</span>, <span title=float>float</span>]</code> </td> <td> <div class=doc-md-description> <p>The desired cumulative time in seconds (default is 3600).</p> </div> </td> <td> <code>3600</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code><span title=nelpy.EpochArray>EpochArray</span></code> </td> <td> <div class=doc-md-description> <p>A new EpochArray containing intervals that cumulatively match the specified time.</p> </div> </td> </tr> </tbody> </table> <details class=algorithm open> <summary>Algorithm</summary> <ol> <li>Calculate the cumulative lengths of intervals in the 'epoch'.</li> <li>If the cumulative time of the 'epoch' is already less than or equal to 'time', return the original 'epoch'.</li> <li>Find the last interval that fits within the specified 'time' and create a new EpochArray 'truncated_intervals' with intervals up to that point.</li> <li>To achieve the desired cumulative time, calculate the remaining time needed to reach 'time'.</li> <li>Add portions of the next interval to 'truncated_intervals' until the desired 'time' is reached or all intervals are used.</li> </ol> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>epoch_data</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>6</span><span class=p>),</span> <span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=mi>10</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>epoch</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span><span class=n>epoch_data</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>truncated_epoch</span> <span class=o>=</span> <span class=n>truncate_epoch</span><span class=p>(</span><span class=n>epoch</span><span class=p>,</span> <span class=n>time</span><span class=o>=</span><span class=mi>7</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>neuro_py/process/intervals.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>422</span>
<span class=normal>423</span>
<span class=normal>424</span>
<span class=normal>425</span>
<span class=normal>426</span>
<span class=normal>427</span>
<span class=normal>428</span>
<span class=normal>429</span>
<span class=normal>430</span>
<span class=normal>431</span>
<span class=normal>432</span>
<span class=normal>433</span>
<span class=normal>434</span>
<span class=normal>435</span>
<span class=normal>436</span>
<span class=normal>437</span>
<span class=normal>438</span>
<span class=normal>439</span>
<span class=normal>440</span>
<span class=normal>441</span>
<span class=normal>442</span>
<span class=normal>443</span>
<span class=normal>444</span>
<span class=normal>445</span>
<span class=normal>446</span>
<span class=normal>447</span>
<span class=normal>448</span>
<span class=normal>449</span>
<span class=normal>450</span>
<span class=normal>451</span>
<span class=normal>452</span>
<span class=normal>453</span>
<span class=normal>454</span>
<span class=normal>455</span>
<span class=normal>456</span>
<span class=normal>457</span>
<span class=normal>458</span>
<span class=normal>459</span>
<span class=normal>460</span>
<span class=normal>461</span>
<span class=normal>462</span>
<span class=normal>463</span>
<span class=normal>464</span>
<span class=normal>465</span>
<span class=normal>466</span>
<span class=normal>467</span>
<span class=normal>468</span>
<span class=normal>469</span>
<span class=normal>470</span>
<span class=normal>471</span>
<span class=normal>472</span>
<span class=normal>473</span>
<span class=normal>474</span>
<span class=normal>475</span>
<span class=normal>476</span>
<span class=normal>477</span>
<span class=normal>478</span>
<span class=normal>479</span>
<span class=normal>480</span>
<span class=normal>481</span>
<span class=normal>482</span>
<span class=normal>483</span>
<span class=normal>484</span>
<span class=normal>485</span>
<span class=normal>486</span>
<span class=normal>487</span>
<span class=normal>488</span>
<span class=normal>489</span>
<span class=normal>490</span>
<span class=normal>491</span>
<span class=normal>492</span>
<span class=normal>493</span>
<span class=normal>494</span>
<span class=normal>495</span>
<span class=normal>496</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>truncate_epoch</span><span class=p>(</span>
    <span class=n>epoch</span><span class=p>:</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>,</span> <span class=n>time</span><span class=p>:</span> <span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3600</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Truncates an EpochArray to achieve a specified cumulative time duration.</span>

<span class=sd>    This function takes an input EpochArray &#39;epoch&#39; and a &#39;time&#39; value representing</span>
<span class=sd>    the desired cumulative time duration in seconds. It returns a new EpochArray</span>
<span class=sd>    containing intervals that cumulatively match the specified time.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    epoch : nel.EpochArray</span>
<span class=sd>        The input EpochArray containing intervals to be truncated.</span>
<span class=sd>    time : Union[int, float], optional</span>
<span class=sd>        The desired cumulative time in seconds (default is 3600).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    nel.EpochArray</span>
<span class=sd>        A new EpochArray containing intervals that cumulatively match</span>
<span class=sd>        the specified time.</span>

<span class=sd>    Algorithm</span>
<span class=sd>    ---------</span>
<span class=sd>    1. Calculate the cumulative lengths of intervals in the &#39;epoch&#39;.</span>
<span class=sd>    2. If the cumulative time of the &#39;epoch&#39; is already less than or equal to &#39;time&#39;,</span>
<span class=sd>        return the original &#39;epoch&#39;.</span>
<span class=sd>    3. Find the last interval that fits within the specified &#39;time&#39; and create a new EpochArray</span>
<span class=sd>        &#39;truncated_intervals&#39; with intervals up to that point.</span>
<span class=sd>    4. To achieve the desired cumulative time, calculate the remaining time needed to reach &#39;time&#39;.</span>
<span class=sd>    5. Add portions of the next interval to &#39;truncated_intervals&#39; until the desired &#39;time&#39; is reached</span>
<span class=sd>        or all intervals are used.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; epoch_data = [(0, 2), (3, 6), (8, 10)]</span>
<span class=sd>    &gt;&gt;&gt; epoch = nel.EpochArray(epoch_data)</span>
<span class=sd>    &gt;&gt;&gt; truncated_epoch = truncate_epoch(epoch, time=7)</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=n>epoch</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>epoch</span>

    <span class=c1># calcuate cumulative lengths</span>
    <span class=n>cumulative_lengths</span> <span class=o>=</span> <span class=n>epoch</span><span class=o>.</span><span class=n>lengths</span><span class=o>.</span><span class=n>cumsum</span><span class=p>()</span>

    <span class=c1># No truncation needed</span>
    <span class=k>if</span> <span class=n>cumulative_lengths</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>time</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>epoch</span>

    <span class=c1># Find the last interval that fits within the time and make new epoch</span>
    <span class=n>idx</span> <span class=o>=</span> <span class=n>cumulative_lengths</span> <span class=o>&lt;=</span> <span class=n>time</span>
    <span class=n>truncated_intervals</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span><span class=n>epoch</span><span class=o>.</span><span class=n>data</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span>

    <span class=c1># It&#39;s unlikely that the last interval will fit perfectly, so add the remainder from the next interval</span>
    <span class=c1>#   until the epoch is the desired length</span>
    <span class=n>interval_i</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>time</span> <span class=o>-</span> <span class=n>truncated_intervals</span><span class=o>.</span><span class=n>duration</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mf>1e-10</span> <span class=ow>or</span> <span class=n>interval_i</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>epoch</span><span class=p>):</span>
        <span class=c1># Add the last interval</span>
        <span class=n>next_interval</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>where</span><span class=p>(</span><span class=n>cumulative_lengths</span> <span class=o>&gt;=</span> <span class=n>time</span><span class=p>)[</span><span class=mi>0</span><span class=p>][</span><span class=n>interval_i</span><span class=p>])</span>

        <span class=n>remainder</span> <span class=o>=</span> <span class=p>(</span>
            <span class=n>nel</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span>
                <span class=p>[</span>
                    <span class=n>epoch</span><span class=p>[</span><span class=n>next_interval</span><span class=p>]</span><span class=o>.</span><span class=n>start</span><span class=p>,</span>
                    <span class=n>epoch</span><span class=p>[</span><span class=n>next_interval</span><span class=p>]</span><span class=o>.</span><span class=n>start</span> <span class=o>+</span> <span class=p>(</span><span class=n>time</span> <span class=o>-</span> <span class=n>truncated_intervals</span><span class=o>.</span><span class=n>duration</span><span class=p>),</span>
                <span class=p>]</span>
            <span class=p>)</span>
            <span class=o>&amp;</span> <span class=n>epoch</span><span class=p>[</span><span class=n>next_interval</span><span class=p>]</span>
        <span class=p>)</span>
        <span class=n>truncated_intervals</span> <span class=o>=</span> <span class=n>truncated_intervals</span> <span class=o>|</span> <span class=n>remainder</span>
        <span class=n>interval_i</span> <span class=o>+=</span> <span class=mi>1</span>

    <span class=k>return</span> <span class=n>truncated_intervals</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> </div> </div> </div> </article> </div> <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> Back to top </button> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../plotting/ class="md-footer__link md-footer__link--prev" aria-label="Previous:  plotting"> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </div> <div class=md-footer__title> <span class=md-footer__direction> Previous </span> <div class=md-ellipsis> plotting </div> </div> </a> <a href=../raw/ class="md-footer__link md-footer__link--next" aria-label="Next:  raw"> <div class=md-footer__title> <span class=md-footer__direction> Next </span> <div class=md-ellipsis> raw </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <div class=md-progress data-md-component=progress role=progressbar></div> <script id=__config type=application/json>{"base": "../../..", "features": ["announce.dismiss", "content.action.edit", "content.action.view", "content.code.annotate", "content.code.copy", "content.tooltips", "content.tabs.link", "navigation.footer", "navigation.indexes", "navigation.instant.prefetch", "navigation.instant.preview", "navigation.instant.progress", "navigation.path", "navigation.sections", "navigation.tabs", "navigation.tabs.sticky", "navigation.top", "navigation.tracking", "search.highlight", "search.suggest", "toc.follow"], "search": "../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script> <script src=../../../assets/javascripts/bundle.f55a23d4.min.js></script> </body> </html>